diff --git a/home/whalien/codebase/cpp/mergebot/eva/output/frameworks_av/6a87ed87-0b39d3eb-fb33f9bc/media@libaudioclient@IAudioPolicyService.no_comments_mergebot.cpp b/home/whalien/codebase/cpp/mergebot/eva/output/frameworks_av/6a87ed87-0b39d3eb-fb33f9bc/media@libaudioclient@IAudioPolicyService.no_comments_merged.cpp
index 2a857db..f421082 100644
--- a/home/whalien/codebase/cpp/mergebot/eva/output/frameworks_av/6a87ed87-0b39d3eb-fb33f9bc/media@libaudioclient@IAudioPolicyService.no_comments_mergebot.cpp
+++ b/home/whalien/codebase/cpp/mergebot/eva/output/frameworks_av/6a87ed87-0b39d3eb-fb33f9bc/media@libaudioclient@IAudioPolicyService.no_comments_merged.cpp
@@ -93 +93,2 @@ enum {
-class BpAudioPolicyService : public BpInterface<IAudioPolicyService> {
+class BpAudioPolicyService : public BpInterface<IAudioPolicyService>
+{
@@ -96,2 +97,5 @@ class BpAudioPolicyService : public BpInterface<IAudioPolicyService> {
-      : BpInterface<IAudioPolicyService>(impl) {}
-  virtual status_t setDeviceConnectionState(audio_devices_t device,
+        : BpInterface<IAudioPolicyService>(impl)
+    {
+    }
+    virtual status_t setDeviceConnectionState(
+                                    audio_devices_t device,
@@ -101 +105,2 @@ class BpAudioPolicyService : public BpInterface<IAudioPolicyService> {
-                                            audio_format_t encodedFormat) {
+                                    audio_format_t encodedFormat)
+    {
@@ -113 +118,3 @@ class BpAudioPolicyService : public BpInterface<IAudioPolicyService> {
-      audio_devices_t device, const char *device_address) {
+                                    audio_devices_t device,
+                                    const char *device_address)
+    {
@@ -124 +131,2 @@ class BpAudioPolicyService : public BpInterface<IAudioPolicyService> {
-                                            audio_format_t encodedFormat) {
+                                              audio_format_t encodedFormat)
+    {
@@ -134 +142,2 @@ class BpAudioPolicyService : public BpInterface<IAudioPolicyService> {
-  virtual status_t setPhoneState(audio_mode_t state) {
+    virtual status_t setPhoneState(audio_mode_t state)
+    {
@@ -141,2 +150,2 @@ class BpAudioPolicyService : public BpInterface<IAudioPolicyService> {
-  virtual status_t setForceUse(audio_policy_force_use_t usage,
-                               audio_policy_forced_cfg_t config) {
+    virtual status_t setForceUse(audio_policy_force_use_t usage, audio_policy_forced_cfg_t config)
+    {
@@ -150,2 +159,2 @@ class BpAudioPolicyService : public BpInterface<IAudioPolicyService> {
-  virtual audio_policy_forced_cfg_t getForceUse(
-      audio_policy_force_use_t usage) {
+    virtual audio_policy_forced_cfg_t getForceUse(audio_policy_force_use_t usage)
+    {
@@ -158 +167,2 @@ class BpAudioPolicyService : public BpInterface<IAudioPolicyService> {
-  virtual audio_io_handle_t getOutput(audio_stream_type_t stream) {
+    virtual audio_io_handle_t getOutput(audio_stream_type_t stream)
+    {
@@ -165,6 +175,12 @@ class BpAudioPolicyService : public BpInterface<IAudioPolicyService> {
-  status_t getOutputForAttr(
-      audio_attributes_t *attr, audio_io_handle_t *output,
-      audio_session_t session, audio_stream_type_t *stream, pid_t pid,
-      uid_t uid, const audio_config_t *config, audio_output_flags_t flags,
-      audio_port_handle_t *selectedDeviceId, audio_port_handle_t *portId,
-      std::vector<audio_io_handle_t> *secondaryOutputs) override {
+    status_t getOutputForAttr(audio_attributes_t *attr,
+                              audio_io_handle_t *output,
+                              audio_session_t session,
+                              audio_stream_type_t *stream,
+                              pid_t pid,
+                              uid_t uid,
+                              const audio_config_t *config,
+                              audio_output_flags_t flags,
+                              audio_port_handle_t *selectedDeviceId,
+                              audio_port_handle_t *portId,
+                              std::vector<audio_io_handle_t> *secondaryOutputs) override
+        {
@@ -230 +246,2 @@ class BpAudioPolicyService : public BpInterface<IAudioPolicyService> {
-  virtual status_t startOutput(audio_port_handle_t portId) {
+    virtual status_t startOutput(audio_port_handle_t portId)
+    {
@@ -237 +254,2 @@ class BpAudioPolicyService : public BpInterface<IAudioPolicyService> {
-  virtual status_t stopOutput(audio_port_handle_t portId) {
+    virtual status_t stopOutput(audio_port_handle_t portId)
+    {
@@ -244 +262,2 @@ class BpAudioPolicyService : public BpInterface<IAudioPolicyService> {
-  virtual void releaseOutput(audio_port_handle_t portId) {
+    virtual void releaseOutput(audio_port_handle_t portId)
+    {
@@ -250,6 +269,12 @@ class BpAudioPolicyService : public BpInterface<IAudioPolicyService> {
-  virtual status_t getInputForAttr(
-      const audio_attributes_t *attr, audio_io_handle_t *input,
-      audio_unique_id_t riid, audio_session_t session, pid_t pid, uid_t uid,
-      const String16 &opPackageName, const audio_config_base_t *config,
-      audio_input_flags_t flags, audio_port_handle_t *selectedDeviceId,
-      audio_port_handle_t *portId) {
+    virtual status_t getInputForAttr(const audio_attributes_t *attr,
+                                     audio_io_handle_t *input,
+                                     audio_unique_id_t riid,
+                                     audio_session_t session,
+                                     pid_t pid,
+                                     uid_t uid,
+                                     const String16& opPackageName,
+                                     const audio_config_base_t *config,
+                                     audio_input_flags_t flags,
+                                     audio_port_handle_t *selectedDeviceId,
+                                     audio_port_handle_t *portId)
+    {
@@ -298 +323,2 @@ class BpAudioPolicyService : public BpInterface<IAudioPolicyService> {
-  virtual status_t startInput(audio_port_handle_t portId) {
+    virtual status_t startInput(audio_port_handle_t portId)
+    {
@@ -306 +332,2 @@ class BpAudioPolicyService : public BpInterface<IAudioPolicyService> {
-  virtual status_t stopInput(audio_port_handle_t portId) {
+    virtual status_t stopInput(audio_port_handle_t portId)
+    {
@@ -313 +340,2 @@ class BpAudioPolicyService : public BpInterface<IAudioPolicyService> {
-  virtual void releaseInput(audio_port_handle_t portId) {
+    virtual void releaseInput(audio_port_handle_t portId)
+    {
@@ -319,2 +347,4 @@ class BpAudioPolicyService : public BpInterface<IAudioPolicyService> {
-  virtual status_t initStreamVolume(audio_stream_type_t stream, int indexMin,
-                                    int indexMax) {
+    virtual status_t initStreamVolume(audio_stream_type_t stream,
+                                    int indexMin,
+                                    int indexMax)
+    {
@@ -329,2 +359,4 @@ class BpAudioPolicyService : public BpInterface<IAudioPolicyService> {
-  virtual status_t setStreamVolumeIndex(audio_stream_type_t stream, int index,
-                                        audio_devices_t device) {
+    virtual status_t setStreamVolumeIndex(audio_stream_type_t stream,
+                                          int index,
+                                          audio_devices_t device)
+    {
@@ -339,2 +371,4 @@ class BpAudioPolicyService : public BpInterface<IAudioPolicyService> {
-  virtual status_t getStreamVolumeIndex(audio_stream_type_t stream, int *index,
-                                        audio_devices_t device) {
+    virtual status_t getStreamVolumeIndex(audio_stream_type_t stream,
+                                          int *index,
+                                          audio_devices_t device)
+    {
@@ -350,3 +384,3 @@ class BpAudioPolicyService : public BpInterface<IAudioPolicyService> {
-  virtual status_t setVolumeIndexForAttributes(const audio_attributes_t &attr,
-                                               int index,
-                                               audio_devices_t device) {
+    virtual status_t setVolumeIndexForAttributes(const audio_attributes_t &attr, int index,
+                                                 audio_devices_t device)
+    {
@@ -364,3 +398,3 @@ class BpAudioPolicyService : public BpInterface<IAudioPolicyService> {
-  virtual status_t getVolumeIndexForAttributes(const audio_attributes_t &attr,
-                                               int &index,
-                                               audio_devices_t device) {
+    virtual status_t getVolumeIndexForAttributes(const audio_attributes_t &attr, int &index,
+                                                 audio_devices_t device)
+    {
@@ -382,2 +416,2 @@ class BpAudioPolicyService : public BpInterface<IAudioPolicyService> {
-  virtual status_t getMinVolumeIndexForAttributes(
-      const audio_attributes_t &attr, int &index) {
+    virtual status_t getMinVolumeIndexForAttributes(const audio_attributes_t &attr, int &index)
+    {
@@ -387,2 +421 @@ class BpAudioPolicyService : public BpInterface<IAudioPolicyService> {
-    status_t status =
-        remote()->transact(GET_MIN_VOLUME_FOR_ATTRIBUTES, data, &reply);
+        status_t status = remote()->transact(GET_MIN_VOLUME_FOR_ATTRIBUTES, data, &reply);
@@ -399,2 +432,2 @@ class BpAudioPolicyService : public BpInterface<IAudioPolicyService> {
-  virtual status_t getMaxVolumeIndexForAttributes(
-      const audio_attributes_t &attr, int &index) {
+    virtual status_t getMaxVolumeIndexForAttributes(const audio_attributes_t &attr, int &index)
+    {
@@ -404,2 +437 @@ class BpAudioPolicyService : public BpInterface<IAudioPolicyService> {
-    status_t status =
-        remote()->transact(GET_MAX_VOLUME_FOR_ATTRIBUTES, data, &reply);
+        status_t status = remote()->transact(GET_MAX_VOLUME_FOR_ATTRIBUTES, data, &reply);
@@ -416 +448,2 @@ class BpAudioPolicyService : public BpInterface<IAudioPolicyService> {
-  virtual uint32_t getStrategyForStream(audio_stream_type_t stream) {
+    virtual uint32_t getStrategyForStream(audio_stream_type_t stream)
+    {
@@ -423 +456,2 @@ class BpAudioPolicyService : public BpInterface<IAudioPolicyService> {
-  virtual audio_devices_t getDevicesForStream(audio_stream_type_t stream) {
+    virtual audio_devices_t getDevicesForStream(audio_stream_type_t stream)
+    {
@@ -430,2 +464,2 @@ class BpAudioPolicyService : public BpInterface<IAudioPolicyService> {
-  virtual audio_io_handle_t getOutputForEffect(
-      const effect_descriptor_t *desc) {
+    virtual audio_io_handle_t getOutputForEffect(const effect_descriptor_t *desc)
+    {
@@ -439,2 +473,5 @@ class BpAudioPolicyService : public BpInterface<IAudioPolicyService> {
-                                  audio_io_handle_t io, uint32_t strategy,
-                                  audio_session_t session, int id) {
+                                        audio_io_handle_t io,
+                                        uint32_t strategy,
+                                        audio_session_t session,
+                                        int id)
+    {
@@ -451 +488,2 @@ class BpAudioPolicyService : public BpInterface<IAudioPolicyService> {
-  virtual status_t unregisterEffect(int id) {
+    virtual status_t unregisterEffect(int id)
+    {
@@ -458 +496,2 @@ class BpAudioPolicyService : public BpInterface<IAudioPolicyService> {
-  virtual status_t setEffectEnabled(int id, bool enabled) {
+    virtual status_t setEffectEnabled(int id, bool enabled)
+    {
@@ -466,2 +505,2 @@ class BpAudioPolicyService : public BpInterface<IAudioPolicyService> {
-  status_t moveEffectsToIo(const std::vector<int> &ids,
-                           audio_io_handle_t io) override {
+    status_t moveEffectsToIo(const std::vector<int>& ids, audio_io_handle_t io) override
+    {
@@ -481,2 +520,2 @@ class BpAudioPolicyService : public BpInterface<IAudioPolicyService> {
-  virtual bool isStreamActive(audio_stream_type_t stream,
-                              uint32_t inPastMs) const {
+    virtual bool isStreamActive(audio_stream_type_t stream, uint32_t inPastMs) const
+    {
@@ -490,2 +529,2 @@ class BpAudioPolicyService : public BpInterface<IAudioPolicyService> {
-  virtual bool isStreamActiveRemotely(audio_stream_type_t stream,
-                                      uint32_t inPastMs) const {
+    virtual bool isStreamActiveRemotely(audio_stream_type_t stream, uint32_t inPastMs) const
+    {
@@ -499 +538,2 @@ class BpAudioPolicyService : public BpInterface<IAudioPolicyService> {
-  virtual bool isSourceActive(audio_source_t source) const {
+    virtual bool isSourceActive(audio_source_t source) const
+    {
@@ -508 +548,2 @@ class BpAudioPolicyService : public BpInterface<IAudioPolicyService> {
-                                             uint32_t *count) {
+                                               uint32_t *count)
+    {
@@ -516,2 +557 @@ class BpAudioPolicyService : public BpInterface<IAudioPolicyService> {
-    status_t status =
-        remote()->transact(QUERY_DEFAULT_PRE_PROCESSING, data, &reply);
+        status_t status = remote()->transact(QUERY_DEFAULT_PRE_PROCESSING, data, &reply);
@@ -530,2 +570 @@ class BpAudioPolicyService : public BpInterface<IAudioPolicyService> {
-  status_t setAllowedCapturePolicy(uid_t uid,
-                                   audio_flags_mask_t flags) override {
+    status_t setAllowedCapturePolicy(uid_t uid, audio_flags_mask_t flags) override {
@@ -539 +578,2 @@ class BpAudioPolicyService : public BpInterface<IAudioPolicyService> {
-  virtual bool isOffloadSupported(const audio_offload_info_t &info) {
+    virtual bool isOffloadSupported(const audio_offload_info_t& info)
+    {
@@ -552,2 +592 @@ class BpAudioPolicyService : public BpInterface<IAudioPolicyService> {
-    status_t status =
-        remote()->transact(IS_DIRECT_OUTPUT_SUPPORTED, data, &reply);
+        status_t status = remote()->transact(IS_DIRECT_OUTPUT_SUPPORTED, data, &reply);
@@ -560 +599,2 @@ class BpAudioPolicyService : public BpInterface<IAudioPolicyService> {
-                                  unsigned int *generation) {
+                                    unsigned int *generation)
+    {
@@ -587 +627,2 @@ class BpAudioPolicyService : public BpInterface<IAudioPolicyService> {
-  virtual status_t getAudioPort(struct audio_port *port) {
+    virtual status_t getAudioPort(struct audio_port *port)
+    {
@@ -603 +644,2 @@ class BpAudioPolicyService : public BpInterface<IAudioPolicyService> {
-                                    audio_patch_handle_t *handle) {
+                                       audio_patch_handle_t *handle)
+    {
@@ -619 +661,2 @@ class BpAudioPolicyService : public BpInterface<IAudioPolicyService> {
-  virtual status_t releaseAudioPatch(audio_patch_handle_t handle) {
+    virtual status_t releaseAudioPatch(audio_patch_handle_t handle)
+    {
@@ -631 +674,2 @@ class BpAudioPolicyService : public BpInterface<IAudioPolicyService> {
-                                    unsigned int *generation) {
+                                      unsigned int *generation)
+    {
@@ -656 +700,2 @@ class BpAudioPolicyService : public BpInterface<IAudioPolicyService> {
-  virtual status_t setAudioPortConfig(const struct audio_port_config *config) {
+    virtual status_t setAudioPortConfig(const struct audio_port_config *config)
+    {
@@ -669 +714,2 @@ class BpAudioPolicyService : public BpInterface<IAudioPolicyService> {
-  virtual void registerClient(const sp<IAudioPolicyServiceClient> &client) {
+    virtual void registerClient(const sp<IAudioPolicyServiceClient>& client)
+    {
@@ -675 +721,2 @@ class BpAudioPolicyService : public BpInterface<IAudioPolicyService> {
-  virtual void setAudioPortCallbacksEnabled(bool enabled) {
+    virtual void setAudioPortCallbacksEnabled(bool enabled)
+    {
@@ -681 +728,2 @@ class BpAudioPolicyService : public BpInterface<IAudioPolicyService> {
-  virtual void setAudioVolumeGroupCallbacksEnabled(bool enabled) {
+    virtual void setAudioVolumeGroupCallbacksEnabled(bool enabled)
+    {
@@ -689 +737,2 @@ class BpAudioPolicyService : public BpInterface<IAudioPolicyService> {
-                                              audio_devices_t *device) {
+                                            audio_devices_t *device)
+    {
@@ -695,2 +744 @@ class BpAudioPolicyService : public BpInterface<IAudioPolicyService> {
-    status_t status =
-        remote()->transact(ACQUIRE_SOUNDTRIGGER_SESSION, data, &reply);
+        status_t status = remote()->transact(ACQUIRE_SOUNDTRIGGER_SESSION, data, &reply);
@@ -708 +756,2 @@ class BpAudioPolicyService : public BpInterface<IAudioPolicyService> {
-  virtual status_t releaseSoundTriggerSession(audio_session_t session) {
+    virtual status_t releaseSoundTriggerSession(audio_session_t session)
+    {
@@ -712,2 +761 @@ class BpAudioPolicyService : public BpInterface<IAudioPolicyService> {
-    status_t status =
-        remote()->transact(RELEASE_SOUNDTRIGGER_SESSION, data, &reply);
+        status_t status = remote()->transact(RELEASE_SOUNDTRIGGER_SESSION, data, &reply);
@@ -719 +767,2 @@ class BpAudioPolicyService : public BpInterface<IAudioPolicyService> {
-  virtual audio_mode_t getPhoneState() {
+    virtual audio_mode_t getPhoneState()
+    {
@@ -728,2 +777,2 @@ class BpAudioPolicyService : public BpInterface<IAudioPolicyService> {
-  virtual status_t registerPolicyMixes(const Vector<AudioMix> &mixes,
-                                       bool registration) {
+    virtual status_t registerPolicyMixes(const Vector<AudioMix>& mixes, bool registration)
+    {
@@ -761 +810,2 @@ class BpAudioPolicyService : public BpInterface<IAudioPolicyService> {
-                                    audio_port_handle_t *portId) {
+                                      audio_port_handle_t *portId)
+    {
@@ -780 +830,2 @@ class BpAudioPolicyService : public BpInterface<IAudioPolicyService> {
-  virtual status_t stopAudioSource(audio_port_handle_t portId) {
+    virtual status_t stopAudioSource(audio_port_handle_t portId)
+    {
@@ -791 +842,2 @@ class BpAudioPolicyService : public BpInterface<IAudioPolicyService> {
-  virtual status_t setMasterMono(bool mono) {
+    virtual status_t setMasterMono(bool mono)
+    {
@@ -801 +853,2 @@ class BpAudioPolicyService : public BpInterface<IAudioPolicyService> {
-  virtual status_t getMasterMono(bool *mono) {
+    virtual status_t getMasterMono(bool *mono)
+    {
@@ -817,2 +870,2 @@ class BpAudioPolicyService : public BpInterface<IAudioPolicyService> {
-  virtual float getStreamVolumeDB(audio_stream_type_t stream, int index,
-                                  audio_devices_t device) {
+    virtual float getStreamVolumeDB(audio_stream_type_t stream, int index, audio_devices_t device)
+    {
@@ -833,3 +886,3 @@ class BpAudioPolicyService : public BpInterface<IAudioPolicyService> {
-                                      bool reported) {
-    if (numSurroundFormats == NULL ||
-        (*numSurroundFormats != 0 &&
+                                        bool reported)
+    {
+        if (numSurroundFormats == NULL || (*numSurroundFormats != 0 &&
@@ -845,2 +898 @@ class BpAudioPolicyService : public BpInterface<IAudioPolicyService> {
-    if (status == NO_ERROR &&
-        (status = (status_t)reply.readInt32()) == NO_ERROR) {
+        if (status == NO_ERROR && (status = (status_t)reply.readInt32()) == NO_ERROR) {
@@ -865,2 +917,2 @@ class BpAudioPolicyService : public BpInterface<IAudioPolicyService> {
-  virtual status_t setSurroundFormatEnabled(audio_format_t audioFormat,
-                                            bool enabled) {
+    virtual status_t setSurroundFormatEnabled(audio_format_t audioFormat, bool enabled)
+    {
@@ -871,2 +923 @@ class BpAudioPolicyService : public BpInterface<IAudioPolicyService> {
-    status_t status =
-        remote()->transact(SET_SURROUND_FORMAT_ENABLED, data, &reply);
+        status_t status = remote()->transact(SET_SURROUND_FORMAT_ENABLED, data, &reply);
@@ -879 +930,2 @@ class BpAudioPolicyService : public BpInterface<IAudioPolicyService> {
-      std::vector<audio_format_t> *formats) {
+                std::vector<audio_format_t> *formats)
+    {
@@ -885,4 +937,2 @@ class BpAudioPolicyService : public BpInterface<IAudioPolicyService> {
-    status_t status =
-        remote()->transact(GET_OFFLOAD_FORMATS_A2DP, data, &reply);
-    if (status != NO_ERROR ||
-        (status = (status_t)reply.readInt32()) != NO_ERROR) {
+        status_t status = remote()->transact(GET_OFFLOAD_FORMATS_A2DP, data, &reply);
+        if (status != NO_ERROR || (status = (status_t)reply.readInt32()) != NO_ERROR) {
@@ -900,2 +950,4 @@ class BpAudioPolicyService : public BpInterface<IAudioPolicyService> {
-                                          int32_t priority, audio_usage_t usage,
-                                          audio_unique_id_t *id) {
+                                            int32_t priority,
+                                            audio_usage_t usage,
+                                            audio_unique_id_t* id)
+    {
@@ -909,2 +961 @@ class BpAudioPolicyService : public BpInterface<IAudioPolicyService> {
-    status_t status =
-        remote()->transact(ADD_STREAM_DEFAULT_EFFECT, data, &reply);
+        status_t status = remote()->transact(ADD_STREAM_DEFAULT_EFFECT, data, &reply);
@@ -918 +969,2 @@ class BpAudioPolicyService : public BpInterface<IAudioPolicyService> {
-  virtual status_t removeStreamDefaultEffect(audio_unique_id_t id) {
+    virtual status_t removeStreamDefaultEffect(audio_unique_id_t id)
+    {
@@ -922,2 +974 @@ class BpAudioPolicyService : public BpInterface<IAudioPolicyService> {
-    status_t status =
-        remote()->transact(REMOVE_STREAM_DEFAULT_EFFECT, data, &reply);
+        status_t status = remote()->transact(REMOVE_STREAM_DEFAULT_EFFECT, data, &reply);
@@ -934 +985,2 @@ class BpAudioPolicyService : public BpInterface<IAudioPolicyService> {
-                                          audio_unique_id_t *id) {
+                                            audio_unique_id_t* id)
+    {
@@ -942,2 +994 @@ class BpAudioPolicyService : public BpInterface<IAudioPolicyService> {
-    status_t status =
-        remote()->transact(ADD_SOURCE_DEFAULT_EFFECT, data, &reply);
+        status_t status = remote()->transact(ADD_SOURCE_DEFAULT_EFFECT, data, &reply);
@@ -951 +1002,2 @@ class BpAudioPolicyService : public BpInterface<IAudioPolicyService> {
-  virtual status_t removeSourceDefaultEffect(audio_unique_id_t id) {
+    virtual status_t removeSourceDefaultEffect(audio_unique_id_t id)
+    {
@@ -955,2 +1007 @@ class BpAudioPolicyService : public BpInterface<IAudioPolicyService> {
-    status_t status =
-        remote()->transact(REMOVE_SOURCE_DEFAULT_EFFECT, data, &reply);
+        status_t status = remote()->transact(REMOVE_SOURCE_DEFAULT_EFFECT, data, &reply);
@@ -962 +1013,2 @@ class BpAudioPolicyService : public BpInterface<IAudioPolicyService> {
-  virtual status_t setAssistantUid(uid_t uid) {
+    virtual status_t setAssistantUid(uid_t uid)
+    {
@@ -972 +1024,2 @@ class BpAudioPolicyService : public BpInterface<IAudioPolicyService> {
-  virtual status_t setA11yServicesUids(const std::vector<uid_t> &uids) {
+    virtual status_t setA11yServicesUids(const std::vector<uid_t>& uids)
+    {
@@ -985 +1038,2 @@ class BpAudioPolicyService : public BpInterface<IAudioPolicyService> {
-  virtual bool isHapticPlaybackSupported() {
+    virtual bool isHapticPlaybackSupported()
+    {
@@ -988,2 +1042 @@ class BpAudioPolicyService : public BpInterface<IAudioPolicyService> {
-    status_t status =
-        remote()->transact(IS_HAPTIC_PLAYBACK_SUPPORTED, data, &reply);
+        status_t status = remote()->transact(IS_HAPTIC_PLAYBACK_SUPPORTED, data, &reply);
@@ -995,2 +1048,2 @@ class BpAudioPolicyService : public BpInterface<IAudioPolicyService> {
-  virtual status_t setUidDeviceAffinities(
-      uid_t uid, const Vector<AudioDeviceTypeAddr> &devices) {
+    virtual status_t setUidDeviceAffinities(uid_t uid, const Vector<AudioDeviceTypeAddr>& devices)
+    {
@@ -1034,2 +1087,2 @@ class BpAudioPolicyService : public BpInterface<IAudioPolicyService> {
-  virtual status_t listAudioProductStrategies(
-      AudioProductStrategyVector &strategies) {
+    virtual status_t listAudioProductStrategies(AudioProductStrategyVector &strategies)
+    {
@@ -1038,2 +1091 @@ class BpAudioPolicyService : public BpInterface<IAudioPolicyService> {
-    status_t status =
-        remote()->transact(LIST_AUDIO_PRODUCT_STRATEGIES, data, &reply);
+        status_t status = remote()->transact(LIST_AUDIO_PRODUCT_STRATEGIES, data, &reply);
@@ -1061,2 +1113,3 @@ class BpAudioPolicyService : public BpInterface<IAudioPolicyService> {
-  virtual status_t getProductStrategyFromAudioAttributes(
-      const AudioAttributes &aa, product_strategy_t &productStrategy) {
+    virtual status_t getProductStrategyFromAudioAttributes(const AudioAttributes &aa,
+                                                           product_strategy_t &productStrategy)
+    {
@@ -1080 +1133,2 @@ class BpAudioPolicyService : public BpInterface<IAudioPolicyService> {
-  virtual status_t listAudioVolumeGroups(AudioVolumeGroupVector &groups) {
+    virtual status_t listAudioVolumeGroups(AudioVolumeGroupVector &groups)
+    {
@@ -1083,2 +1137 @@ class BpAudioPolicyService : public BpInterface<IAudioPolicyService> {
-    status_t status =
-        remote()->transact(LIST_AUDIO_VOLUME_GROUPS, data, &reply);
+        status_t status = remote()->transact(LIST_AUDIO_VOLUME_GROUPS, data, &reply);
@@ -1105,2 +1158,3 @@ class BpAudioPolicyService : public BpInterface<IAudioPolicyService> {
-  virtual status_t getVolumeGroupFromAudioAttributes(
-      const AudioAttributes &aa, volume_group_t &volumeGroup) {
+    virtual status_t getVolumeGroupFromAudioAttributes(const AudioAttributes &aa,
+                                                       volume_group_t &volumeGroup)
+    {
@@ -1124 +1178,2 @@ class BpAudioPolicyService : public BpInterface<IAudioPolicyService> {
-  virtual status_t setRttEnabled(bool enabled) {
+    virtual status_t setRttEnabled(bool enabled)
+    {
@@ -1134 +1189,2 @@ class BpAudioPolicyService : public BpInterface<IAudioPolicyService> {
-  virtual bool isCallScreenModeSupported() {
+    virtual bool isCallScreenModeSupported()
+    {
@@ -1137,2 +1193 @@ class BpAudioPolicyService : public BpInterface<IAudioPolicyService> {
-    status_t status =
-        remote()->transact(IS_CALL_SCREEN_MODE_SUPPORTED, data, &reply);
+        status_t status = remote()->transact(IS_CALL_SCREEN_MODE_SUPPORTED, data, &reply);
@@ -1144,2 +1199,3 @@ class BpAudioPolicyService : public BpInterface<IAudioPolicyService> {
-  virtual status_t setPreferredDeviceForStrategy(
-      product_strategy_t strategy, const AudioDeviceTypeAddr &device) {
+    virtual status_t setPreferredDeviceForStrategy(product_strategy_t strategy,
+            const AudioDeviceTypeAddr &device)
+    {
@@ -1153,2 +1209,2 @@ class BpAudioPolicyService : public BpInterface<IAudioPolicyService> {
-    status = remote()->transact(SET_PREFERRED_DEVICE_FOR_PRODUCT_STRATEGY, data,
-                                &reply);
+        status = remote()->transact(SET_PREFERRED_DEVICE_FOR_PRODUCT_STRATEGY,
+                data, &reply);
@@ -1160,2 +1216,2 @@ class BpAudioPolicyService : public BpInterface<IAudioPolicyService> {
-  virtual status_t removePreferredDeviceForStrategy(
-      product_strategy_t strategy) {
+    virtual status_t removePreferredDeviceForStrategy(product_strategy_t strategy)
+    {
@@ -1165,2 +1221,2 @@ class BpAudioPolicyService : public BpInterface<IAudioPolicyService> {
-    status_t status = remote()->transact(
-        REMOVE_PREFERRED_DEVICE_FOR_PRODUCT_STRATEGY, data, &reply);
+        status_t status = remote()->transact(REMOVE_PREFERRED_DEVICE_FOR_PRODUCT_STRATEGY,
+                data, &reply);
@@ -1173 +1229,2 @@ class BpAudioPolicyService : public BpInterface<IAudioPolicyService> {
-                                                 AudioDeviceTypeAddr &device) {
+            AudioDeviceTypeAddr &device)
+    {
@@ -1177,2 +1234,2 @@ class BpAudioPolicyService : public BpInterface<IAudioPolicyService> {
-    status_t status = remote()->transact(
-        GET_PREFERRED_DEVICE_FOR_PRODUCT_STRATEGY, data, &reply);
+        status_t status = remote()->transact(GET_PREFERRED_DEVICE_FOR_PRODUCT_STRATEGY,
+                data, &reply);
@@ -1189,4 +1246,416 @@ class BpAudioPolicyService : public BpInterface<IAudioPolicyService> {
-status_t BnAudioPolicyService::sanitizeAudioPortConfig(
-    struct audio_port_config *config) {
-  if (config->type == AUDIO_PORT_TYPE_DEVICE &&
-      preventStringOverflow(config->ext.device.address)) {
+IMPLEMENT_META_INTERFACE(AudioPolicyService, "android.media.IAudioPolicyService");
+status_t BnAudioPolicyService::onTransact(
+    uint32_t code, const Parcel& data, Parcel* reply, uint32_t flags)
+{
+    switch (code) {
+        case START_OUTPUT:
+        case STOP_OUTPUT:
+        case RELEASE_OUTPUT:
+        case GET_INPUT_FOR_ATTR:
+        case START_INPUT:
+        case STOP_INPUT:
+        case RELEASE_INPUT:
+        case GET_OUTPUT_FOR_EFFECT:
+        case REGISTER_EFFECT:
+        case UNREGISTER_EFFECT:
+        case SET_EFFECT_ENABLED:
+        case GET_OUTPUT_FOR_ATTR:
+        case ACQUIRE_SOUNDTRIGGER_SESSION:
+        case RELEASE_SOUNDTRIGGER_SESSION:
+        case MOVE_EFFECTS_TO_IO:
+            ALOGW("%s: transaction %d received from PID %d",
+                  __func__, code, IPCThreadState::self()->getCallingPid());
+            switch (code) {
+                case RELEASE_OUTPUT:
+                case RELEASE_INPUT:
+                    break;
+                default:
+                    reply->writeInt32(static_cast<int32_t> (INVALID_OPERATION));
+                    break;
+            }
+            return OK;
+        default:
+            break;
+    }
+    switch (code) {
+        case SET_DEVICE_CONNECTION_STATE:
+        case HANDLE_DEVICE_CONFIG_CHANGE:
+        case SET_PHONE_STATE:
+        case INIT_STREAM_VOLUME:
+        case SET_STREAM_VOLUME:
+        case REGISTER_POLICY_MIXES:
+        case SET_MASTER_MONO:
+        case GET_SURROUND_FORMATS:
+        case SET_SURROUND_FORMAT_ENABLED:
+        case SET_ASSISTANT_UID:
+        case SET_A11Y_SERVICES_UIDS:
+        case SET_UID_DEVICE_AFFINITY:
+        case REMOVE_UID_DEVICE_AFFINITY:
+        case GET_OFFLOAD_FORMATS_A2DP:
+        case LIST_AUDIO_VOLUME_GROUPS:
+        case GET_VOLUME_GROUP_FOR_ATTRIBUTES:
+        case SET_RTT_ENABLED:
+        case IS_CALL_SCREEN_MODE_SUPPORTED:
+        case SET_PREFERRED_DEVICE_FOR_PRODUCT_STRATEGY:
+        case REMOVE_PREFERRED_DEVICE_FOR_PRODUCT_STRATEGY:
+        case GET_PREFERRED_DEVICE_FOR_PRODUCT_STRATEGY: {
+            if (!isServiceUid(IPCThreadState::self()->getCallingUid())) {
+                ALOGW("%s: transaction %d received from PID %d unauthorized UID %d",
+                      __func__, code, IPCThreadState::self()->getCallingPid(),
+                      IPCThreadState::self()->getCallingUid());
+                reply->writeInt32(static_cast<int32_t> (INVALID_OPERATION));
+                return OK;
+            }
+        } break;
+        default:
+            break;
+    }
+    std::string tag("IAudioPolicyService command " + std::to_string(code));
+    TimeCheck check(tag.c_str());
+    switch (code) {
+        case SET_DEVICE_CONNECTION_STATE: {
+            CHECK_INTERFACE(IAudioPolicyService, data, reply);
+            audio_devices_t device =
+                    static_cast <audio_devices_t>(data.readInt32());
+            audio_policy_dev_state_t state =
+                    static_cast <audio_policy_dev_state_t>(data.readInt32());
+            const char *device_address = data.readCString();
+            const char *device_name = data.readCString();
+            audio_format_t codecFormat = static_cast <audio_format_t>(data.readInt32());
+            if (device_address == nullptr || device_name == nullptr) {
+                ALOGE("Bad Binder transaction: SET_DEVICE_CONNECTION_STATE for device %u", device);
+                reply->writeInt32(static_cast<int32_t> (BAD_VALUE));
+            } else {
+                reply->writeInt32(static_cast<uint32_t> (setDeviceConnectionState(device,
+                                                                                  state,
+                                                                                  device_address,
+                                                                                  device_name,
+                                                                                  codecFormat)));
+            }
+            return NO_ERROR;
+        } break;
+        case GET_DEVICE_CONNECTION_STATE: {
+            CHECK_INTERFACE(IAudioPolicyService, data, reply);
+            audio_devices_t device =
+                    static_cast<audio_devices_t> (data.readInt32());
+            const char *device_address = data.readCString();
+            if (device_address == nullptr) {
+                ALOGE("Bad Binder transaction: GET_DEVICE_CONNECTION_STATE for device %u", device);
+                reply->writeInt32(static_cast<int32_t> (AUDIO_POLICY_DEVICE_STATE_UNAVAILABLE));
+            } else {
+                reply->writeInt32(static_cast<uint32_t> (getDeviceConnectionState(device,
+                                                                                  device_address)));
+            }
+            return NO_ERROR;
+        } break;
+        case HANDLE_DEVICE_CONFIG_CHANGE: {
+            CHECK_INTERFACE(IAudioPolicyService, data, reply);
+            audio_devices_t device =
+                    static_cast <audio_devices_t>(data.readInt32());
+            const char *device_address = data.readCString();
+            const char *device_name = data.readCString();
+            audio_format_t codecFormat =
+                    static_cast <audio_format_t>(data.readInt32());
+            if (device_address == nullptr || device_name == nullptr) {
+                ALOGE("Bad Binder transaction: HANDLE_DEVICE_CONFIG_CHANGE for device %u", device);
+                reply->writeInt32(static_cast<int32_t> (BAD_VALUE));
+            } else {
+                reply->writeInt32(static_cast<uint32_t> (handleDeviceConfigChange(device,
+                                                                                  device_address,
+                                                                                  device_name,
+                                                                                  codecFormat)));
+            }
+            return NO_ERROR;
+        } break;
+        case SET_PHONE_STATE: {
+            CHECK_INTERFACE(IAudioPolicyService, data, reply);
+            reply->writeInt32(static_cast <uint32_t>(setPhoneState(
+                    (audio_mode_t) data.readInt32())));
+            return NO_ERROR;
+        } break;
+        case SET_FORCE_USE: {
+            CHECK_INTERFACE(IAudioPolicyService, data, reply);
+            audio_policy_force_use_t usage = static_cast <audio_policy_force_use_t>(
+                    data.readInt32());
+            audio_policy_forced_cfg_t config =
+                    static_cast <audio_policy_forced_cfg_t>(data.readInt32());
+            reply->writeInt32(static_cast <uint32_t>(setForceUse(usage, config)));
+            return NO_ERROR;
+        } break;
+        case GET_FORCE_USE: {
+            CHECK_INTERFACE(IAudioPolicyService, data, reply);
+            audio_policy_force_use_t usage = static_cast <audio_policy_force_use_t>(
+                    data.readInt32());
+            reply->writeInt32(static_cast <uint32_t>(getForceUse(usage)));
+            return NO_ERROR;
+        } break;
+        case GET_OUTPUT: {
+            CHECK_INTERFACE(IAudioPolicyService, data, reply);
+            audio_stream_type_t stream =
+                    static_cast <audio_stream_type_t>(data.readInt32());
+            audio_io_handle_t output = getOutput(stream);
+            reply->writeInt32(static_cast <int>(output));
+            return NO_ERROR;
+        } break;
+        case GET_OUTPUT_FOR_ATTR: {
+            CHECK_INTERFACE(IAudioPolicyService, data, reply);
+            audio_attributes_t attr = AUDIO_ATTRIBUTES_INITIALIZER;
+            status_t status = data.read(&attr, sizeof(audio_attributes_t));
+            if (status != NO_ERROR) {
+                return status;
+            }
+            sanetizeAudioAttributes(&attr);
+            audio_session_t session = (audio_session_t)data.readInt32();
+            audio_stream_type_t stream = AUDIO_STREAM_DEFAULT;
+            bool hasStream = data.readInt32() != 0;
+            if (hasStream) {
+                stream = (audio_stream_type_t)data.readInt32();
+            }
+            pid_t pid = (pid_t)data.readInt32();
+            uid_t uid = (uid_t)data.readInt32();
+            audio_config_t config;
+            memset(&config, 0, sizeof(audio_config_t));
+            data.read(&config, sizeof(audio_config_t));
+            audio_output_flags_t flags =
+                    static_cast <audio_output_flags_t>(data.readInt32());
+            audio_port_handle_t selectedDeviceId = data.readInt32();
+            audio_port_handle_t portId = (audio_port_handle_t)data.readInt32();
+            audio_io_handle_t output = 0;
+            std::vector<audio_io_handle_t> secondaryOutputs;
+            status = getOutputForAttr(&attr,
+                    &output, session, &stream, pid, uid,
+                    &config,
+                    flags, &selectedDeviceId, &portId, &secondaryOutputs);
+            reply->writeInt32(status);
+            status = reply->write(&attr, sizeof(audio_attributes_t));
+            if (status != NO_ERROR) {
+                return status;
+            }
+            reply->writeInt32(output);
+            reply->writeInt32(stream);
+            reply->writeInt32(selectedDeviceId);
+            reply->writeInt32(portId);
+            reply->writeInt32(secondaryOutputs.size());
+            return reply->write(secondaryOutputs.data(),
+                                secondaryOutputs.size() * sizeof(audio_io_handle_t));
+        } break;
+        case START_OUTPUT: {
+            CHECK_INTERFACE(IAudioPolicyService, data, reply);
+            const audio_port_handle_t portId = static_cast <audio_port_handle_t>(data.readInt32());
+            reply->writeInt32(static_cast <uint32_t>(startOutput(portId)));
+            return NO_ERROR;
+        } break;
+        case STOP_OUTPUT: {
+            CHECK_INTERFACE(IAudioPolicyService, data, reply);
+            const audio_port_handle_t portId = static_cast <audio_port_handle_t>(data.readInt32());
+            reply->writeInt32(static_cast <uint32_t>(stopOutput(portId)));
+            return NO_ERROR;
+        } break;
+        case RELEASE_OUTPUT: {
+            CHECK_INTERFACE(IAudioPolicyService, data, reply);
+            const audio_port_handle_t portId = static_cast <audio_port_handle_t>(data.readInt32());
+            releaseOutput(portId);
+            return NO_ERROR;
+        } break;
+        case GET_INPUT_FOR_ATTR: {
+            CHECK_INTERFACE(IAudioPolicyService, data, reply);
+            audio_attributes_t attr = {};
+            data.read(&attr, sizeof(audio_attributes_t));
+            sanetizeAudioAttributes(&attr);
+            audio_io_handle_t input = (audio_io_handle_t)data.readInt32();
+            audio_unique_id_t riid = (audio_unique_id_t)data.readInt32();
+            audio_session_t session = (audio_session_t)data.readInt32();
+            pid_t pid = (pid_t)data.readInt32();
+            uid_t uid = (uid_t)data.readInt32();
+            const String16 opPackageName = data.readString16();
+            audio_config_base_t config;
+            memset(&config, 0, sizeof(audio_config_base_t));
+            data.read(&config, sizeof(audio_config_base_t));
+            audio_input_flags_t flags = (audio_input_flags_t) data.readInt32();
+            audio_port_handle_t selectedDeviceId = (audio_port_handle_t) data.readInt32();
+            audio_port_handle_t portId = (audio_port_handle_t)data.readInt32();
+            status_t status = getInputForAttr(&attr, &input, riid, session, pid, uid,
+                                              opPackageName, &config,
+                                              flags, &selectedDeviceId, &portId);
+            reply->writeInt32(status);
+            if (status == NO_ERROR) {
+                reply->writeInt32(input);
+                reply->writeInt32(selectedDeviceId);
+                reply->writeInt32(portId);
+            }
+            return NO_ERROR;
+        } break;
+        case START_INPUT: {
+            CHECK_INTERFACE(IAudioPolicyService, data, reply);
+            audio_port_handle_t portId = static_cast <audio_port_handle_t>(data.readInt32());
+            status_t status = startInput(portId);
+            reply->writeInt32(static_cast <uint32_t>(status));
+            return NO_ERROR;
+        } break;
+        case STOP_INPUT: {
+            CHECK_INTERFACE(IAudioPolicyService, data, reply);
+            audio_port_handle_t portId = static_cast <audio_port_handle_t>(data.readInt32());
+            reply->writeInt32(static_cast <uint32_t>(stopInput(portId)));
+            return NO_ERROR;
+        } break;
+        case RELEASE_INPUT: {
+            CHECK_INTERFACE(IAudioPolicyService, data, reply);
+            audio_port_handle_t portId = static_cast <audio_port_handle_t>(data.readInt32());
+            releaseInput(portId);
+            return NO_ERROR;
+        } break;
+        case INIT_STREAM_VOLUME: {
+            CHECK_INTERFACE(IAudioPolicyService, data, reply);
+            audio_stream_type_t stream =
+                    static_cast <audio_stream_type_t>(data.readInt32());
+            int indexMin = data.readInt32();
+            int indexMax = data.readInt32();
+            reply->writeInt32(static_cast <uint32_t>(initStreamVolume(stream, indexMin,indexMax)));
+            return NO_ERROR;
+        } break;
+        case SET_STREAM_VOLUME: {
+            CHECK_INTERFACE(IAudioPolicyService, data, reply);
+            audio_stream_type_t stream =
+                    static_cast <audio_stream_type_t>(data.readInt32());
+            int index = data.readInt32();
+            audio_devices_t device = static_cast <audio_devices_t>(data.readInt32());
+            reply->writeInt32(static_cast <uint32_t>(setStreamVolumeIndex(stream,
+                                                                          index,
+                                                                          device)));
+            return NO_ERROR;
+        } break;
+        case GET_STREAM_VOLUME: {
+            CHECK_INTERFACE(IAudioPolicyService, data, reply);
+            audio_stream_type_t stream =
+                    static_cast <audio_stream_type_t>(data.readInt32());
+            audio_devices_t device = static_cast <audio_devices_t>(data.readInt32());
+            int index = 0;
+            status_t status = getStreamVolumeIndex(stream, &index, device);
+            reply->writeInt32(index);
+            reply->writeInt32(static_cast <uint32_t>(status));
+            return NO_ERROR;
+        } break;
+        case GET_STRATEGY_FOR_STREAM: {
+            CHECK_INTERFACE(IAudioPolicyService, data, reply);
+            audio_stream_type_t stream =
+                    static_cast <audio_stream_type_t>(data.readInt32());
+            reply->writeUint32(getStrategyForStream(stream));
+            return NO_ERROR;
+        } break;
+        case SET_VOLUME_ATTRIBUTES: {
+            CHECK_INTERFACE(IAudioPolicyService, data, reply);
+            audio_attributes_t attributes = {};
+            status_t status = data.read(&attributes, sizeof(audio_attributes_t));
+            if (status != NO_ERROR) {
+                return status;
+            }
+            int index = data.readInt32();
+            audio_devices_t device = static_cast <audio_devices_t>(data.readInt32());
+            reply->writeInt32(static_cast <uint32_t>(setVolumeIndexForAttributes(attributes,
+                                                                                 index, device)));
+            return NO_ERROR;
+        } break;
+        case GET_VOLUME_ATTRIBUTES: {
+            CHECK_INTERFACE(IAudioPolicyService, data, reply);
+            audio_attributes_t attributes = {};
+            status_t status = data.read(&attributes, sizeof(audio_attributes_t));
+            if (status != NO_ERROR) {
+                return status;
+            }
+            audio_devices_t device = static_cast <audio_devices_t>(data.readInt32());
+            int index = 0;
+            status = getVolumeIndexForAttributes(attributes, index, device);
+            reply->writeInt32(static_cast <uint32_t>(status));
+            if (status == NO_ERROR) {
+                reply->writeInt32(index);
+            }
+            return NO_ERROR;
+        } break;
+        case GET_MIN_VOLUME_FOR_ATTRIBUTES: {
+            CHECK_INTERFACE(IAudioPolicyService, data, reply);
+            audio_attributes_t attributes = {};
+            status_t status = data.read(&attributes, sizeof(audio_attributes_t));
+            if (status != NO_ERROR) {
+                return status;
+            }
+            int index = 0;
+            status = getMinVolumeIndexForAttributes(attributes, index);
+            reply->writeInt32(static_cast <uint32_t>(status));
+            if (status == NO_ERROR) {
+                reply->writeInt32(index);
+            }
+            return NO_ERROR;
+        } break;
+        case GET_MAX_VOLUME_FOR_ATTRIBUTES: {
+            CHECK_INTERFACE(IAudioPolicyService, data, reply);
+            audio_attributes_t attributes = {};
+            status_t status = data.read(&attributes, sizeof(audio_attributes_t));
+            if (status != NO_ERROR) {
+                return status;
+            }
+            int index = 0;
+            status = getMaxVolumeIndexForAttributes(attributes, index);
+            reply->writeInt32(static_cast <uint32_t>(status));
+            if (status == NO_ERROR) {
+                reply->writeInt32(index);
+            }
+            return NO_ERROR;
+        } break;
+        case GET_DEVICES_FOR_STREAM: {
+            CHECK_INTERFACE(IAudioPolicyService, data, reply);
+            audio_stream_type_t stream =
+                    static_cast <audio_stream_type_t>(data.readInt32());
+            reply->writeInt32(static_cast <int>(getDevicesForStream(stream)));
+            return NO_ERROR;
+        } break;
+        case GET_OUTPUT_FOR_EFFECT: {
+            CHECK_INTERFACE(IAudioPolicyService, data, reply);
+            effect_descriptor_t desc = {};
+            if (data.read(&desc, sizeof(desc)) != NO_ERROR) {
+                android_errorWriteLog(0x534e4554, "73126106");
+            }
+            (void)sanitizeEffectDescriptor(&desc);
+            audio_io_handle_t output = getOutputForEffect(&desc);
+            reply->writeInt32(static_cast <int>(output));
+            return NO_ERROR;
+        } break;
+        case REGISTER_EFFECT: {
+            CHECK_INTERFACE(IAudioPolicyService, data, reply);
+            effect_descriptor_t desc = {};
+            if (data.read(&desc, sizeof(desc)) != NO_ERROR) {
+                android_errorWriteLog(0x534e4554, "73126106");
+            }
+            (void)sanitizeEffectDescriptor(&desc);
+            audio_io_handle_t io = data.readInt32();
+            uint32_t strategy = data.readInt32();
+            audio_session_t session = (audio_session_t) data.readInt32();
+            int id = data.readInt32();
+            reply->writeInt32(static_cast <int32_t>(registerEffect(&desc,
+                                                                   io,
+                                                                   strategy,
+                                                                   session,
+                                                                   id)));
+            return NO_ERROR;
+        } break;
+        case UNREGISTER_EFFECT: {
+            CHECK_INTERFACE(IAudioPolicyService, data, reply);
+            int id = data.readInt32();
+            reply->writeInt32(static_cast <int32_t>(unregisterEffect(id)));
+            return NO_ERROR;
+        } break;
+        case SET_EFFECT_ENABLED: {
+            CHECK_INTERFACE(IAudioPolicyService, data, reply);
+            int id = data.readInt32();
+            bool enabled = static_cast <bool>(data.readInt32());
+            reply->writeInt32(static_cast <int32_t>(setEffectEnabled(id, enabled)));
+            return NO_ERROR;
+        } break;
+        case MOVE_EFFECTS_TO_IO: {
+            CHECK_INTERFACE(IAudioPolicyService, data, reply);
+            std::vector<int> ids;
+            int32_t size;
+            status_t status = data.readInt32(&size);
+            if (status != NO_ERROR) {
+                return status;
+            }
+            if (size > MAX_ITEMS_PER_LIST) {
@@ -1194,0 +1664,344 @@ status_t BnAudioPolicyService::sanitizeAudioPortConfig(
+            for (int32_t i = 0; i < size; i++) {
+                int id;
+                status = data.readInt32(&id);
+                if (status != NO_ERROR) {
+                    return status;
+                }
+                ids.push_back(id);
+            }
+            audio_io_handle_t io = data.readInt32();
+            reply->writeInt32(static_cast <int32_t>(moveEffectsToIo(ids, io)));
+            return NO_ERROR;
+        } break;
+        case IS_STREAM_ACTIVE: {
+            CHECK_INTERFACE(IAudioPolicyService, data, reply);
+            audio_stream_type_t stream = (audio_stream_type_t) data.readInt32();
+            uint32_t inPastMs = (uint32_t)data.readInt32();
+            reply->writeInt32( isStreamActive(stream, inPastMs) );
+            return NO_ERROR;
+        } break;
+        case IS_STREAM_ACTIVE_REMOTELY: {
+            CHECK_INTERFACE(IAudioPolicyService, data, reply);
+            audio_stream_type_t stream = (audio_stream_type_t) data.readInt32();
+            uint32_t inPastMs = (uint32_t)data.readInt32();
+            reply->writeInt32( isStreamActiveRemotely(stream, inPastMs) );
+            return NO_ERROR;
+        } break;
+        case IS_SOURCE_ACTIVE: {
+            CHECK_INTERFACE(IAudioPolicyService, data, reply);
+            audio_source_t source = (audio_source_t) data.readInt32();
+            reply->writeInt32( isSourceActive(source));
+            return NO_ERROR;
+        }
+        case QUERY_DEFAULT_PRE_PROCESSING: {
+            CHECK_INTERFACE(IAudioPolicyService, data, reply);
+            audio_session_t audioSession = (audio_session_t) data.readInt32();
+            uint32_t count = data.readInt32();
+            if (count > AudioEffect::kMaxPreProcessing) {
+                count = AudioEffect::kMaxPreProcessing;
+            }
+            uint32_t retCount = count;
+            effect_descriptor_t *descriptors = new effect_descriptor_t[count]{};
+            status_t status = queryDefaultPreProcessing(audioSession, descriptors, &retCount);
+            reply->writeInt32(status);
+            if (status != NO_ERROR && status != NO_MEMORY) {
+                retCount = 0;
+            }
+            reply->writeInt32(retCount);
+            if (retCount != 0) {
+                if (retCount < count) {
+                    count = retCount;
+                }
+                reply->write(descriptors, sizeof(effect_descriptor_t) * count);
+            }
+            delete[] descriptors;
+            return status;
+        }
+        case IS_OFFLOAD_SUPPORTED: {
+            CHECK_INTERFACE(IAudioPolicyService, data, reply);
+            audio_offload_info_t info = {};
+            data.read(&info, sizeof(audio_offload_info_t));
+            bool isSupported = isOffloadSupported(info);
+            reply->writeInt32(isSupported);
+            return NO_ERROR;
+        }
+        case IS_DIRECT_OUTPUT_SUPPORTED: {
+            CHECK_INTERFACE(IAudioPolicyService, data, reply);
+            audio_config_base_t config = {};
+            audio_attributes_t attributes = {};
+            status_t status = data.read(&config, sizeof(audio_config_base_t));
+            if (status != NO_ERROR) return status;
+            status = data.read(&attributes, sizeof(audio_attributes_t));
+            if (status != NO_ERROR) return status;
+            reply->writeInt32(isDirectOutputSupported(config, attributes));
+            return NO_ERROR;
+        }
+        case LIST_AUDIO_PORTS: {
+            CHECK_INTERFACE(IAudioPolicyService, data, reply);
+            audio_port_role_t role = (audio_port_role_t)data.readInt32();
+            audio_port_type_t type = (audio_port_type_t)data.readInt32();
+            unsigned int numPortsReq = data.readInt32();
+            if (numPortsReq > MAX_ITEMS_PER_LIST) {
+                numPortsReq = MAX_ITEMS_PER_LIST;
+            }
+            unsigned int numPorts = numPortsReq;
+            struct audio_port *ports =
+                    (struct audio_port *)calloc(numPortsReq, sizeof(struct audio_port));
+            if (ports == NULL) {
+                reply->writeInt32(NO_MEMORY);
+                reply->writeInt32(0);
+                return NO_ERROR;
+            }
+            unsigned int generation;
+            status_t status = listAudioPorts(role, type, &numPorts, ports, &generation);
+            reply->writeInt32(status);
+            reply->writeInt32(numPorts);
+            if (status == NO_ERROR) {
+                if (numPortsReq > numPorts) {
+                    numPortsReq = numPorts;
+                }
+                reply->write(ports, numPortsReq * sizeof(struct audio_port));
+                reply->writeInt32(generation);
+            }
+            free(ports);
+            return NO_ERROR;
+        }
+        case GET_AUDIO_PORT: {
+            CHECK_INTERFACE(IAudioPolicyService, data, reply);
+            struct audio_port port = {};
+            if (data.read(&port, sizeof(struct audio_port)) != NO_ERROR) {
+                ALOGE("b/23912202");
+            }
+            status_t status = getAudioPort(&port);
+            reply->writeInt32(status);
+            if (status == NO_ERROR) {
+                reply->write(&port, sizeof(struct audio_port));
+            }
+            return NO_ERROR;
+        }
+        case CREATE_AUDIO_PATCH: {
+            CHECK_INTERFACE(IAudioPolicyService, data, reply);
+            struct audio_patch patch = {};
+            data.read(&patch, sizeof(struct audio_patch));
+            audio_patch_handle_t handle = AUDIO_PATCH_HANDLE_NONE;
+            if (data.read(&handle, sizeof(audio_patch_handle_t)) != NO_ERROR) {
+                ALOGE("b/23912202");
+            }
+            status_t status = createAudioPatch(&patch, &handle);
+            reply->writeInt32(status);
+            if (status == NO_ERROR) {
+                reply->write(&handle, sizeof(audio_patch_handle_t));
+            }
+            return NO_ERROR;
+        }
+        case RELEASE_AUDIO_PATCH: {
+            CHECK_INTERFACE(IAudioPolicyService, data, reply);
+            audio_patch_handle_t handle = AUDIO_PATCH_HANDLE_NONE;
+            data.read(&handle, sizeof(audio_patch_handle_t));
+            status_t status = releaseAudioPatch(handle);
+            reply->writeInt32(status);
+            return NO_ERROR;
+        }
+        case LIST_AUDIO_PATCHES: {
+            CHECK_INTERFACE(IAudioPolicyService, data, reply);
+            unsigned int numPatchesReq = data.readInt32();
+            if (numPatchesReq > MAX_ITEMS_PER_LIST) {
+                numPatchesReq = MAX_ITEMS_PER_LIST;
+            }
+            unsigned int numPatches = numPatchesReq;
+            struct audio_patch *patches =
+                    (struct audio_patch *)calloc(numPatchesReq,
+                                                 sizeof(struct audio_patch));
+            if (patches == NULL) {
+                reply->writeInt32(NO_MEMORY);
+                reply->writeInt32(0);
+                return NO_ERROR;
+            }
+            unsigned int generation;
+            status_t status = listAudioPatches(&numPatches, patches, &generation);
+            reply->writeInt32(status);
+            reply->writeInt32(numPatches);
+            if (status == NO_ERROR) {
+                if (numPatchesReq > numPatches) {
+                    numPatchesReq = numPatches;
+                }
+                reply->write(patches, numPatchesReq * sizeof(struct audio_patch));
+                reply->writeInt32(generation);
+            }
+            free(patches);
+            return NO_ERROR;
+        }
+        case SET_AUDIO_PORT_CONFIG: {
+            CHECK_INTERFACE(IAudioPolicyService, data, reply);
+            struct audio_port_config config = {};
+            data.read(&config, sizeof(struct audio_port_config));
+            (void)sanitizeAudioPortConfig(&config);
+            status_t status = setAudioPortConfig(&config);
+            reply->writeInt32(status);
+            return NO_ERROR;
+        }
+        case REGISTER_CLIENT: {
+            CHECK_INTERFACE(IAudioPolicyService, data, reply);
+            sp<IAudioPolicyServiceClient> client = interface_cast<IAudioPolicyServiceClient>(
+                    data.readStrongBinder());
+            registerClient(client);
+            return NO_ERROR;
+        } break;
+        case SET_AUDIO_PORT_CALLBACK_ENABLED: {
+            CHECK_INTERFACE(IAudioPolicyService, data, reply);
+            setAudioPortCallbacksEnabled(data.readInt32() == 1);
+            return NO_ERROR;
+        } break;
+        case SET_AUDIO_VOLUME_GROUP_CALLBACK_ENABLED: {
+            CHECK_INTERFACE(IAudioPolicyService, data, reply);
+            setAudioVolumeGroupCallbacksEnabled(data.readInt32() == 1);
+            return NO_ERROR;
+        } break;
+        case ACQUIRE_SOUNDTRIGGER_SESSION: {
+            CHECK_INTERFACE(IAudioPolicyService, data, reply);
+            sp<IAudioPolicyServiceClient> client = interface_cast<IAudioPolicyServiceClient>(
+                    data.readStrongBinder());
+            audio_session_t session = AUDIO_SESSION_NONE;
+            audio_io_handle_t ioHandle = AUDIO_IO_HANDLE_NONE;
+            audio_devices_t device = AUDIO_DEVICE_NONE;
+            status_t status = acquireSoundTriggerSession(&session, &ioHandle, &device);
+            reply->writeInt32(status);
+            if (status == NO_ERROR) {
+                reply->writeInt32(session);
+                reply->writeInt32(ioHandle);
+                reply->writeInt32(device);
+            }
+            return NO_ERROR;
+        } break;
+        case RELEASE_SOUNDTRIGGER_SESSION: {
+            CHECK_INTERFACE(IAudioPolicyService, data, reply);
+            sp<IAudioPolicyServiceClient> client = interface_cast<IAudioPolicyServiceClient>(
+                    data.readStrongBinder());
+            audio_session_t session = (audio_session_t)data.readInt32();
+            status_t status = releaseSoundTriggerSession(session);
+            reply->writeInt32(status);
+            return NO_ERROR;
+        } break;
+        case GET_PHONE_STATE: {
+            CHECK_INTERFACE(IAudioPolicyService, data, reply);
+            reply->writeInt32((int32_t)getPhoneState());
+            return NO_ERROR;
+        } break;
+        case REGISTER_POLICY_MIXES: {
+            CHECK_INTERFACE(IAudioPolicyService, data, reply);
+            bool registration = data.readInt32() == 1;
+            Vector<AudioMix> mixes;
+            size_t size = (size_t)data.readInt32();
+            if (size > MAX_MIXES_PER_POLICY) {
+                size = MAX_MIXES_PER_POLICY;
+            }
+            for (size_t i = 0; i < size; i++) {
+                AudioMix mix;
+                if (mix.readFromParcel((Parcel*)&data) == NO_ERROR) {
+                    mixes.add(mix);
+                }
+            }
+            status_t status = registerPolicyMixes(mixes, registration);
+            reply->writeInt32(status);
+            return NO_ERROR;
+        } break;
+        case START_AUDIO_SOURCE: {
+            CHECK_INTERFACE(IAudioPolicyService, data, reply);
+            struct audio_port_config source = {};
+            data.read(&source, sizeof(struct audio_port_config));
+            (void)sanitizeAudioPortConfig(&source);
+            audio_attributes_t attributes = {};
+            data.read(&attributes, sizeof(audio_attributes_t));
+            sanetizeAudioAttributes(&attributes);
+            audio_port_handle_t portId = AUDIO_PORT_HANDLE_NONE;
+            status_t status = startAudioSource(&source, &attributes, &portId);
+            reply->writeInt32(status);
+            reply->writeInt32(portId);
+            return NO_ERROR;
+        } break;
+        case STOP_AUDIO_SOURCE: {
+            CHECK_INTERFACE(IAudioPolicyService, data, reply);
+            audio_port_handle_t portId = (audio_port_handle_t) data.readInt32();
+            status_t status = stopAudioSource(portId);
+            reply->writeInt32(status);
+            return NO_ERROR;
+        } break;
+        case SET_MASTER_MONO: {
+            CHECK_INTERFACE(IAudioPolicyService, data, reply);
+            bool mono = static_cast<bool>(data.readInt32());
+            status_t status = setMasterMono(mono);
+            reply->writeInt32(status);
+            return NO_ERROR;
+        } break;
+        case GET_MASTER_MONO: {
+            CHECK_INTERFACE(IAudioPolicyService, data, reply);
+            bool mono;
+            status_t status = getMasterMono(&mono);
+            reply->writeInt32(status);
+            if (status == NO_ERROR) {
+                reply->writeInt32(static_cast<int32_t>(mono));
+            }
+            return NO_ERROR;
+        } break;
+        case GET_STREAM_VOLUME_DB: {
+            CHECK_INTERFACE(IAudioPolicyService, data, reply);
+            audio_stream_type_t stream =
+                    static_cast <audio_stream_type_t>(data.readInt32());
+            int index = static_cast <int>(data.readInt32());
+            audio_devices_t device =
+                    static_cast <audio_devices_t>(data.readUint32());
+            reply->writeFloat(getStreamVolumeDB(stream, index, device));
+            return NO_ERROR;
+        }
+        case GET_SURROUND_FORMATS: {
+            CHECK_INTERFACE(IAudioPolicyService, data, reply);
+            unsigned int numSurroundFormatsReq = data.readUint32();
+            if (numSurroundFormatsReq > MAX_ITEMS_PER_LIST) {
+                numSurroundFormatsReq = MAX_ITEMS_PER_LIST;
+            }
+            bool reported = data.readBool();
+            unsigned int numSurroundFormats = numSurroundFormatsReq;
+            audio_format_t *surroundFormats = (audio_format_t *)calloc(
+                    numSurroundFormats, sizeof(audio_format_t));
+            bool *surroundFormatsEnabled = (bool *)calloc(numSurroundFormats, sizeof(bool));
+            if (numSurroundFormatsReq > 0 &&
+                    (surroundFormats == NULL || surroundFormatsEnabled == NULL)) {
+                free(surroundFormats);
+                free(surroundFormatsEnabled);
+                reply->writeInt32(NO_MEMORY);
+                return NO_ERROR;
+            }
+            status_t status = getSurroundFormats(
+                    &numSurroundFormats, surroundFormats, surroundFormatsEnabled, reported);
+            reply->writeInt32(status);
+            if (status == NO_ERROR) {
+                reply->writeUint32(numSurroundFormats);
+                if (numSurroundFormatsReq > numSurroundFormats) {
+                    numSurroundFormatsReq = numSurroundFormats;
+                }
+                reply->write(surroundFormats, numSurroundFormatsReq * sizeof(audio_format_t));
+                reply->write(surroundFormatsEnabled, numSurroundFormatsReq * sizeof(bool));
+            }
+            free(surroundFormats);
+            free(surroundFormatsEnabled);
+            return NO_ERROR;
+        }
+        case SET_SURROUND_FORMAT_ENABLED: {
+            CHECK_INTERFACE(IAudioPolicyService, data, reply);
+            audio_format_t audioFormat = (audio_format_t) data.readInt32();
+            bool enabled = data.readBool();
+            status_t status = setSurroundFormatEnabled(audioFormat, enabled);
+            reply->writeInt32(status);
+            return NO_ERROR;
+        }
+        case GET_OFFLOAD_FORMATS_A2DP: {
+            CHECK_INTERFACE(IAudioPolicyService, data, reply);
+            std::vector<audio_format_t> encodingFormats;
+            status_t status = getHwOffloadEncodingFormatsSupportedForA2DP(&encodingFormats);
+            reply->writeInt32(status);
+            if (status != NO_ERROR) {
+                return NO_ERROR;
+            }
+            reply->writeUint32(static_cast<uint32_t>(encodingFormats.size()));
+            for (size_t i = 0; i < encodingFormats.size(); i++)
+                reply->writeInt32(static_cast<int32_t>(encodingFormats[i]));
@@ -1196,0 +2010,274 @@ status_t BnAudioPolicyService::sanitizeAudioPortConfig(
+        case ADD_STREAM_DEFAULT_EFFECT: {
+            CHECK_INTERFACE(IAudioPolicyService, data, reply);
+            effect_uuid_t type;
+            status_t status = data.read(&type, sizeof(effect_uuid_t));
+            if (status != NO_ERROR) {
+                return status;
+            }
+            String16 opPackageName;
+            status = data.readString16(&opPackageName);
+            if (status != NO_ERROR) {
+                return status;
+            }
+            effect_uuid_t uuid;
+            status = data.read(&uuid, sizeof(effect_uuid_t));
+            if (status != NO_ERROR) {
+                return status;
+            }
+            int32_t priority = data.readInt32();
+            audio_usage_t usage = (audio_usage_t) data.readInt32();
+            audio_unique_id_t id = 0;
+            reply->writeInt32(static_cast <int32_t>(addStreamDefaultEffect(&type,
+                                                                           opPackageName,
+                                                                           &uuid,
+                                                                           priority,
+                                                                           usage,
+                                                                           &id)));
+            reply->writeInt32(id);
+            return NO_ERROR;
+        }
+        case REMOVE_STREAM_DEFAULT_EFFECT: {
+            CHECK_INTERFACE(IAudioPolicyService, data, reply);
+            audio_unique_id_t id = static_cast<audio_unique_id_t>(data.readInt32());
+            reply->writeInt32(static_cast <int32_t>(removeStreamDefaultEffect(id)));
+            return NO_ERROR;
+        }
+        case ADD_SOURCE_DEFAULT_EFFECT: {
+            CHECK_INTERFACE(IAudioPolicyService, data, reply);
+            effect_uuid_t type;
+            status_t status = data.read(&type, sizeof(effect_uuid_t));
+            if (status != NO_ERROR) {
+                return status;
+            }
+            String16 opPackageName;
+            status = data.readString16(&opPackageName);
+            if (status != NO_ERROR) {
+                return status;
+            }
+            effect_uuid_t uuid;
+            status = data.read(&uuid, sizeof(effect_uuid_t));
+            if (status != NO_ERROR) {
+                return status;
+            }
+            int32_t priority = data.readInt32();
+            audio_source_t source = (audio_source_t) data.readInt32();
+            audio_unique_id_t id = 0;
+            reply->writeInt32(static_cast <int32_t>(addSourceDefaultEffect(&type,
+                                                                           opPackageName,
+                                                                           &uuid,
+                                                                           priority,
+                                                                           source,
+                                                                           &id)));
+            reply->writeInt32(id);
+            return NO_ERROR;
+        }
+        case REMOVE_SOURCE_DEFAULT_EFFECT: {
+            CHECK_INTERFACE(IAudioPolicyService, data, reply);
+            audio_unique_id_t id = static_cast<audio_unique_id_t>(data.readInt32());
+            reply->writeInt32(static_cast <int32_t>(removeSourceDefaultEffect(id)));
+            return NO_ERROR;
+        }
+        case SET_ASSISTANT_UID: {
+            CHECK_INTERFACE(IAudioPolicyService, data, reply);
+            int32_t uid;
+            status_t status = data.readInt32(&uid);
+            if (status != NO_ERROR) {
+                return status;
+            }
+            status = setAssistantUid(uid);
+            reply->writeInt32(static_cast <int32_t>(status));
+            return NO_ERROR;
+        }
+        case SET_A11Y_SERVICES_UIDS: {
+            CHECK_INTERFACE(IAudioPolicyService, data, reply);
+            std::vector<uid_t> uids;
+            int32_t size;
+            status_t status = data.readInt32(&size);
+            if (status != NO_ERROR) {
+                return status;
+            }
+            if (size > MAX_ITEMS_PER_LIST) {
+                size = MAX_ITEMS_PER_LIST;
+            }
+            for (int32_t i = 0; i < size; i++) {
+                int32_t uid;
+                status = data.readInt32(&uid);
+                if (status != NO_ERROR) {
+                    return status;
+                }
+                uids.push_back(uid);
+            }
+            status = setA11yServicesUids(uids);
+            reply->writeInt32(static_cast <int32_t>(status));
+            return NO_ERROR;
+        }
+        case IS_HAPTIC_PLAYBACK_SUPPORTED: {
+            CHECK_INTERFACE(IAudioPolicyService, data, reply);
+            bool isSupported = isHapticPlaybackSupported();
+            reply->writeBool(isSupported);
+            return NO_ERROR;
+        }
+        case SET_UID_DEVICE_AFFINITY: {
+            CHECK_INTERFACE(IAudioPolicyService, data, reply);
+            const uid_t uid = (uid_t) data.readInt32();
+            Vector<AudioDeviceTypeAddr> devices;
+            size_t size = (size_t)data.readInt32();
+            for (size_t i = 0; i < size; i++) {
+                AudioDeviceTypeAddr device;
+                if (device.readFromParcel((Parcel*)&data) == NO_ERROR) {
+                    devices.add(device);
+                }
+            }
+            status_t status = setUidDeviceAffinities(uid, devices);
+            reply->writeInt32(status);
+            return NO_ERROR;
+        }
+        case REMOVE_UID_DEVICE_AFFINITY: {
+            CHECK_INTERFACE(IAudioPolicyService, data, reply);
+            const uid_t uid = (uid_t) data.readInt32();
+            status_t status = removeUidDeviceAffinities(uid);
+            reply->writeInt32(status);
+            return NO_ERROR;
+        }
+        case LIST_AUDIO_PRODUCT_STRATEGIES: {
+            CHECK_INTERFACE(IAudioPolicyService, data, reply);
+            AudioProductStrategyVector strategies;
+            status_t status = listAudioProductStrategies(strategies);
+            reply->writeInt32(status);
+            if (status != NO_ERROR) {
+                return NO_ERROR;
+            }
+            size_t size = strategies.size();
+            size_t sizePosition = reply->dataPosition();
+            reply->writeInt32(size);
+            size_t finalSize = size;
+            for (size_t i = 0; i < size; i++) {
+                size_t position = reply->dataPosition();
+                if (strategies[i].writeToParcel(reply) != NO_ERROR) {
+                    reply->setDataPosition(position);
+                    finalSize--;
+                }
+            }
+            if (size != finalSize) {
+                size_t position = reply->dataPosition();
+                reply->setDataPosition(sizePosition);
+                reply->writeInt32(finalSize);
+                reply->setDataPosition(position);
+            }
+            return NO_ERROR;
+        }
+        case GET_STRATEGY_FOR_ATTRIBUTES: {
+            CHECK_INTERFACE(IAudioPolicyService, data, reply);
+            AudioAttributes attributes;
+            status_t status = attributes.readFromParcel(&data);
+            if (status != NO_ERROR) {
+                return status;
+            }
+            product_strategy_t strategy;
+            status = getProductStrategyFromAudioAttributes(attributes, strategy);
+            reply->writeInt32(status);
+            if (status != NO_ERROR) {
+                return NO_ERROR;
+            }
+            reply->writeUint32(static_cast<int>(strategy));
+            return NO_ERROR;
+        }
+        case LIST_AUDIO_VOLUME_GROUPS: {
+            CHECK_INTERFACE(IAudioPolicyService, data, reply);
+            AudioVolumeGroupVector groups;
+            status_t status = listAudioVolumeGroups(groups);
+            reply->writeInt32(status);
+            if (status != NO_ERROR) {
+                return NO_ERROR;
+            }
+            size_t size = groups.size();
+            size_t sizePosition = reply->dataPosition();
+            reply->writeInt32(size);
+            size_t finalSize = size;
+            for (size_t i = 0; i < size; i++) {
+                size_t position = reply->dataPosition();
+                if (groups[i].writeToParcel(reply) != NO_ERROR) {
+                    reply->setDataPosition(position);
+                    finalSize--;
+                }
+            }
+            if (size != finalSize) {
+                size_t position = reply->dataPosition();
+                reply->setDataPosition(sizePosition);
+                reply->writeInt32(finalSize);
+                reply->setDataPosition(position);
+            }
+            return NO_ERROR;
+        }
+        case GET_VOLUME_GROUP_FOR_ATTRIBUTES: {
+            CHECK_INTERFACE(IAudioPolicyService, data, reply);
+            AudioAttributes attributes;
+            status_t status = attributes.readFromParcel(&data);
+            if (status != NO_ERROR) {
+                return status;
+            }
+            volume_group_t group;
+            status = getVolumeGroupFromAudioAttributes(attributes, group);
+            reply->writeInt32(status);
+            if (status != NO_ERROR) {
+                return NO_ERROR;
+            }
+            reply->writeUint32(static_cast<int>(group));
+            return NO_ERROR;
+        }
+        case SET_ALLOWED_CAPTURE_POLICY: {
+            CHECK_INTERFACE(IAudioPolicyService, data, reply);
+            uid_t uid = data.readInt32();
+            audio_flags_mask_t flags = data.readInt32();
+            status_t status = setAllowedCapturePolicy(uid, flags);
+            reply->writeInt32(status);
+            return NO_ERROR;
+        }
+        case SET_RTT_ENABLED: {
+            CHECK_INTERFACE(IAudioPolicyService, data, reply);
+            bool enabled = static_cast<bool>(data.readInt32());
+            status_t status = setRttEnabled(enabled);
+            reply->writeInt32(status);
+            return NO_ERROR;
+        }
+        case IS_CALL_SCREEN_MODE_SUPPORTED: {
+            CHECK_INTERFACE(IAudioPolicyService, data, reply);
+            bool isAvailable = isCallScreenModeSupported();
+            reply->writeBool(isAvailable);
+            return NO_ERROR;
+        }
+        case SET_PREFERRED_DEVICE_FOR_PRODUCT_STRATEGY: {
+            CHECK_INTERFACE(IAudioPolicyService, data, reply);
+            product_strategy_t strategy = (product_strategy_t) data.readUint32();
+            AudioDeviceTypeAddr device;
+            status_t status = device.readFromParcel((Parcel*)&data);
+            if (status != NO_ERROR) {
+                return status;
+            }
+            status = setPreferredDeviceForStrategy(strategy, device);
+            reply->writeInt32(status);
+            return NO_ERROR;
+        }
+        case REMOVE_PREFERRED_DEVICE_FOR_PRODUCT_STRATEGY: {
+            CHECK_INTERFACE(IAudioPolicyService, data, reply);
+            product_strategy_t strategy = (product_strategy_t) data.readUint32();
+            status_t status = removePreferredDeviceForStrategy(strategy);
+            reply->writeInt32(status);
+            return NO_ERROR;
+        }
+        case GET_PREFERRED_DEVICE_FOR_PRODUCT_STRATEGY: {
+            CHECK_INTERFACE(IAudioPolicyService, data, reply);
+            product_strategy_t strategy = (product_strategy_t) data.readUint32();
+            AudioDeviceTypeAddr device;
+            status_t status = getPreferredDeviceForStrategy(strategy, device);
+            status_t marshall_status = device.writeToParcel(reply);
+            if (marshall_status != NO_ERROR) {
+                return marshall_status;
+            }
+            reply->writeInt32(status);
+            return NO_ERROR;
+        }
+        default:
+            return BBinder::onTransact(code, data, reply, flags);
+    }
+}
@@ -1203,5 +2290,5 @@ static bool preventStringOverflow(char (&s)[size]) {
-status_t BnAudioPolicyService::sanitizeAudioPortConfig(
-    struct audio_port_config *config) {
-  if (config->type == AUDIO_PORT_TYPE_DEVICE &&
-      preventStringOverflow(config->ext.device.address)) {
-    return BAD_VALUE;
+void BnAudioPolicyService::sanetizeAudioAttributes(audio_attributes_t* attr)
+{
+    const size_t tagsMaxSize = AUDIO_ATTRIBUTES_TAGS_MAX_SIZE;
+    if (strnlen(attr->tags, tagsMaxSize) >= tagsMaxSize) {
+        android_errorWriteLog(0x534e4554, "68953950");
@@ -1209 +2296 @@ status_t BnAudioPolicyService::sanitizeAudioPortConfig(
-  return NO_ERROR;
+    attr->tags[tagsMaxSize - 1] = '\0';
@@ -1211,4 +2298,5 @@ status_t BnAudioPolicyService::sanitizeAudioPortConfig(
-status_t BnAudioPolicyService::sanitizeAudioPortConfig(
-    struct audio_port_config *config) {
-  if (config->type == AUDIO_PORT_TYPE_DEVICE &&
-      preventStringOverflow(config->ext.device.address)) {
+status_t BnAudioPolicyService::sanitizeEffectDescriptor(effect_descriptor_t* desc)
+{
+    if (preventStringOverflow(desc->name)
+        | preventStringOverflow(desc->implementor)) {
+        android_errorWriteLog(0x534e4554, "73126106");
@@ -1219,2 +2307,2 @@ status_t BnAudioPolicyService::sanitizeAudioPortConfig(
-status_t BnAudioPolicyService::sanitizeAudioPortConfig(
-    struct audio_port_config *config) {
+status_t BnAudioPolicyService::sanitizeAudioPortConfig(struct audio_port_config* config)
+{
