diff --git a/output/art/3713d6b7-b33635d2-2a539ab0/runtime@reference_table.no_comments_mergebot.cc b/output/art/3713d6b7-b33635d2-2a539ab0/runtime@reference_table.no_comments_truth.cc
index c56142d..a3bb256 100644
--- a/output/art/3713d6b7-b33635d2-2a539ab0/runtime@reference_table.no_comments_mergebot.cc
+++ b/output/art/3713d6b7-b33635d2-2a539ab0/runtime@reference_table.no_comments_truth.cc
@@ -39,4 +39,4 @@ void ReferenceTable::Remove(ObjPtr<mirror::Object> obj) {
-void ReferenceTable::VisitRoots(RootVisitor* visitor, const RootInfo& root_info) {
-  BufferedRootVisitor<kDefaultBufferedRootCount> buffered_visitor(visitor, root_info);
-  for (GcRoot<mirror::Object>& root : entries_) {
-    buffered_visitor.VisitRoot(root);
+static size_t GetElementCount(ObjPtr<mirror::Object> obj) REQUIRES_SHARED(Locks::mutator_lock_) {
+  DCHECK(!Runtime::Current()->GetClearedJniWeakGlobal()->IsArrayInstance());
+  if (obj == nullptr || !obj->IsArrayInstance()) {
+    return 0;
@@ -43,0 +44 @@ void ReferenceTable::VisitRoots(RootVisitor* visitor, const RootInfo& root_info)
+  return obj->AsArray()->GetLength();
@@ -69,0 +71,160 @@ static void DumpSummaryLine(std::ostream& os, ObjPtr<mirror::Object> obj, size_t
+size_t ReferenceTable::Size() const {
+  return entries_.size();
+}
+void ReferenceTable::Dump(std::ostream& os) {
+  os << name_ << " reference table dump:\n";
+  Dump(os, entries_);
+}
+void ReferenceTable::Dump(std::ostream& os, Table& entries) {
+  struct GcRootComparator {
+    bool operator()(GcRoot<mirror::Object> root1, GcRoot<mirror::Object> root2) const
+        NO_THREAD_SAFETY_ANALYSIS {
+      Locks::mutator_lock_->AssertSharedHeld(Thread::Current());
+      ObjPtr<mirror::Object> obj1 = root1.Read<kWithoutReadBarrier>();
+      ObjPtr<mirror::Object> obj2 = root2.Read<kWithoutReadBarrier>();
+      DCHECK(obj1 != nullptr);
+      DCHECK(obj2 != nullptr);
+      Runtime* runtime = Runtime::Current();
+      DCHECK(!runtime->IsClearedJniWeakGlobal(obj1));
+      DCHECK(!runtime->IsClearedJniWeakGlobal(obj2));
+      if (obj1->GetClass() != obj2->GetClass()) {
+        return obj1->GetClass() < obj2->GetClass();
+      }
+      const size_t size1 = obj1->SizeOf();
+      const size_t size2 = obj2->SizeOf();
+      if (size1 != size2) {
+        return size1 < size2;
+      }
+      return obj1.Ptr() < obj2.Ptr();
+    }
+  };
+  if (entries.empty()) {
+    os << "  (empty)\n";
+    return;
+  }
+  const size_t kLast = 10;
+  size_t count = entries.size();
+  int first = count - kLast;
+  if (first < 0) {
+    first = 0;
+  }
+  os << "  Last " << (count - first) << " entries (of " << count << "):\n";
+  Runtime* runtime = Runtime::Current();
+  for (int idx = count - 1; idx >= first; --idx) {
+    ObjPtr<mirror::Object> ref = entries[idx].Read();
+    if (ref == nullptr) {
+      continue;
+    }
+    if (runtime->IsClearedJniWeakGlobal(ref)) {
+      os << StringPrintf("    %5d: cleared jweak\n", idx);
+      continue;
+    }
+    if (ref->GetClass() == nullptr) {
+      size_t size = ref->SizeOf();
+      os << StringPrintf("    %5d: %p (raw) (%zd bytes)\n", idx, ref.Ptr(), size);
+      continue;
+    }
+    std::string className(ref->PrettyTypeOf());
+    std::string extras;
+    size_t element_count = GetElementCount(ref);
+    if (element_count != 0) {
+      StringAppendF(&extras, " (%zd elements)", element_count);
+    } else if (ref->GetClass()->IsStringClass()) {
+      ObjPtr<mirror::String> s = ref->AsString();
+      std::string utf8(s->ToModifiedUtf8());
+      if (s->GetLength() <= 16) {
+        StringAppendF(&extras, " \"%s\"", utf8.c_str());
+      } else {
+        StringAppendF(&extras, " \"%.16s... (%d chars)", utf8.c_str(), s->GetLength());
+      }
+    } else if (ref->IsReferenceInstance()) {
+      ObjPtr<mirror::Object> referent = ref->AsReference()->GetReferent();
+      if (referent == nullptr) {
+        extras = " (referent is null)";
+      } else {
+        extras = StringPrintf(" (referent is a %s)", referent->PrettyTypeOf().c_str());
+      }
+    }
+    os << StringPrintf("    %5d: ", idx) << ref << " " << className << extras << "\n";
+  }
+  Table sorted_entries;
+  for (GcRoot<mirror::Object>& root : entries) {
+    if (!root.IsNull() && !runtime->IsClearedJniWeakGlobal(root.Read())) {
+      sorted_entries.push_back(root);
+    }
+  }
+  if (sorted_entries.empty()) {
+    return;
+  }
+  std::sort(sorted_entries.begin(), sorted_entries.end(), GcRootComparator());
+  class SummaryElement {
+   public:
+    GcRoot<mirror::Object> root;
+    size_t equiv;
+    size_t identical;
+    SummaryElement() : equiv(0), identical(0) {}
+    SummaryElement(SummaryElement&& ref) {
+      root = ref.root;
+      equiv = ref.equiv;
+      identical = ref.identical;
+    }
+    SummaryElement(const SummaryElement&) = default;
+    SummaryElement& operator=(SummaryElement&&) = default;
+    void Reset(GcRoot<mirror::Object>& _root) {
+      root = _root;
+      equiv = 0;
+      identical = 0;
+    }
+  };
+  std::vector<SummaryElement> sorted_summaries;
+  {
+    SummaryElement prev;
+    for (GcRoot<mirror::Object>& root : sorted_entries) {
+      ObjPtr<mirror::Object> current = root.Read<kWithoutReadBarrier>();
+      if (UNLIKELY(prev.root.IsNull())) {
+        prev.Reset(root);
+        continue;
+      }
+      ObjPtr<mirror::Object> prevObj = prev.root.Read<kWithoutReadBarrier>();
+      if (current == prevObj) {
+        ++prev.identical;
+      } else if (current->GetClass() == prevObj->GetClass() &&
+          GetElementCount(current) == GetElementCount(prevObj)) {
+        ++prev.equiv;
+      } else {
+        sorted_summaries.push_back(prev);
+        prev.Reset(root);
+      }
+      prev.root = root;
+    }
+    sorted_summaries.push_back(prev);
+    struct SummaryElementComparator {
+      GcRootComparator gc_root_cmp;
+      bool operator()(SummaryElement& elem1, SummaryElement& elem2) const
+          NO_THREAD_SAFETY_ANALYSIS {
+        Locks::mutator_lock_->AssertSharedHeld(Thread::Current());
+        size_t count1 = elem1.equiv + elem1.identical;
+        size_t count2 = elem2.equiv + elem2.identical;
+        if (count1 != count2) {
+          return count1 > count2;
+        }
+        if (elem1.identical != elem2.identical) {
+          return elem1.identical > elem2.identical;
+        }
+        return gc_root_cmp(elem1.root, elem2.root);
+      }
+    };
+    std::sort(sorted_summaries.begin(), sorted_summaries.end(), SummaryElementComparator());
+  }
+  os << "  Summary:\n";
+  for (SummaryElement& elem : sorted_summaries) {
+    ObjPtr<mirror::Object> elemObj = elem.root.Read<kWithoutReadBarrier>();
+    DumpSummaryLine(os, elemObj, GetElementCount(elemObj), elem.identical, elem.equiv);
+  }
+}
+void ReferenceTable::VisitRoots(RootVisitor* visitor, const RootInfo& root_info) {
+  BufferedRootVisitor<kDefaultBufferedRootCount> buffered_visitor(visitor, root_info);
+  for (GcRoot<mirror::Object>& root : entries_) {
+    buffered_visitor.VisitRoot(root);
+  }
+}
