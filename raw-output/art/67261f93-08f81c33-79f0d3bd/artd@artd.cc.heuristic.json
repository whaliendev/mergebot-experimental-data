[
  {
    "desc": "Added code or method extraction, accept our side.",
    "confidence": 0.7,
    "index": 0,
    "label": "",
    "code": [
      "CopyAndRewriteProfileResult AnalyzeCopyAndRewriteProfileFailure(",
      "    File* src, ProfmanResult::CopyAndUpdateResult result) {",
      "  DCHECK(result == ProfmanResult::kCopyAndUpdateNoMatch ||",
      "         result == ProfmanResult::kCopyAndUpdateErrorFailedToLoadProfile);",
      "",
      "  auto bad_profile = [&](std::string_view error_msg) {",
      "    return CopyAndRewriteProfileResult{",
      "        .status = CopyAndRewriteProfileResult::Status::BAD_PROFILE,",
      "        .errorMsg = ART_FORMAT(\"Failed to load profile '{}': {}\", src->GetPath(), error_msg)};",
      "  };",
      "  CopyAndRewriteProfileResult no_profile{.status = CopyAndRewriteProfileResult::Status::NO_PROFILE,",
      "                                         .errorMsg = \"\"};",
      "",
      "  int64_t length = src->GetLength();",
      "  if (length < 0) {",
      "    return bad_profile(strerror(-length));",
      "  }",
      "  if (length == 0) {",
      "    return no_profile;",
      "  }",
      "",
      "  std::string error_msg;",
      "  uint32_t magic;",
      "  if (!ReadMagicAndReset(src->Fd(), &magic, &error_msg)) {",
      "    return bad_profile(error_msg);",
      "  }",
      "  if (IsZipMagic(magic)) {",
      "    std::unique_ptr<ZipArchive> zip_archive(",
      "        ZipArchive::OpenFromOwnedFd(src->Fd(), src->GetPath().c_str(), &error_msg));",
      "    if (zip_archive == nullptr) {",
      "      return bad_profile(error_msg);",
      "    }",
      "    std::unique_ptr<ZipEntry> zip_entry(zip_archive->Find(\"primary.prof\", &error_msg));",
      "    if (zip_entry == nullptr || zip_entry->GetUncompressedLength() == 0) {",
      "      return no_profile;",
      "    }",
      "  }",
      "",
      "  if (result == ProfmanResult::kCopyAndUpdateNoMatch) {",
      "    return bad_profile(",
      "        \"The profile does not match the APK (The checksums in the profile do not match the \"",
      "        \"checksums of the .dex files in the APK)\");",
      "  }",
      "  return bad_profile(\"The profile is in the wrong format or an I/O error has occurred\");",
      "}",
      "",
      "// Returns the fd on success, or an invalid fd if the dex file contains no profile, or error if any",
      "// error occurs.",
      "Result<File> ExtractEmbeddedProfileToFd(const std::string& dex_path) {",
      "  std::unique_ptr<File> dex_file = OR_RETURN(OpenFileForReading(dex_path));",
      "",
      "  std::string error_msg;",
      "  uint32_t magic;",
      "  if (!ReadMagicAndReset(dex_file->Fd(), &magic, &error_msg)) {",
      "    return Error() << error_msg;",
      "  }",
      "  if (!IsZipMagic(magic)) {",
      "    if (DexFileLoader::IsMagicValid(magic)) {",
      "      // The dex file can be a plain dex file. This is expected.",
      "      return File();",
      "    }",
      "    return Error() << \"File is neither a zip file nor a plain dex file\";",
      "  }",
      "",
      "  std::unique_ptr<ZipArchive> zip_archive(",
      "      ZipArchive::OpenFromOwnedFd(dex_file->Fd(), dex_path.c_str(), &error_msg));",
      "  if (zip_archive == nullptr) {",
      "    return Error() << error_msg;",
      "  }",
      "  constexpr const char* kEmbeddedProfileEntry = \"assets/art-profile/baseline.prof\";",
      "  std::unique_ptr<ZipEntry> zip_entry(zip_archive->Find(kEmbeddedProfileEntry, &error_msg));",
      "  size_t size;",
      "  if (zip_entry == nullptr || (size = zip_entry->GetUncompressedLength()) == 0) {",
      "    // From system/libziparchive/zip_error.cpp.",
      "    constexpr const char* kEntryNotFound = \"Entry not found\";",
      "    if (error_msg != kEntryNotFound) {",
      "      LOG(WARNING) << ART_FORMAT(",
      "          \"Failed to find zip entry '{}' in '{}': {}\", kEmbeddedProfileEntry, dex_path, error_msg);",
      "    }",
      "    // The dex file doesn't necessarily contain a profile. This is expected.",
      "    return File();",
      "  }",
      "",
      "  // The name is for debugging only.",
      "  std::string memfd_name =",
      "      ART_FORMAT(\"{} extracted in memory from {}\", kEmbeddedProfileEntry, dex_path);",
      "  File memfd(memfd_create(memfd_name.c_str(), /*flags=*/0),",
      "             memfd_name,",
      "             /*check_usage=*/false);",
      "  if (!memfd.IsValid()) {",
      "    return ErrnoError() << \"Failed to create memfd\";",
      "  }",
      "  if (ftruncate(memfd.Fd(), size) != 0) {",
      "    return ErrnoError() << \"Failed to ftruncate memfd\";",
      "  }",
      "  // Map with MAP_SHARED because we're feeding the fd to profman.",
      "  MemMap mem_map = MemMap::MapFile(size,",
      "                                   PROT_READ | PROT_WRITE,",
      "                                   MAP_SHARED,",
      "                                   memfd.Fd(),",
      "                                   /*start=*/0,",
      "                                   /*low_4gb=*/false,",
      "                                   memfd_name.c_str(),",
      "                                   &error_msg);",
      "  if (!mem_map.IsValid()) {",
      "    return Errorf(\"Failed to mmap memfd: {}\", error_msg);",
      "  }",
      "  if (!zip_entry->ExtractToMemory(mem_map.Begin(), &error_msg)) {",
      "    return Errorf(\"Failed to extract '{}': {}\", kEmbeddedProfileEntry, error_msg);",
      "  }",
      "",
      "  return memfd;",
      "}",
      ""
    ]
  },
  {
    "code": [
      "ndk::ScopedAStatus Artd::copyAndRewriteProfile(const ProfilePath& in_src,",
      "                                               OutputProfile* in_dst,",
      "                                               const std::string& in_dexFile,",
      "                                               CopyAndRewriteProfileResult* _aidl_return) {",
      "  std::string src_path = OR_RETURN_FATAL(BuildProfileOrDmPath(in_src));",
      "  std::string dst_path = OR_RETURN_FATAL(BuildFinalProfilePath(in_dst->profilePath));",
      "  OR_RETURN_FATAL(ValidateDexPath(in_dexFile));",
      "ndk::ScopedAStatus Artd::CopyAndRewriteProfileImpl(File src,",
      "                                                   OutputProfile* dst_aidl,",
      "                                                   const std::string& dex_path,",
      "                                                   CopyAndRewriteProfileResult* aidl_return) {",
      "  std::string dst_path = OR_RETURN_FATAL(BuildFinalProfilePath(dst_aidl->profilePath));",
      "  OR_RETURN_FATAL(ValidateDexPath(dex_path));"
    ],
    "label": "",
    "index": 1,
    "confidence": 0.4,
    "desc": "List merge."
  }
]