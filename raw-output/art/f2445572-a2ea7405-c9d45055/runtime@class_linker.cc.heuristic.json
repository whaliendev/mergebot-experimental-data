[
  {
    "code": [
      "static void ThrowSignatureCheckResolveReturnTypeException(Handle<mirror::Class> klass,",
      "                                                          Handle<mirror::Class> super_klass,",
      "                                                          Handle<mirror::ArtMethod> method,",
      "                                                          mirror::ArtMethod* m)",
      "static void ThrowSignatureCheckResolveReturnTypeException(Handle<mirror::Class> klass,",
      "                                                          Handle<mirror::Class> super_klass,",
      "                                                          ArtMethod* method,",
      "                                                          ArtMethod* m)",
      "SHARED_LOCKS_REQUIRED(Locks::mutator_lock_) {",
      "  DCHECK(Thread::Current()->IsExceptionPending());",
      "  DCHECK(!m->IsProxyMethod());",
      "  const DexFile* dex_file = m->GetDexFile();",
      "  const DexFile::MethodId& method_id = dex_file->GetMethodId(m->GetDexMethodIndex());",
      "  const DexFile::ProtoId& proto_id = dex_file->GetMethodPrototype(method_id);",
      "  uint16_t return_type_idx = proto_id.return_type_idx_;",
      "  std::string return_type = PrettyType(return_type_idx, *dex_file);",
      "  std::string class_loader = PrettyTypeOf(m->GetDeclaringClass()->GetClassLoader());",
      "  ThrowWrappedLinkageError(klass.Get(),",
      "                           \"While checking class %s method %s signature against %s %s: \"",
      "                           \"Failed to resolve return type %s with %s\",",
      "                           PrettyDescriptor(klass.Get()).c_str(),",
      "                           PrettyMethod(method.Get()).c_str(),",
      "                           super_klass->IsInterface() ? \"interface\" : \"superclass\",",
      "                           PrettyDescriptor(super_klass.Get()).c_str(),",
      "                           return_type.c_str(), class_loader.c_str());",
      "}",
      "static void ThrowSignatureCheckResolveArgException(Handle<mirror::Class> klass,",
      "                                                   Handle<mirror::Class> super_klass,",
      "                                                   Handle<mirror::ArtMethod> method,",
      "                                                   mirror::ArtMethod* m,",
      "                                                   uint32_t index, uint32_t arg_type_idx)",
      "SHARED_LOCKS_REQUIRED(Locks::mutator_lock_) {",
      "  DCHECK(Thread::Current()->IsExceptionPending());",
      "  DCHECK(!m->IsProxyMethod());",
      "  const DexFile* dex_file = m->GetDexFile();",
      "  std::string arg_type = PrettyType(arg_type_idx, *dex_file);",
      "  std::string class_loader = PrettyTypeOf(m->GetDeclaringClass()->GetClassLoader());",
      "  ThrowWrappedLinkageError(klass.Get(),",
      "                           \"While checking class %s method %s signature against %s %s: \"",
      "                           \"Failed to resolve arg %u type %s with %s\",",
      "                           PrettyDescriptor(klass.Get()).c_str(),",
      "                           PrettyMethod(method.Get()).c_str(),",
      "                           super_klass->IsInterface() ? \"interface\" : \"superclass\",",
      "                           PrettyDescriptor(super_klass.Get()).c_str(),",
      "                           index, arg_type.c_str(), class_loader.c_str());",
      "}",
      "static void ThrowSignatureMismatch(Handle<mirror::Class> klass,",
      "                                   Handle<mirror::Class> super_klass,",
      "                                   Handle<mirror::ArtMethod> method,",
      "                                   const std::string& error_msg)",
      "SHARED_LOCKS_REQUIRED(Locks::mutator_lock_) {",
      "  ThrowLinkageError(klass.Get(),",
      "                    \"Class %s method %s resolves differently in %s %s: %s\",",
      "                    PrettyDescriptor(klass.Get()).c_str(),",
      "                    PrettyMethod(method.Get()).c_str(),",
      "                    super_klass->IsInterface() ? \"interface\" : \"superclass\",",
      "                    PrettyDescriptor(super_klass.Get()).c_str(),",
      "                    error_msg.c_str());",
      "}",
      "SHARED_LOCKS_REQUIRED(Locks::mutator_lock_) {",
      "  DCHECK(Thread::Current()->IsExceptionPending());",
      "  DCHECK(!m->IsProxyMethod());",
      "  const DexFile* dex_file = m->GetDexFile();",
      "  const DexFile::MethodId& method_id = dex_file->GetMethodId(m->GetDexMethodIndex());",
      "  const DexFile::ProtoId& proto_id = dex_file->GetMethodPrototype(method_id);",
      "  uint16_t return_type_idx = proto_id.return_type_idx_;",
      "  std::string return_type = PrettyType(return_type_idx, *dex_file);",
      "  std::string class_loader = PrettyTypeOf(m->GetDeclaringClass()->GetClassLoader());",
      "  ThrowWrappedLinkageError(klass.Get(),",
      "                           \"While checking class %s method %s signature against %s %s: \"",
      "                           \"Failed to resolve return type %s with %s\",",
      "                           PrettyDescriptor(klass.Get()).c_str(),",
      "                           PrettyMethod(method).c_str(),",
      "                           super_klass->IsInterface() ? \"interface\" : \"superclass\",",
      "                           PrettyDescriptor(super_klass.Get()).c_str(),",
      "                           return_type.c_str(), class_loader.c_str());",
      "}",
      "static void ThrowSignatureCheckResolveArgException(Handle<mirror::Class> klass,",
      "                                                   Handle<mirror::Class> super_klass,",
      "                                                   ArtMethod* method,",
      "                                                   ArtMethod* m,",
      "                                                   uint32_t index, uint32_t arg_type_idx)",
      "SHARED_LOCKS_REQUIRED(Locks::mutator_lock_) {",
      "  DCHECK(Thread::Current()->IsExceptionPending());",
      "  DCHECK(!m->IsProxyMethod());",
      "  const DexFile* dex_file = m->GetDexFile();",
      "  std::string arg_type = PrettyType(arg_type_idx, *dex_file);",
      "  std::string class_loader = PrettyTypeOf(m->GetDeclaringClass()->GetClassLoader());",
      "  ThrowWrappedLinkageError(klass.Get(),",
      "                           \"While checking class %s method %s signature against %s %s: \"",
      "                           \"Failed to resolve arg %u type %s with %s\",",
      "                           PrettyDescriptor(klass.Get()).c_str(),",
      "                           PrettyMethod(method).c_str(),",
      "                           super_klass->IsInterface() ? \"interface\" : \"superclass\",",
      "                           PrettyDescriptor(super_klass.Get()).c_str(),",
      "                           index, arg_type.c_str(), class_loader.c_str());",
      "}",
      "static void ThrowSignatureMismatch(Handle<mirror::Class> klass,",
      "                                   Handle<mirror::Class> super_klass,",
      "                                   ArtMethod* method,",
      "                                   const std::string& error_msg)",
      "SHARED_LOCKS_REQUIRED(Locks::mutator_lock_) {",
      "  ThrowLinkageError(klass.Get(),",
      "                    \"Class %s method %s resolves differently in %s %s: %s\",",
      "                    PrettyDescriptor(klass.Get()).c_str(),",
      "                    PrettyMethod(method).c_str(),",
      "                    super_klass->IsInterface() ? \"interface\" : \"superclass\",",
      "                    PrettyDescriptor(super_klass.Get()).c_str(),",
      "                    error_msg.c_str());",
      "}"
    ],
    "label": "",
    "index": 0,
    "confidence": 0.4,
    "desc": "List merge."
  }
]