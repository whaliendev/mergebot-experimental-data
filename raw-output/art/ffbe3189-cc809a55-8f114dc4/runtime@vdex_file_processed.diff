--- a/output/art/ffbe3189-cc809a55-8f114dc4/runtime@vdex_file.no_comments_mergebot.cc
+++ b/output/art/ffbe3189-cc809a55-8f114dc4/runtime@vdex_file.no_comments_truth.cc
@@ -28,0 +29,2 @@ using android::base::StringPrintf;
+constexpr uint8_t VdexFile::VdexFileHeader::kVdexInvalidMagic[4];
+constexpr uint8_t VdexFile::VdexFileHeader::kVdexMagic[4];
@@ -30,772 +32,2 @@ constexpr uint8_t VdexFile::VdexFileHeader::kVdexVersion[4];
-constexpr uint8_t VdexFile::VdexFileHeader::kVdexVersion[4];
-constexpr uint8_t VdexFile::VdexFileHeader::kVdexVersion[4];
-bool VdexFile::VdexFileHeader::IsMagicValid() const {
-  return (memcmp(magic_, kVdexMagic, sizeof(kVdexMagic)) == 0);
-}
-bool VdexFile::VdexFileHeader::IsVdexVersionValid() const {
-  return (memcmp(vdex_version_, kVdexVersion, sizeof(kVdexVersion)) == 0);
-}
-VdexFile::VdexFileHeader::VdexFileHeader(bool has_dex_section ATTRIBUTE_UNUSED)
-    : number_of_sections_(static_cast<uint32_t>(VdexSection::kNumberOfSections)) {
-  memcpy(magic_, kVdexMagic, sizeof(kVdexMagic));
-  memcpy(vdex_version_, kVdexVersion, sizeof(kVdexVersion));
-  DCHECK(IsMagicValid());
-  DCHECK(IsVdexVersionValid());
-}
-std::unique_ptr<VdexFile> VdexFile::OpenAtAddress(uint8_t* mmap_addr,
-                                                  size_t mmap_size,
-                                                  bool mmap_reuse,
-                                                  const std::string& vdex_filename,
-                                                  bool writable,
-                                                  bool low_4gb,
-                                                  bool unquicken,
-                                                  std::string* error_msg) {
-  ScopedTrace trace(("VdexFile::OpenAtAddress " + vdex_filename).c_str());
-  if (!OS::FileExists(vdex_filename.c_str())) {
-    *error_msg = "File " + vdex_filename + " does not exist.";
-    return nullptr;
-  }
-  std::unique_ptr<File> vdex_file;
-  if (writable) {
-    vdex_file.reset(OS::OpenFileReadWrite(vdex_filename.c_str()));
-  } else {
-    vdex_file.reset(OS::OpenFileForReading(vdex_filename.c_str()));
-  }
-  if (vdex_file == nullptr) {
-    *error_msg = "Could not open file " + vdex_filename +
-                 (writable ? " for read/write" : "for reading");
-    return nullptr;
-  }
-  int64_t vdex_length = vdex_file->GetLength();
-  if (vdex_length == -1) {
-    *error_msg = "Could not read the length of file " + vdex_filename;
-    return nullptr;
-  }
-  return OpenAtAddress(mmap_addr,
-                       mmap_size,
-                       mmap_reuse,
-                       vdex_file->Fd(),
-                       vdex_length,
-                       vdex_filename,
-                       writable,
-                       low_4gb,
-                       unquicken,
-                       error_msg);
-}
-ClassStatus VdexFile::ComputeClassStatus(Thread* self, Handle<mirror::Class> cls) const {
-  const DexFile& dex_file = cls->GetDexFile();
-  uint16_t class_def_index = cls->GetDexClassDefIndex();
-  uint32_t index = 0;
-  for (; index < GetNumberOfDexFiles(); ++index) {
-    if (dex_file.GetLocationChecksum() == GetLocationChecksum(index)) {
-      break;
-    }
-  }
-  DCHECK_NE(index, GetNumberOfDexFiles());
-  const uint8_t* verifier_deps = GetVerifierDepsData().data();
-  const uint32_t* dex_file_class_defs = GetDexFileClassDefs(verifier_deps, index);
-  uint32_t class_def_offset = dex_file_class_defs[class_def_index];
-  if (class_def_offset == verifier::VerifierDeps::kNotVerifiedMarker) {
-    return ClassStatus::kResolved;
-  }
-  uint32_t end_offset = verifier::VerifierDeps::kNotVerifiedMarker;
-  for (uint32_t i = class_def_index + 1; i < dex_file.NumClassDefs() + 1; ++i) {
-    end_offset = dex_file_class_defs[i];
-    if (end_offset != verifier::VerifierDeps::kNotVerifiedMarker) {
-      break;
-    }
-  }
-  DCHECK_NE(end_offset, verifier::VerifierDeps::kNotVerifiedMarker);
-  uint32_t number_of_extra_strings = 0;
-  const uint32_t* extra_strings_offsets = GetExtraStringsOffsets(dex_file,
-                                                                 verifier_deps,
-                                                                 dex_file_class_defs,
-                                                                 &number_of_extra_strings);
-  StackHandleScope<3> hs(self);
-  ClassLinker* class_linker = Runtime::Current()->GetClassLinker();
-  Handle<mirror::ClassLoader> class_loader(hs.NewHandle(cls->GetClassLoader()));
-  MutableHandle<mirror::Class> source(hs.NewHandle<mirror::Class>(nullptr));
-  MutableHandle<mirror::Class> destination(hs.NewHandle<mirror::Class>(nullptr));
-  const uint8_t* cursor = verifier_deps + class_def_offset;
-  const uint8_t* end = verifier_deps + end_offset;
-  while (cursor < end) {
-    uint32_t destination_index;
-    uint32_t source_index;
-    if (UNLIKELY(!DecodeUnsignedLeb128Checked(&cursor, end, &destination_index) ||
-                 !DecodeUnsignedLeb128Checked(&cursor, end, &source_index))) {
-      return ClassStatus::kResolved;
-    }
-    const char* destination_desc = GetStringFromId(dex_file,
-                                                   dex::StringIndex(destination_index),
-                                                   number_of_extra_strings,
-                                                   extra_strings_offsets,
-                                                   verifier_deps);
-    destination.Assign(
-        FindClassAndClearException(class_linker, self, destination_desc, class_loader));
-    const char* source_desc = GetStringFromId(dex_file,
-                                              dex::StringIndex(source_index),
-                                              number_of_extra_strings,
-                                              extra_strings_offsets,
-                                              verifier_deps);
-    source.Assign(FindClassAndClearException(class_linker, self, source_desc, class_loader));
-    if (destination == nullptr || source == nullptr) {
-      continue;
-    }
-    DCHECK(destination->IsResolved() && source->IsResolved());
-    if (!destination->IsAssignableFrom(source.Get())) {
-      VLOG(verifier) << "Vdex checking failed for " << cls->PrettyClass()
-                     << ": expected " << destination->PrettyClass()
-                     << " to be assignable from " << source->PrettyClass();
-      return ClassStatus::kResolved;
-    }
-  }
-  return ClassStatus::kVerifiedNeedsAccessChecks;
-}
-ClassStatus VdexFile::ComputeClassStatus(Thread* self, Handle<mirror::Class> cls) const {
-  const DexFile& dex_file = cls->GetDexFile();
-  uint16_t class_def_index = cls->GetDexClassDefIndex();
-  uint32_t index = 0;
-  for (; index < GetNumberOfDexFiles(); ++index) {
-    if (dex_file.GetLocationChecksum() == GetLocationChecksum(index)) {
-      break;
-    }
-  }
-  DCHECK_NE(index, GetNumberOfDexFiles());
-  const uint8_t* verifier_deps = GetVerifierDepsData().data();
-  const uint32_t* dex_file_class_defs = GetDexFileClassDefs(verifier_deps, index);
-  uint32_t class_def_offset = dex_file_class_defs[class_def_index];
-  if (class_def_offset == verifier::VerifierDeps::kNotVerifiedMarker) {
-    return ClassStatus::kResolved;
-  }
-  uint32_t end_offset = verifier::VerifierDeps::kNotVerifiedMarker;
-  for (uint32_t i = class_def_index + 1; i < dex_file.NumClassDefs() + 1; ++i) {
-    end_offset = dex_file_class_defs[i];
-    if (end_offset != verifier::VerifierDeps::kNotVerifiedMarker) {
-      break;
-    }
-  }
-  DCHECK_NE(end_offset, verifier::VerifierDeps::kNotVerifiedMarker);
-  uint32_t number_of_extra_strings = 0;
-  const uint32_t* extra_strings_offsets = GetExtraStringsOffsets(dex_file,
-                                                                 verifier_deps,
-                                                                 dex_file_class_defs,
-                                                                 &number_of_extra_strings);
-  StackHandleScope<3> hs(self);
-  ClassLinker* class_linker = Runtime::Current()->GetClassLinker();
-  Handle<mirror::ClassLoader> class_loader(hs.NewHandle(cls->GetClassLoader()));
-  MutableHandle<mirror::Class> source(hs.NewHandle<mirror::Class>(nullptr));
-  MutableHandle<mirror::Class> destination(hs.NewHandle<mirror::Class>(nullptr));
-  const uint8_t* cursor = verifier_deps + class_def_offset;
-  const uint8_t* end = verifier_deps + end_offset;
-  while (cursor < end) {
-    uint32_t destination_index;
-    uint32_t source_index;
-    if (UNLIKELY(!DecodeUnsignedLeb128Checked(&cursor, end, &destination_index) ||
-                 !DecodeUnsignedLeb128Checked(&cursor, end, &source_index))) {
-      return ClassStatus::kResolved;
-    }
-    const char* destination_desc = GetStringFromId(dex_file,
-                                                   dex::StringIndex(destination_index),
-                                                   number_of_extra_strings,
-                                                   extra_strings_offsets,
-                                                   verifier_deps);
-    destination.Assign(
-        FindClassAndClearException(class_linker, self, destination_desc, class_loader));
-    const char* source_desc = GetStringFromId(dex_file,
-                                              dex::StringIndex(source_index),
-                                              number_of_extra_strings,
-                                              extra_strings_offsets,
-                                              verifier_deps);
-    source.Assign(FindClassAndClearException(class_linker, self, source_desc, class_loader));
-    if (destination == nullptr || source == nullptr) {
-      continue;
-    }
-    DCHECK(destination->IsResolved() && source->IsResolved());
-    if (!destination->IsAssignableFrom(source.Get())) {
-      VLOG(verifier) << "Vdex checking failed for " << cls->PrettyClass()
-                     << ": expected " << destination->PrettyClass()
-                     << " to be assignable from " << source->PrettyClass();
-      return ClassStatus::kResolved;
-    }
-  }
-  return ClassStatus::kVerifiedNeedsAccessChecks;
-}
-ClassStatus VdexFile::ComputeClassStatus(Thread* self, Handle<mirror::Class> cls) const {
-  const DexFile& dex_file = cls->GetDexFile();
-  uint16_t class_def_index = cls->GetDexClassDefIndex();
-  uint32_t index = 0;
-  for (; index < GetNumberOfDexFiles(); ++index) {
-    if (dex_file.GetLocationChecksum() == GetLocationChecksum(index)) {
-      break;
-    }
-  }
-  DCHECK_NE(index, GetNumberOfDexFiles());
-  const uint8_t* verifier_deps = GetVerifierDepsData().data();
-  const uint32_t* dex_file_class_defs = GetDexFileClassDefs(verifier_deps, index);
-  uint32_t class_def_offset = dex_file_class_defs[class_def_index];
-  if (class_def_offset == verifier::VerifierDeps::kNotVerifiedMarker) {
-    return ClassStatus::kResolved;
-  }
-  uint32_t end_offset = verifier::VerifierDeps::kNotVerifiedMarker;
-  for (uint32_t i = class_def_index + 1; i < dex_file.NumClassDefs() + 1; ++i) {
-    end_offset = dex_file_class_defs[i];
-    if (end_offset != verifier::VerifierDeps::kNotVerifiedMarker) {
-      break;
-    }
-  }
-  DCHECK_NE(end_offset, verifier::VerifierDeps::kNotVerifiedMarker);
-  uint32_t number_of_extra_strings = 0;
-  const uint32_t* extra_strings_offsets = GetExtraStringsOffsets(dex_file,
-                                                                 verifier_deps,
-                                                                 dex_file_class_defs,
-                                                                 &number_of_extra_strings);
-  StackHandleScope<3> hs(self);
-  ClassLinker* class_linker = Runtime::Current()->GetClassLinker();
-  Handle<mirror::ClassLoader> class_loader(hs.NewHandle(cls->GetClassLoader()));
-  MutableHandle<mirror::Class> source(hs.NewHandle<mirror::Class>(nullptr));
-  MutableHandle<mirror::Class> destination(hs.NewHandle<mirror::Class>(nullptr));
-  const uint8_t* cursor = verifier_deps + class_def_offset;
-  const uint8_t* end = verifier_deps + end_offset;
-  while (cursor < end) {
-    uint32_t destination_index;
-    uint32_t source_index;
-    if (UNLIKELY(!DecodeUnsignedLeb128Checked(&cursor, end, &destination_index) ||
-                 !DecodeUnsignedLeb128Checked(&cursor, end, &source_index))) {
-      return ClassStatus::kResolved;
-    }
-    const char* destination_desc = GetStringFromId(dex_file,
-                                                   dex::StringIndex(destination_index),
-                                                   number_of_extra_strings,
-                                                   extra_strings_offsets,
-                                                   verifier_deps);
-    destination.Assign(
-        FindClassAndClearException(class_linker, self, destination_desc, class_loader));
-    const char* source_desc = GetStringFromId(dex_file,
-                                              dex::StringIndex(source_index),
-                                              number_of_extra_strings,
-                                              extra_strings_offsets,
-                                              verifier_deps);
-    source.Assign(FindClassAndClearException(class_linker, self, source_desc, class_loader));
-    if (destination == nullptr || source == nullptr) {
-      continue;
-    }
-    DCHECK(destination->IsResolved() && source->IsResolved());
-    if (!destination->IsAssignableFrom(source.Get())) {
-      VLOG(verifier) << "Vdex checking failed for " << cls->PrettyClass()
-                     << ": expected " << destination->PrettyClass()
-                     << " to be assignable from " << source->PrettyClass();
-      return ClassStatus::kResolved;
-    }
-  }
-  return ClassStatus::kVerifiedNeedsAccessChecks;
-}
-ClassStatus VdexFile::ComputeClassStatus(Thread* self, Handle<mirror::Class> cls) const {
-  const DexFile& dex_file = cls->GetDexFile();
-  uint16_t class_def_index = cls->GetDexClassDefIndex();
-  uint32_t index = 0;
-  for (; index < GetNumberOfDexFiles(); ++index) {
-    if (dex_file.GetLocationChecksum() == GetLocationChecksum(index)) {
-      break;
-    }
-  }
-  DCHECK_NE(index, GetNumberOfDexFiles());
-  const uint8_t* verifier_deps = GetVerifierDepsData().data();
-  const uint32_t* dex_file_class_defs = GetDexFileClassDefs(verifier_deps, index);
-  uint32_t class_def_offset = dex_file_class_defs[class_def_index];
-  if (class_def_offset == verifier::VerifierDeps::kNotVerifiedMarker) {
-    return ClassStatus::kResolved;
-  }
-  uint32_t end_offset = verifier::VerifierDeps::kNotVerifiedMarker;
-  for (uint32_t i = class_def_index + 1; i < dex_file.NumClassDefs() + 1; ++i) {
-    end_offset = dex_file_class_defs[i];
-    if (end_offset != verifier::VerifierDeps::kNotVerifiedMarker) {
-      break;
-    }
-  }
-  DCHECK_NE(end_offset, verifier::VerifierDeps::kNotVerifiedMarker);
-  uint32_t number_of_extra_strings = 0;
-  const uint32_t* extra_strings_offsets = GetExtraStringsOffsets(dex_file,
-                                                                 verifier_deps,
-                                                                 dex_file_class_defs,
-                                                                 &number_of_extra_strings);
-  StackHandleScope<3> hs(self);
-  ClassLinker* class_linker = Runtime::Current()->GetClassLinker();
-  Handle<mirror::ClassLoader> class_loader(hs.NewHandle(cls->GetClassLoader()));
-  MutableHandle<mirror::Class> source(hs.NewHandle<mirror::Class>(nullptr));
-  MutableHandle<mirror::Class> destination(hs.NewHandle<mirror::Class>(nullptr));
-  const uint8_t* cursor = verifier_deps + class_def_offset;
-  const uint8_t* end = verifier_deps + end_offset;
-  while (cursor < end) {
-    uint32_t destination_index;
-    uint32_t source_index;
-    if (UNLIKELY(!DecodeUnsignedLeb128Checked(&cursor, end, &destination_index) ||
-                 !DecodeUnsignedLeb128Checked(&cursor, end, &source_index))) {
-      return ClassStatus::kResolved;
-    }
-    const char* destination_desc = GetStringFromId(dex_file,
-                                                   dex::StringIndex(destination_index),
-                                                   number_of_extra_strings,
-                                                   extra_strings_offsets,
-                                                   verifier_deps);
-    destination.Assign(
-        FindClassAndClearException(class_linker, self, destination_desc, class_loader));
-    const char* source_desc = GetStringFromId(dex_file,
-                                              dex::StringIndex(source_index),
-                                              number_of_extra_strings,
-                                              extra_strings_offsets,
-                                              verifier_deps);
-    source.Assign(FindClassAndClearException(class_linker, self, source_desc, class_loader));
-    if (destination == nullptr || source == nullptr) {
-      continue;
-    }
-    DCHECK(destination->IsResolved() && source->IsResolved());
-    if (!destination->IsAssignableFrom(source.Get())) {
-      VLOG(verifier) << "Vdex checking failed for " << cls->PrettyClass()
-                     << ": expected " << destination->PrettyClass()
-                     << " to be assignable from " << source->PrettyClass();
-      return ClassStatus::kResolved;
-    }
-  }
-  return ClassStatus::kVerifiedNeedsAccessChecks;
-}
-ClassStatus VdexFile::ComputeClassStatus(Thread* self, Handle<mirror::Class> cls) const {
-  const DexFile& dex_file = cls->GetDexFile();
-  uint16_t class_def_index = cls->GetDexClassDefIndex();
-  uint32_t index = 0;
-  for (; index < GetNumberOfDexFiles(); ++index) {
-    if (dex_file.GetLocationChecksum() == GetLocationChecksum(index)) {
-      break;
-    }
-  }
-  DCHECK_NE(index, GetNumberOfDexFiles());
-  const uint8_t* verifier_deps = GetVerifierDepsData().data();
-  const uint32_t* dex_file_class_defs = GetDexFileClassDefs(verifier_deps, index);
-  uint32_t class_def_offset = dex_file_class_defs[class_def_index];
-  if (class_def_offset == verifier::VerifierDeps::kNotVerifiedMarker) {
-    return ClassStatus::kResolved;
-  }
-  uint32_t end_offset = verifier::VerifierDeps::kNotVerifiedMarker;
-  for (uint32_t i = class_def_index + 1; i < dex_file.NumClassDefs() + 1; ++i) {
-    end_offset = dex_file_class_defs[i];
-    if (end_offset != verifier::VerifierDeps::kNotVerifiedMarker) {
-      break;
-    }
-  }
-  DCHECK_NE(end_offset, verifier::VerifierDeps::kNotVerifiedMarker);
-  uint32_t number_of_extra_strings = 0;
-  const uint32_t* extra_strings_offsets = GetExtraStringsOffsets(dex_file,
-                                                                 verifier_deps,
-                                                                 dex_file_class_defs,
-                                                                 &number_of_extra_strings);
-  StackHandleScope<3> hs(self);
-  ClassLinker* class_linker = Runtime::Current()->GetClassLinker();
-  Handle<mirror::ClassLoader> class_loader(hs.NewHandle(cls->GetClassLoader()));
-  MutableHandle<mirror::Class> source(hs.NewHandle<mirror::Class>(nullptr));
-  MutableHandle<mirror::Class> destination(hs.NewHandle<mirror::Class>(nullptr));
-  const uint8_t* cursor = verifier_deps + class_def_offset;
-  const uint8_t* end = verifier_deps + end_offset;
-  while (cursor < end) {
-    uint32_t destination_index;
-    uint32_t source_index;
-    if (UNLIKELY(!DecodeUnsignedLeb128Checked(&cursor, end, &destination_index) ||
-                 !DecodeUnsignedLeb128Checked(&cursor, end, &source_index))) {
-      return ClassStatus::kResolved;
-    }
-    const char* destination_desc = GetStringFromId(dex_file,
-                                                   dex::StringIndex(destination_index),
-                                                   number_of_extra_strings,
-                                                   extra_strings_offsets,
-                                                   verifier_deps);
-    destination.Assign(
-        FindClassAndClearException(class_linker, self, destination_desc, class_loader));
-    const char* source_desc = GetStringFromId(dex_file,
-                                              dex::StringIndex(source_index),
-                                              number_of_extra_strings,
-                                              extra_strings_offsets,
-                                              verifier_deps);
-    source.Assign(FindClassAndClearException(class_linker, self, source_desc, class_loader));
-    if (destination == nullptr || source == nullptr) {
-      continue;
-    }
-    DCHECK(destination->IsResolved() && source->IsResolved());
-    if (!destination->IsAssignableFrom(source.Get())) {
-      VLOG(verifier) << "Vdex checking failed for " << cls->PrettyClass()
-                     << ": expected " << destination->PrettyClass()
-                     << " to be assignable from " << source->PrettyClass();
-      return ClassStatus::kResolved;
-    }
-  }
-  return ClassStatus::kVerifiedNeedsAccessChecks;
-}
-ClassStatus VdexFile::ComputeClassStatus(Thread* self, Handle<mirror::Class> cls) const {
-  const DexFile& dex_file = cls->GetDexFile();
-  uint16_t class_def_index = cls->GetDexClassDefIndex();
-  uint32_t index = 0;
-  for (; index < GetNumberOfDexFiles(); ++index) {
-    if (dex_file.GetLocationChecksum() == GetLocationChecksum(index)) {
-      break;
-    }
-  }
-  DCHECK_NE(index, GetNumberOfDexFiles());
-  const uint8_t* verifier_deps = GetVerifierDepsData().data();
-  const uint32_t* dex_file_class_defs = GetDexFileClassDefs(verifier_deps, index);
-  uint32_t class_def_offset = dex_file_class_defs[class_def_index];
-  if (class_def_offset == verifier::VerifierDeps::kNotVerifiedMarker) {
-    return ClassStatus::kResolved;
-  }
-  uint32_t end_offset = verifier::VerifierDeps::kNotVerifiedMarker;
-  for (uint32_t i = class_def_index + 1; i < dex_file.NumClassDefs() + 1; ++i) {
-    end_offset = dex_file_class_defs[i];
-    if (end_offset != verifier::VerifierDeps::kNotVerifiedMarker) {
-      break;
-    }
-  }
-  DCHECK_NE(end_offset, verifier::VerifierDeps::kNotVerifiedMarker);
-  uint32_t number_of_extra_strings = 0;
-  const uint32_t* extra_strings_offsets = GetExtraStringsOffsets(dex_file,
-                                                                 verifier_deps,
-                                                                 dex_file_class_defs,
-                                                                 &number_of_extra_strings);
-  StackHandleScope<3> hs(self);
-  ClassLinker* class_linker = Runtime::Current()->GetClassLinker();
-  Handle<mirror::ClassLoader> class_loader(hs.NewHandle(cls->GetClassLoader()));
-  MutableHandle<mirror::Class> source(hs.NewHandle<mirror::Class>(nullptr));
-  MutableHandle<mirror::Class> destination(hs.NewHandle<mirror::Class>(nullptr));
-  const uint8_t* cursor = verifier_deps + class_def_offset;
-  const uint8_t* end = verifier_deps + end_offset;
-  while (cursor < end) {
-    uint32_t destination_index;
-    uint32_t source_index;
-    if (UNLIKELY(!DecodeUnsignedLeb128Checked(&cursor, end, &destination_index) ||
-                 !DecodeUnsignedLeb128Checked(&cursor, end, &source_index))) {
-      return ClassStatus::kResolved;
-    }
-    const char* destination_desc = GetStringFromId(dex_file,
-                                                   dex::StringIndex(destination_index),
-                                                   number_of_extra_strings,
-                                                   extra_strings_offsets,
-                                                   verifier_deps);
-    destination.Assign(
-        FindClassAndClearException(class_linker, self, destination_desc, class_loader));
-    const char* source_desc = GetStringFromId(dex_file,
-                                              dex::StringIndex(source_index),
-                                              number_of_extra_strings,
-                                              extra_strings_offsets,
-                                              verifier_deps);
-    source.Assign(FindClassAndClearException(class_linker, self, source_desc, class_loader));
-    if (destination == nullptr || source == nullptr) {
-      continue;
-    }
-    DCHECK(destination->IsResolved() && source->IsResolved());
-    if (!destination->IsAssignableFrom(source.Get())) {
-      VLOG(verifier) << "Vdex checking failed for " << cls->PrettyClass()
-                     << ": expected " << destination->PrettyClass()
-                     << " to be assignable from " << source->PrettyClass();
-      return ClassStatus::kResolved;
-    }
-  }
-  return ClassStatus::kVerifiedNeedsAccessChecks;
-}
-ClassStatus VdexFile::ComputeClassStatus(Thread* self, Handle<mirror::Class> cls) const {
-  const DexFile& dex_file = cls->GetDexFile();
-  uint16_t class_def_index = cls->GetDexClassDefIndex();
-  uint32_t index = 0;
-  for (; index < GetNumberOfDexFiles(); ++index) {
-    if (dex_file.GetLocationChecksum() == GetLocationChecksum(index)) {
-      break;
-    }
-  }
-  DCHECK_NE(index, GetNumberOfDexFiles());
-  const uint8_t* verifier_deps = GetVerifierDepsData().data();
-  const uint32_t* dex_file_class_defs = GetDexFileClassDefs(verifier_deps, index);
-  uint32_t class_def_offset = dex_file_class_defs[class_def_index];
-  if (class_def_offset == verifier::VerifierDeps::kNotVerifiedMarker) {
-    return ClassStatus::kResolved;
-  }
-  uint32_t end_offset = verifier::VerifierDeps::kNotVerifiedMarker;
-  for (uint32_t i = class_def_index + 1; i < dex_file.NumClassDefs() + 1; ++i) {
-    end_offset = dex_file_class_defs[i];
-    if (end_offset != verifier::VerifierDeps::kNotVerifiedMarker) {
-      break;
-    }
-  }
-  DCHECK_NE(end_offset, verifier::VerifierDeps::kNotVerifiedMarker);
-  uint32_t number_of_extra_strings = 0;
-  const uint32_t* extra_strings_offsets = GetExtraStringsOffsets(dex_file,
-                                                                 verifier_deps,
-                                                                 dex_file_class_defs,
-                                                                 &number_of_extra_strings);
-  StackHandleScope<3> hs(self);
-  ClassLinker* class_linker = Runtime::Current()->GetClassLinker();
-  Handle<mirror::ClassLoader> class_loader(hs.NewHandle(cls->GetClassLoader()));
-  MutableHandle<mirror::Class> source(hs.NewHandle<mirror::Class>(nullptr));
-  MutableHandle<mirror::Class> destination(hs.NewHandle<mirror::Class>(nullptr));
-  const uint8_t* cursor = verifier_deps + class_def_offset;
-  const uint8_t* end = verifier_deps + end_offset;
-  while (cursor < end) {
-    uint32_t destination_index;
-    uint32_t source_index;
-    if (UNLIKELY(!DecodeUnsignedLeb128Checked(&cursor, end, &destination_index) ||
-                 !DecodeUnsignedLeb128Checked(&cursor, end, &source_index))) {
-      return ClassStatus::kResolved;
-    }
-    const char* destination_desc = GetStringFromId(dex_file,
-                                                   dex::StringIndex(destination_index),
-                                                   number_of_extra_strings,
-                                                   extra_strings_offsets,
-                                                   verifier_deps);
-    destination.Assign(
-        FindClassAndClearException(class_linker, self, destination_desc, class_loader));
-    const char* source_desc = GetStringFromId(dex_file,
-                                              dex::StringIndex(source_index),
-                                              number_of_extra_strings,
-                                              extra_strings_offsets,
-                                              verifier_deps);
-    source.Assign(FindClassAndClearException(class_linker, self, source_desc, class_loader));
-    if (destination == nullptr || source == nullptr) {
-      continue;
-    }
-    DCHECK(destination->IsResolved() && source->IsResolved());
-    if (!destination->IsAssignableFrom(source.Get())) {
-      VLOG(verifier) << "Vdex checking failed for " << cls->PrettyClass()
-                     << ": expected " << destination->PrettyClass()
-                     << " to be assignable from " << source->PrettyClass();
-      return ClassStatus::kResolved;
-    }
-  }
-  return ClassStatus::kVerifiedNeedsAccessChecks;
-}
-static ObjPtr<mirror::Class> FindClassAndClearException(ClassLinker* class_linker,
-                                                        Thread* self,
-                                                        const char* name,
-                                                        Handle<mirror::ClassLoader> class_loader)
-    REQUIRES_SHARED(Locks::mutator_lock_) {
-    ObjPtr<mirror::Class> result = class_linker->FindClass(self, name, class_loader);
-    if (result == nullptr) {
-    DCHECK(self->IsExceptionPending());
-    self->ClearException();
-    }
-    return result;
-    }
-ClassStatus VdexFile::ComputeClassStatus(Thread* self, Handle<mirror::Class> cls) const {
-  const DexFile& dex_file = cls->GetDexFile();
-  uint16_t class_def_index = cls->GetDexClassDefIndex();
-  uint32_t index = 0;
-  for (; index < GetNumberOfDexFiles(); ++index) {
-    if (dex_file.GetLocationChecksum() == GetLocationChecksum(index)) {
-      break;
-    }
-  }
-  DCHECK_NE(index, GetNumberOfDexFiles());
-  const uint8_t* verifier_deps = GetVerifierDepsData().data();
-  const uint32_t* dex_file_class_defs = GetDexFileClassDefs(verifier_deps, index);
-  uint32_t class_def_offset = dex_file_class_defs[class_def_index];
-  if (class_def_offset == verifier::VerifierDeps::kNotVerifiedMarker) {
-    return ClassStatus::kResolved;
-  }
-  uint32_t end_offset = verifier::VerifierDeps::kNotVerifiedMarker;
-  for (uint32_t i = class_def_index + 1; i < dex_file.NumClassDefs() + 1; ++i) {
-    end_offset = dex_file_class_defs[i];
-    if (end_offset != verifier::VerifierDeps::kNotVerifiedMarker) {
-      break;
-    }
-  }
-  DCHECK_NE(end_offset, verifier::VerifierDeps::kNotVerifiedMarker);
-  uint32_t number_of_extra_strings = 0;
-  const uint32_t* extra_strings_offsets = GetExtraStringsOffsets(dex_file,
-                                                                 verifier_deps,
-                                                                 dex_file_class_defs,
-                                                                 &number_of_extra_strings);
-  StackHandleScope<3> hs(self);
-  ClassLinker* class_linker = Runtime::Current()->GetClassLinker();
-  Handle<mirror::ClassLoader> class_loader(hs.NewHandle(cls->GetClassLoader()));
-  MutableHandle<mirror::Class> source(hs.NewHandle<mirror::Class>(nullptr));
-  MutableHandle<mirror::Class> destination(hs.NewHandle<mirror::Class>(nullptr));
-  const uint8_t* cursor = verifier_deps + class_def_offset;
-  const uint8_t* end = verifier_deps + end_offset;
-  while (cursor < end) {
-    uint32_t destination_index;
-    uint32_t source_index;
-    if (UNLIKELY(!DecodeUnsignedLeb128Checked(&cursor, end, &destination_index) ||
-                 !DecodeUnsignedLeb128Checked(&cursor, end, &source_index))) {
-      return ClassStatus::kResolved;
-    }
-    const char* destination_desc = GetStringFromId(dex_file,
-                                                   dex::StringIndex(destination_index),
-                                                   number_of_extra_strings,
-                                                   extra_strings_offsets,
-                                                   verifier_deps);
-    destination.Assign(
-        FindClassAndClearException(class_linker, self, destination_desc, class_loader));
-    const char* source_desc = GetStringFromId(dex_file,
-                                              dex::StringIndex(source_index),
-                                              number_of_extra_strings,
-                                              extra_strings_offsets,
-                                              verifier_deps);
-    source.Assign(FindClassAndClearException(class_linker, self, source_desc, class_loader));
-    if (destination == nullptr || source == nullptr) {
-      continue;
-    }
-    DCHECK(destination->IsResolved() && source->IsResolved());
-    if (!destination->IsAssignableFrom(source.Get())) {
-      VLOG(verifier) << "Vdex checking failed for " << cls->PrettyClass()
-                     << ": expected " << destination->PrettyClass()
-                     << " to be assignable from " << source->PrettyClass();
-      return ClassStatus::kResolved;
-    }
-  }
-  return ClassStatus::kVerifiedNeedsAccessChecks;
-}
-ClassStatus VdexFile::ComputeClassStatus(Thread* self, Handle<mirror::Class> cls) const {
-  const DexFile& dex_file = cls->GetDexFile();
-  uint16_t class_def_index = cls->GetDexClassDefIndex();
-  uint32_t index = 0;
-  for (; index < GetNumberOfDexFiles(); ++index) {
-    if (dex_file.GetLocationChecksum() == GetLocationChecksum(index)) {
-      break;
-    }
-  }
-  DCHECK_NE(index, GetNumberOfDexFiles());
-  const uint8_t* verifier_deps = GetVerifierDepsData().data();
-  const uint32_t* dex_file_class_defs = GetDexFileClassDefs(verifier_deps, index);
-  uint32_t class_def_offset = dex_file_class_defs[class_def_index];
-  if (class_def_offset == verifier::VerifierDeps::kNotVerifiedMarker) {
-    return ClassStatus::kResolved;
-  }
-  uint32_t end_offset = verifier::VerifierDeps::kNotVerifiedMarker;
-  for (uint32_t i = class_def_index + 1; i < dex_file.NumClassDefs() + 1; ++i) {
-    end_offset = dex_file_class_defs[i];
-    if (end_offset != verifier::VerifierDeps::kNotVerifiedMarker) {
-      break;
-    }
-  }
-  DCHECK_NE(end_offset, verifier::VerifierDeps::kNotVerifiedMarker);
-  uint32_t number_of_extra_strings = 0;
-  const uint32_t* extra_strings_offsets = GetExtraStringsOffsets(dex_file,
-                                                                 verifier_deps,
-                                                                 dex_file_class_defs,
-                                                                 &number_of_extra_strings);
-  StackHandleScope<3> hs(self);
-  ClassLinker* class_linker = Runtime::Current()->GetClassLinker();
-  Handle<mirror::ClassLoader> class_loader(hs.NewHandle(cls->GetClassLoader()));
-  MutableHandle<mirror::Class> source(hs.NewHandle<mirror::Class>(nullptr));
-  MutableHandle<mirror::Class> destination(hs.NewHandle<mirror::Class>(nullptr));
-  const uint8_t* cursor = verifier_deps + class_def_offset;
-  const uint8_t* end = verifier_deps + end_offset;
-  while (cursor < end) {
-    uint32_t destination_index;
-    uint32_t source_index;
-    if (UNLIKELY(!DecodeUnsignedLeb128Checked(&cursor, end, &destination_index) ||
-                 !DecodeUnsignedLeb128Checked(&cursor, end, &source_index))) {
-      return ClassStatus::kResolved;
-    }
-    const char* destination_desc = GetStringFromId(dex_file,
-                                                   dex::StringIndex(destination_index),
-                                                   number_of_extra_strings,
-                                                   extra_strings_offsets,
-                                                   verifier_deps);
-    destination.Assign(
-        FindClassAndClearException(class_linker, self, destination_desc, class_loader));
-    const char* source_desc = GetStringFromId(dex_file,
-                                              dex::StringIndex(source_index),
-                                              number_of_extra_strings,
-                                              extra_strings_offsets,
-                                              verifier_deps);
-    source.Assign(FindClassAndClearException(class_linker, self, source_desc, class_loader));
-    if (destination == nullptr || source == nullptr) {
-      continue;
-    }
-    DCHECK(destination->IsResolved() && source->IsResolved());
-    if (!destination->IsAssignableFrom(source.Get())) {
-      VLOG(verifier) << "Vdex checking failed for " << cls->PrettyClass()
-                     << ": expected " << destination->PrettyClass()
-                     << " to be assignable from " << source->PrettyClass();
-      return ClassStatus::kResolved;
-    }
-  }
-  return ClassStatus::kVerifiedNeedsAccessChecks;
-}
-ClassStatus VdexFile::ComputeClassStatus(Thread* self, Handle<mirror::Class> cls) const {
-  const DexFile& dex_file = cls->GetDexFile();
-  uint16_t class_def_index = cls->GetDexClassDefIndex();
-  uint32_t index = 0;
-  for (; index < GetNumberOfDexFiles(); ++index) {
-    if (dex_file.GetLocationChecksum() == GetLocationChecksum(index)) {
-      break;
-    }
-  }
-  DCHECK_NE(index, GetNumberOfDexFiles());
-  const uint8_t* verifier_deps = GetVerifierDepsData().data();
-  const uint32_t* dex_file_class_defs = GetDexFileClassDefs(verifier_deps, index);
-  uint32_t class_def_offset = dex_file_class_defs[class_def_index];
-  if (class_def_offset == verifier::VerifierDeps::kNotVerifiedMarker) {
-    return ClassStatus::kResolved;
-  }
-  uint32_t end_offset = verifier::VerifierDeps::kNotVerifiedMarker;
-  for (uint32_t i = class_def_index + 1; i < dex_file.NumClassDefs() + 1; ++i) {
-    end_offset = dex_file_class_defs[i];
-    if (end_offset != verifier::VerifierDeps::kNotVerifiedMarker) {
-      break;
-    }
-  }
-  DCHECK_NE(end_offset, verifier::VerifierDeps::kNotVerifiedMarker);
-  uint32_t number_of_extra_strings = 0;
-  const uint32_t* extra_strings_offsets = GetExtraStringsOffsets(dex_file,
-                                                                 verifier_deps,
-                                                                 dex_file_class_defs,
-                                                                 &number_of_extra_strings);
-  StackHandleScope<3> hs(self);
-  ClassLinker* class_linker = Runtime::Current()->GetClassLinker();
-  Handle<mirror::ClassLoader> class_loader(hs.NewHandle(cls->GetClassLoader()));
-  MutableHandle<mirror::Class> source(hs.NewHandle<mirror::Class>(nullptr));
-  MutableHandle<mirror::Class> destination(hs.NewHandle<mirror::Class>(nullptr));
-  const uint8_t* cursor = verifier_deps + class_def_offset;
-  const uint8_t* end = verifier_deps + end_offset;
-  while (cursor < end) {
-    uint32_t destination_index;
-    uint32_t source_index;
-    if (UNLIKELY(!DecodeUnsignedLeb128Checked(&cursor, end, &destination_index) ||
-                 !DecodeUnsignedLeb128Checked(&cursor, end, &source_index))) {
-      return ClassStatus::kResolved;
-    }
-    const char* destination_desc = GetStringFromId(dex_file,
-                                                   dex::StringIndex(destination_index),
-                                                   number_of_extra_strings,
-                                                   extra_strings_offsets,
-                                                   verifier_deps);
-    destination.Assign(
-        FindClassAndClearException(class_linker, self, destination_desc, class_loader));
-    const char* source_desc = GetStringFromId(dex_file,
-                                              dex::StringIndex(source_index),
-                                              number_of_extra_strings,
-                                              extra_strings_offsets,
-                                              verifier_deps);
-    source.Assign(FindClassAndClearException(class_linker, self, source_desc, class_loader));
-    if (destination == nullptr || source == nullptr) {
-      continue;
-    }
-    DCHECK(destination->IsResolved() && source->IsResolved());
-    if (!destination->IsAssignableFrom(source.Get())) {
-      VLOG(verifier) << "Vdex checking failed for " << cls->PrettyClass()
-                     << ": expected " << destination->PrettyClass()
-                     << " to be assignable from " << source->PrettyClass();
-      return ClassStatus::kResolved;
-    }
-  }
-  return ClassStatus::kVerifiedNeedsAccessChecks;
-}
-ClassStatus VdexFile::ComputeClassStatus(Thread* self, Handle<mirror::Class> cls) const {
-  const DexFile& dex_file = cls->GetDexFile();
-  uint16_t class_def_index = cls->GetDexClassDefIndex();
-  uint32_t index = 0;
-  for (; index < GetNumberOfDexFiles(); ++index) {
-    if (dex_file.GetLocationChecksum() == GetLocationChecksum(index)) {
-      break;
-    }
-  }
-  DCHECK_NE(index, GetNumberOfDexFiles());
-  const uint8_t* verifier_deps = GetVerifierDepsData().data();
-  const uint32_t* dex_file_class_defs = GetDexFileClassDefs(verifier_deps, index);
-  uint32_t class_def_offset = dex_file_class_defs[class_def_index];
-  if (class_def_offset == verifier::VerifierDeps::kNotVerifiedMarker) {
-    return ClassStatus::kResolved;
+bool VdexFile::VdexFileHeader::IsMagicValid() const {
+  return (memcmp(magic_, kVdexMagic, sizeof(kVdexMagic)) == 0);
@@ -803,5 +35,2 @@ ClassStatus VdexFile::ComputeClassStatus(Thread* self, Handle<mirror::Class> cls
-  uint32_t end_offset = verifier::VerifierDeps::kNotVerifiedMarker;
-  for (uint32_t i = class_def_index + 1; i < dex_file.NumClassDefs() + 1; ++i) {
-    end_offset = dex_file_class_defs[i];
-    if (end_offset != verifier::VerifierDeps::kNotVerifiedMarker) {
-      break;
+bool VdexFile::VdexFileHeader::IsVdexVersionValid() const {
+  return (memcmp(vdex_version_, kVdexVersion, sizeof(kVdexVersion)) == 0);
@@ -808,0 +38,6 @@ ClassStatus VdexFile::ComputeClassStatus(Thread* self, Handle<mirror::Class> cls
+VdexFile::VdexFileHeader::VdexFileHeader(bool has_dex_section ATTRIBUTE_UNUSED)
+    : number_of_sections_(static_cast<uint32_t>(VdexSection::kNumberOfSections)) {
+  memcpy(magic_, kVdexMagic, sizeof(kVdexMagic));
+  memcpy(vdex_version_, kVdexVersion, sizeof(kVdexVersion));
+  DCHECK(IsMagicValid());
+  DCHECK(IsVdexVersionValid());
@@ -810,19 +45,12 @@ ClassStatus VdexFile::ComputeClassStatus(Thread* self, Handle<mirror::Class> cls
-  DCHECK_NE(end_offset, verifier::VerifierDeps::kNotVerifiedMarker);
-  uint32_t number_of_extra_strings = 0;
-  const uint32_t* extra_strings_offsets = GetExtraStringsOffsets(dex_file,
-                                                                 verifier_deps,
-                                                                 dex_file_class_defs,
-                                                                 &number_of_extra_strings);
-  StackHandleScope<3> hs(self);
-  ClassLinker* class_linker = Runtime::Current()->GetClassLinker();
-  Handle<mirror::ClassLoader> class_loader(hs.NewHandle(cls->GetClassLoader()));
-  MutableHandle<mirror::Class> source(hs.NewHandle<mirror::Class>(nullptr));
-  MutableHandle<mirror::Class> destination(hs.NewHandle<mirror::Class>(nullptr));
-  const uint8_t* cursor = verifier_deps + class_def_offset;
-  const uint8_t* end = verifier_deps + end_offset;
-  while (cursor < end) {
-    uint32_t destination_index;
-    uint32_t source_index;
-    if (UNLIKELY(!DecodeUnsignedLeb128Checked(&cursor, end, &destination_index) ||
-                 !DecodeUnsignedLeb128Checked(&cursor, end, &source_index))) {
-      return ClassStatus::kResolved;
+std::unique_ptr<VdexFile> VdexFile::OpenAtAddress(uint8_t* mmap_addr,
+                                                  size_t mmap_size,
+                                                  bool mmap_reuse,
+                                                  const std::string& vdex_filename,
+                                                  bool writable,
+                                                  bool low_4gb,
+                                                  bool unquicken,
+                                                  std::string* error_msg) {
+  ScopedTrace trace(("VdexFile::OpenAtAddress " + vdex_filename).c_str());
+  if (!OS::FileExists(vdex_filename.c_str())) {
+    *error_msg = "File " + vdex_filename + " does not exist.";
+    return nullptr;
@@ -830,15 +58,5 @@ ClassStatus VdexFile::ComputeClassStatus(Thread* self, Handle<mirror::Class> cls
-    const char* destination_desc = GetStringFromId(dex_file,
-                                                   dex::StringIndex(destination_index),
-                                                   number_of_extra_strings,
-                                                   extra_strings_offsets,
-                                                   verifier_deps);
-    destination.Assign(
-        FindClassAndClearException(class_linker, self, destination_desc, class_loader));
-    const char* source_desc = GetStringFromId(dex_file,
-                                              dex::StringIndex(source_index),
-                                              number_of_extra_strings,
-                                              extra_strings_offsets,
-                                              verifier_deps);
-    source.Assign(FindClassAndClearException(class_linker, self, source_desc, class_loader));
-    if (destination == nullptr || source == nullptr) {
-      continue;
+  std::unique_ptr<File> vdex_file;
+  if (writable) {
+    vdex_file.reset(OS::OpenFileReadWrite(vdex_filename.c_str()));
+  } else {
+    vdex_file.reset(OS::OpenFileForReading(vdex_filename.c_str()));
@@ -846,6 +64,4 @@ ClassStatus VdexFile::ComputeClassStatus(Thread* self, Handle<mirror::Class> cls
-    DCHECK(destination->IsResolved() && source->IsResolved());
-    if (!destination->IsAssignableFrom(source.Get())) {
-      VLOG(verifier) << "Vdex checking failed for " << cls->PrettyClass()
-                     << ": expected " << destination->PrettyClass()
-                     << " to be assignable from " << source->PrettyClass();
-      return ClassStatus::kResolved;
+  if (vdex_file == nullptr) {
+    *error_msg = "Could not open file " + vdex_filename +
+                 (writable ? " for read/write" : "for reading");
+    return nullptr;
@@ -852,0 +69,4 @@ ClassStatus VdexFile::ComputeClassStatus(Thread* self, Handle<mirror::Class> cls
+  int64_t vdex_length = vdex_file->GetLength();
+  if (vdex_length == -1) {
+    *error_msg = "Could not read the length of file " + vdex_filename;
+    return nullptr;
@@ -854 +74,10 @@ ClassStatus VdexFile::ComputeClassStatus(Thread* self, Handle<mirror::Class> cls
-  return ClassStatus::kVerifiedNeedsAccessChecks;
+  return OpenAtAddress(mmap_addr,
+                       mmap_size,
+                       mmap_reuse,
+                       vdex_file->Fd(),
+                       vdex_length,
+                       vdex_filename,
+                       writable,
+                       low_4gb,
+                       unquicken,
+                       error_msg);
@@ -1082,0 +327,109 @@ bool VdexFile::MatchesDexFileChecksums(const std::vector<const DexFile::Header*>
+static ObjPtr<mirror::Class> FindClassAndClearException(ClassLinker* class_linker,
+                                                        Thread* self,
+                                                        const char* name,
+                                                        Handle<mirror::ClassLoader> class_loader)
+    REQUIRES_SHARED(Locks::mutator_lock_) {
+  ObjPtr<mirror::Class> result = class_linker->FindClass(self, name, class_loader);
+  if (result == nullptr) {
+    DCHECK(self->IsExceptionPending());
+    self->ClearException();
+  }
+  return result;
+}
+static const char* GetStringFromId(const DexFile& dex_file,
+                                   dex::StringIndex string_id,
+                                   uint32_t number_of_extra_strings,
+                                   const uint32_t* extra_strings_offsets,
+                                   const uint8_t* verifier_deps) {
+  uint32_t num_ids_in_dex = dex_file.NumStringIds();
+  if (string_id.index_ < num_ids_in_dex) {
+    return dex_file.StringDataByIdx(string_id);
+  } else {
+    CHECK_LT(string_id.index_ - num_ids_in_dex, number_of_extra_strings);
+    uint32_t offset = extra_strings_offsets[string_id.index_ - num_ids_in_dex];
+    return reinterpret_cast<const char*>(verifier_deps) + offset;
+  }
+}
+static const uint32_t* GetDexFileClassDefs(const uint8_t* verifier_deps, uint32_t index) {
+  uint32_t dex_file_offset = reinterpret_cast<const uint32_t*>(verifier_deps)[index];
+  return reinterpret_cast<const uint32_t*>(verifier_deps + dex_file_offset);
+}
+static const uint32_t* GetExtraStringsOffsets(const DexFile& dex_file,
+                                              const uint8_t* verifier_deps,
+                                              const uint32_t* dex_file_class_defs,
+                                                      uint32_t* number_of_extra_strings) {
+  uint32_t end_of_assignability_types = dex_file_class_defs[dex_file.NumClassDefs()];
+  const uint8_t* strings_data_start =
+      AlignUp(verifier_deps + end_of_assignability_types, sizeof(uint32_t));
+  *number_of_extra_strings = *reinterpret_cast<const uint32_t*>(strings_data_start);
+  return reinterpret_cast<const uint32_t*>(strings_data_start + sizeof(uint32_t));
+}
+ClassStatus VdexFile::ComputeClassStatus(Thread* self, Handle<mirror::Class> cls) const {
+  const DexFile& dex_file = cls->GetDexFile();
+  uint16_t class_def_index = cls->GetDexClassDefIndex();
+  uint32_t index = 0;
+  for (; index < GetNumberOfDexFiles(); ++index) {
+    if (dex_file.GetLocationChecksum() == GetLocationChecksum(index)) {
+      break;
+    }
+  }
+  DCHECK_NE(index, GetNumberOfDexFiles());
+  const uint8_t* verifier_deps = GetVerifierDepsData().data();
+  const uint32_t* dex_file_class_defs = GetDexFileClassDefs(verifier_deps, index);
+  uint32_t class_def_offset = dex_file_class_defs[class_def_index];
+  if (class_def_offset == verifier::VerifierDeps::kNotVerifiedMarker) {
+    return ClassStatus::kResolved;
+  }
+  uint32_t end_offset = verifier::VerifierDeps::kNotVerifiedMarker;
+  for (uint32_t i = class_def_index + 1; i < dex_file.NumClassDefs() + 1; ++i) {
+    end_offset = dex_file_class_defs[i];
+    if (end_offset != verifier::VerifierDeps::kNotVerifiedMarker) {
+      break;
+    }
+  }
+  DCHECK_NE(end_offset, verifier::VerifierDeps::kNotVerifiedMarker);
+  uint32_t number_of_extra_strings = 0;
+  const uint32_t* extra_strings_offsets = GetExtraStringsOffsets(dex_file,
+                                                                 verifier_deps,
+                                                                 dex_file_class_defs,
+                                                                 &number_of_extra_strings);
+  StackHandleScope<3> hs(self);
+  ClassLinker* class_linker = Runtime::Current()->GetClassLinker();
+  Handle<mirror::ClassLoader> class_loader(hs.NewHandle(cls->GetClassLoader()));
+  MutableHandle<mirror::Class> source(hs.NewHandle<mirror::Class>(nullptr));
+  MutableHandle<mirror::Class> destination(hs.NewHandle<mirror::Class>(nullptr));
+  const uint8_t* cursor = verifier_deps + class_def_offset;
+  const uint8_t* end = verifier_deps + end_offset;
+  while (cursor < end) {
+    uint32_t destination_index;
+    uint32_t source_index;
+    if (UNLIKELY(!DecodeUnsignedLeb128Checked(&cursor, end, &destination_index) ||
+                 !DecodeUnsignedLeb128Checked(&cursor, end, &source_index))) {
+      return ClassStatus::kResolved;
+    }
+    const char* destination_desc = GetStringFromId(dex_file,
+                                                   dex::StringIndex(destination_index),
+                                                   number_of_extra_strings,
+                                                   extra_strings_offsets,
+                                                   verifier_deps);
+    destination.Assign(
+        FindClassAndClearException(class_linker, self, destination_desc, class_loader));
+    const char* source_desc = GetStringFromId(dex_file,
+                                              dex::StringIndex(source_index),
+                                              number_of_extra_strings,
+                                              extra_strings_offsets,
+                                              verifier_deps);
+    source.Assign(FindClassAndClearException(class_linker, self, source_desc, class_loader));
+    if (destination == nullptr || source == nullptr) {
+      continue;
+    }
+    DCHECK(destination->IsResolved() && source->IsResolved());
+    if (!destination->IsAssignableFrom(source.Get())) {
+      VLOG(verifier) << "Vdex checking failed for " << cls->PrettyClass()
+                     << ": expected " << destination->PrettyClass()
+                     << " to be assignable from " << source->PrettyClass();
+      return ClassStatus::kResolved;
+    }
+  }
+  return ClassStatus::kVerifiedNeedsAccessChecks;
+}
