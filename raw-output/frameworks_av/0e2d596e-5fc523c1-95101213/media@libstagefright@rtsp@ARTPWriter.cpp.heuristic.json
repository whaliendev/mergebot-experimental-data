[
  {
    "code": [
      "void ARTPWriter::addTMMBN(const sp<ABuffer> &buffer) {",
      "    if (buffer->size() + 20 > buffer->capacity()) {",
      "        ALOGW(\"RTCP buffer too small to accomodate SR.\");",
      "        return;",
      "    }",
      "    if (mOpponentID == 0)",
      "        return;",
      "",
      "    uint8_t *data = buffer->data() + buffer->size();",
      "",
      "    data[0] = 0x80 | 4; // TMMBN",
      "    data[1] = 205;      // TSFB",
      "    data[2] = 0;",
      "    data[3] = 4;        // total (4+1) * sizeof(int32_t) = 20 bytes",
      "    data[4] = mSourceID >> 24;",
      "    data[5] = (mSourceID >> 16) & 0xff;",
      "    data[6] = (mSourceID >> 8) & 0xff;",
      "    data[7] = mSourceID & 0xff;",
      "",
      "    *(int32_t*)(&data[8]) = 0;  // 4 bytes blank",
      "",
      "    data[12] = mOpponentID >> 24;",
      "    data[13] = (mOpponentID >> 16) & 0xff;",
      "    data[14] = (mOpponentID >> 8) & 0xff;",
      "    data[15] = mOpponentID & 0xff;",
      "",
      "    int32_t exp, mantissa;",
      "",
      "    // Round off to the nearest 2^4th",
      "    ALOGI(\"UE -> Op Noti Tx bitrate : %d \", mBitrate & 0xfffffff0);",
      "    for (exp=4 ; exp < 32 ; exp++)",
      "        if (((mBitrate >> exp) & 0x01) != 0)",
      "            break;",
      "    mantissa = mBitrate >> exp;",
      "",
      "    data[16] = ((exp << 2) & 0xfc) | ((mantissa & 0x18000) >> 15);",
      "    data[17] =                        (mantissa & 0x07f80) >> 7;",
      "    data[18] =                        (mantissa & 0x0007f) << 1;",
      "    data[19] = 40;              // 40 bytes overhead;",
      "",
      "    buffer->setRange(buffer->offset(), buffer->size() + 20);",
      "}",
      "void ARTPWriter::addTMMBN(const sp<ABuffer> &buffer) {",
      "    if (buffer->size() + 20 > buffer->capacity()) {",
      "        ALOGW(\"RTCP buffer too small to accommodate SR.\");",
      "        return;",
      "    }",
      "    if (mOpponentID == 0)",
      "        return;",
      "",
      "    uint8_t *data = buffer->data() + buffer->size();",
      "",
      "    data[0] = 0x80 | 4; // TMMBN",
      "    data[1] = 205;      // TSFB",
      "    data[2] = 0;",
      "    data[3] = 4;        // total (4+1) * sizeof(int32_t) = 20 bytes",
      "    data[4] = mSourceID >> 24;",
      "    data[5] = (mSourceID >> 16) & 0xff;",
      "    data[6] = (mSourceID >> 8) & 0xff;",
      "    data[7] = mSourceID & 0xff;",
      "",
      "    *(int32_t*)(&data[8]) = 0;  // 4 bytes blank",
      "",
      "    data[12] = mOpponentID >> 24;",
      "    data[13] = (mOpponentID >> 16) & 0xff;",
      "    data[14] = (mOpponentID >> 8) & 0xff;",
      "    data[15] = mOpponentID & 0xff;",
      "",
      "    int32_t exp, mantissa;",
      "",
      "    // Round off to the nearest 2^4th",
      "    ALOGI(\"UE -> Op Noti Tx bitrate : %d \", mBitrate & 0xfffffff0);",
      "    for (exp=4 ; exp < 32 ; exp++)",
      "        if (((mBitrate >> exp) & 0x01) != 0)",
      "            break;",
      "    mantissa = mBitrate >> exp;",
      "",
      "    data[16] = ((exp << 2) & 0xfc) | ((mantissa & 0x18000) >> 15);",
      "    data[17] =                        (mantissa & 0x07f80) >> 7;",
      "    data[18] =                        (mantissa & 0x0007f) << 1;",
      "    data[19] = 40;              // 40 bytes overhead;",
      "",
      "    buffer->setRange(buffer->offset(), buffer->size() + 20);",
      "}"
    ],
    "label": "",
    "index": 1,
    "confidence": 0.4,
    "desc": "List merge."
  }
]