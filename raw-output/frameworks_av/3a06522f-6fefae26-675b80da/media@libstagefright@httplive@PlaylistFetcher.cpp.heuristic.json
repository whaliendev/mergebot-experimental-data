[
  {
    "desc": "Added code or method extraction, accept our side.",
    "confidence": 0.7,
    "index": 0,
    "label": "",
    "code": [
      "                CHECK(accessUnit->meta()->findInt64(\"timeUs\", &timeUs));",
      "                if (mMinStartTimeUs > 0) {",
      "                    if (timeUs < mMinStartTimeUs) {",
      "                        // TODO untested path",
      "                        // try a later ts",
      "                        int32_t targetDuration;",
      "                        mPlaylist->meta()->findInt32(\"target-duration\", &targetDuration);",
      "                        int32_t incr = (mMinStartTimeUs - timeUs) / 1000000 / targetDuration;",
      "                        if (incr == 0) {",
      "                            // increment mSeqNumber by at least one",
      "                            incr = 1;",
      "                        }",
      "                        mSeqNumber += incr;",
      "                        err = -EAGAIN;",
      "                        break;",
      "                    } else {",
      "                        int64_t startTimeUs;",
      "                        if (mStartTimeUsNotify != NULL",
      "                                && !mStartTimeUsNotify->findInt64(key, &startTimeUs)) {",
      "                            mStartTimeUsNotify->setInt64(key, timeUs);",
      "",
      "                            uint32_t streamMask = 0;",
      "                            mStartTimeUsNotify->findInt32(\"streamMask\", (int32_t *) &streamMask);",
      "                            streamMask |= mPacketSources.keyAt(i);",
      "                            mStartTimeUsNotify->setInt32(\"streamMask\", streamMask);",
      "",
      "                            if (streamMask == mStreamTypeMask) {",
      "                                mStartTimeUsNotify->post();",
      "                                mStartTimeUsNotify.clear();",
      "                            }",
      "                        }",
      "                    }",
      "                }",
      "",
      "                if (mStopParams != NULL) {",
      "                    // Queue discontinuity in original stream.",
      "                    int64_t stopTimeUs;",
      "                    if (!mStopParams->findInt64(key, &stopTimeUs) || timeUs >= stopTimeUs) {",
      "                        packetSource->queueAccessUnit(mSession->createFormatChangeBuffer());",
      "                        mStreamTypeMask &= ~stream;",
      "                        mPacketSources.removeItemsAt(i);",
      "                        break;",
      "                    }",
      "                }",
      "",
      "                // Note that we do NOT dequeue any discontinuities except for format change.",
      "",
      "                // for simplicity, store a reference to the format in each unit",
      "                sp<MetaData> format = source->getFormat();",
      "                if (format != NULL) {",
      "                    accessUnit->meta()->setObject(\"format\", format);",
      "                }",
      "",
      "                // Stash the sequence number so we can hint future fetchers where to start at.",
      "                accessUnit->meta()->setInt32(\"seq\", mSeqNumber);"
    ]
  },
  {
    "code": [],
    "label": "",
    "index": 1,
    "confidence": 0.7,
    "desc": "Single side deletion."
  }
]