[
  {
    "code": [
      "void MelReporter::onFirstRef() {",
      "    mAudioFlinger.mPatchCommandThread->addListener(this);",
      "void MelReporter::onFirstRef() {",
      "    mAfMelReporterCallback->getPatchCommandThread()->addListener(this);",
      "",
      "    mSoundDoseManager = sp<SoundDoseManager>::make(sp<IMelReporterCallback>::fromExisting(this));"
    ],
    "label": "",
    "index": 0,
    "confidence": 0.4,
    "desc": "List merge."
  },
  {
    "desc": "Added code or method extraction, accept their side.",
    "confidence": 0.7,
    "index": 1,
    "label": "",
    "code": [
      "bool MelReporter::shouldComputeMelForDeviceType(audio_devices_t device) {",
      "    if (!mSoundDoseManager->isCsdEnabled()) {",
      "        ALOGV(\"%s csd is disabled\", __func__);",
      "        return false;",
      "    }",
      "    if (mSoundDoseManager->forceComputeCsdOnAllDevices()) {",
      "        return true;",
      "    }",
      "",
      "    switch (device) {",
      "        case AUDIO_DEVICE_OUT_WIRED_HEADSET:",
      "        case AUDIO_DEVICE_OUT_WIRED_HEADPHONE:",
      "        // TODO(b/278265907): enable A2DP when we can distinguish A2DP headsets",
      "        // case AUDIO_DEVICE_OUT_BLUETOOTH_A2DP:",
      "        case AUDIO_DEVICE_OUT_BLUETOOTH_A2DP_HEADPHONES:",
      "        case AUDIO_DEVICE_OUT_USB_HEADSET:",
      "        case AUDIO_DEVICE_OUT_BLE_HEADSET:",
      "        case AUDIO_DEVICE_OUT_BLE_BROADCAST:",
      "            return true;",
      "        default:",
      "            return false;",
      "    }",
      "}",
      "",
      "void MelReporter::updateMetadataForCsd(audio_io_handle_t streamHandle,"
    ]
  },
  {
    "code": [
      "void MelReporter::startMelComputationForDeviceId(audio_port_handle_t deviceId) {",
      "    ALOGV(\"%s(%d)\", __func__, deviceId);",
      "    std::lock_guard _laf(mAfMelReporterCallback->mutex());",
      "    std::lock_guard _l(mLock);",
      "",
      "    for (auto& activeMelPatch : mActiveMelPatches) {",
      "        bool csdActive = false;",
      "        for (auto& device: activeMelPatch.second.deviceStates) {",
      "            if (device.first == deviceId && !device.second) {",
      "                device.second = true;",
      "            }",
      "            csdActive |= device.second;",
      "        }",
      "        if (csdActive && !activeMelPatch.second.csdActive) {",
      "            activeMelPatch.second.csdActive = csdActive;",
      "            startMelComputationForActivePatch_l(activeMelPatch.second);",
      "        }",
      "    }",
      "}",
      "",
      "void MelReporter::onReleaseAudioPatch(audio_patch_handle_t handle) {"
    ],
    "label": "",
    "index": 2,
    "confidence": 0.7,
    "desc": "Added code or method extraction, accept our side."
  },
  {
    "code": [
      "void MelReporter::stopMelComputationForDeviceId(audio_port_handle_t deviceId) {",
      "    ALOGV(\"%s(%d)\", __func__, deviceId);",
      "    std::lock_guard _laf(mAfMelReporterCallback->mutex());",
      "    std::lock_guard _l(mLock);",
      "",
      "    for (auto& activeMelPatch : mActiveMelPatches) {",
      "        bool csdActive = false;",
      "        for (auto& device: activeMelPatch.second.deviceStates) {",
      "            if (device.first == deviceId && device.second) {",
      "                device.second = false;",
      "            }",
      "            csdActive |= device.second;",
      "        }",
      "",
      "        if (!csdActive && activeMelPatch.second.csdActive) {",
      "            activeMelPatch.second.csdActive = csdActive;",
      "            stopMelComputationForPatch_l(activeMelPatch.second);",
      "        }",
      "    }",
      "",
      "}",
      "",
      "std::optional<audio_patch_handle_t> MelReporter::activePatchStreamHandle_l("
    ],
    "label": "",
    "index": 3,
    "confidence": 0.7,
    "desc": "Added code or method extraction, accept our side."
  }
]