--- a/output/frameworks_native/26b1e747-267b4c49-3264ef9a/services@surfaceflinger@Scheduler@Scheduler.no_comments_mergebot.cpp
+++ b/output/frameworks_native/26b1e747-267b4c49-3264ef9a/services@surfaceflinger@Scheduler@Scheduler.no_comments_truth.cpp
@@ -24,3 +23,0 @@
-#include "IdleTimer.h"
-#include "InjectVSyncSource.h"
-#include "LayerInfo.h"
@@ -38,3 +34,0 @@ namespace android {
-using namespace android::hardware::configstore;
-using namespace android::hardware::configstore::V1_0;
-using namespace android::sysprop;
@@ -101,49 +102,189 @@ Scheduler::ConnectionHandle Scheduler::createConnection(std::unique_ptr<EventThr
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
-    }
-}
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
-    }
-}
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
-    }
-}
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
-    }
-}
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
-    }
-}
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
-    }
-}
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
-    }
-}
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
-    }
-}
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
+std::unique_ptr<EventThread> Scheduler::makeEventThread(
+        const char* connectionName, nsecs_t phaseOffsetNs, nsecs_t offsetThresholdForNextVsync,
+        impl::EventThread::InterceptVSyncsCallback&& interceptCallback) {
+    auto source = std::make_unique<DispSyncSource>(mPrimaryDispSync.get(), phaseOffsetNs,
+                                                   offsetThresholdForNextVsync,
+                                                   true , connectionName);
+    return std::make_unique<impl::EventThread>(std::move(source), std::move(interceptCallback),
+                                               connectionName);
+}
+sp<EventThreadConnection> Scheduler::createConnectionInternal(
+        EventThread* eventThread, ResyncCallback&& resyncCallback,
+        ISurfaceComposer::ConfigChanged configChanged) {
+    return eventThread->createEventConnection(std::move(resyncCallback), configChanged);
+}
+sp<IDisplayEventConnection> Scheduler::createDisplayEventConnection(
+        ConnectionHandle handle, ResyncCallback resyncCallback,
+        ISurfaceComposer::ConfigChanged configChanged) {
+    RETURN_IF_INVALID_HANDLE(handle, nullptr);
+    return createConnectionInternal(mConnections[handle].thread.get(), std::move(resyncCallback),
+                                    configChanged);
+}
+EventThread* Scheduler::getEventThread(ConnectionHandle handle) {
+    RETURN_IF_INVALID_HANDLE(handle, nullptr);
+    return mConnections[handle].thread.get();
+}
+sp<EventThreadConnection> Scheduler::getEventConnection(ConnectionHandle handle) {
+    RETURN_IF_INVALID_HANDLE(handle, nullptr);
+    return mConnections[handle].connection;
+}
+void Scheduler::onHotplugReceived(ConnectionHandle handle, PhysicalDisplayId displayId,
+                                  bool connected) {
+    RETURN_IF_INVALID_HANDLE(handle);
+    mConnections[handle].thread->onHotplugReceived(displayId, connected);
+}
+void Scheduler::onScreenAcquired(ConnectionHandle handle) {
+    RETURN_IF_INVALID_HANDLE(handle);
+    mConnections[handle].thread->onScreenAcquired();
+}
+void Scheduler::onScreenReleased(ConnectionHandle handle) {
+    RETURN_IF_INVALID_HANDLE(handle);
+    mConnections[handle].thread->onScreenReleased();
+}
+void Scheduler::onConfigChanged(ConnectionHandle handle, PhysicalDisplayId displayId,
+                                int32_t configId) {
+    RETURN_IF_INVALID_HANDLE(handle);
+    mConnections[handle].thread->onConfigChanged(displayId, configId);
+}
+void Scheduler::dump(ConnectionHandle handle, std::string& result) const {
+    RETURN_IF_INVALID_HANDLE(handle);
+    mConnections.at(handle).thread->dump(result);
+}
+void Scheduler::setPhaseOffset(ConnectionHandle handle, nsecs_t phaseOffset) {
+    RETURN_IF_INVALID_HANDLE(handle);
+    mConnections[handle].thread->setPhaseOffset(phaseOffset);
+}
+void Scheduler::getDisplayStatInfo(DisplayStatInfo* stats) {
+    stats->vsyncTime = mPrimaryDispSync->computeNextRefresh(0);
+    stats->vsyncPeriod = mPrimaryDispSync->getPeriod();
+}
+void Scheduler::enableHardwareVsync() {
+    std::lock_guard<std::mutex> lock(mHWVsyncLock);
+    if (!mPrimaryHWVsyncEnabled && mHWVsyncAvailable) {
+        mPrimaryDispSync->beginResync();
+        mEventControlThread->setVsyncEnabled(true);
+        mPrimaryHWVsyncEnabled = true;
+    }
+}
+void Scheduler::disableHardwareVsync(bool makeUnavailable) {
+    std::lock_guard<std::mutex> lock(mHWVsyncLock);
+    if (mPrimaryHWVsyncEnabled) {
+        mEventControlThread->setVsyncEnabled(false);
+        mPrimaryDispSync->endResync();
+        mPrimaryHWVsyncEnabled = false;
+    }
+    if (makeUnavailable) {
+        mHWVsyncAvailable = false;
+    }
+}
+void Scheduler::resyncToHardwareVsync(bool makeAvailable, nsecs_t period) {
+    {
+        std::lock_guard<std::mutex> lock(mHWVsyncLock);
+        if (makeAvailable) {
+            mHWVsyncAvailable = makeAvailable;
+        } else if (!mHWVsyncAvailable) {
+            return;
+        }
+    }
+    if (period <= 0) {
+        return;
+    }
+    setVsyncPeriod(period);
+}
+ResyncCallback Scheduler::makeResyncCallback(GetVsyncPeriod&& getVsyncPeriod) {
+    std::weak_ptr<VsyncState> ptr = mPrimaryVsyncState;
+    return [ptr, getVsyncPeriod = std::move(getVsyncPeriod)]() {
+        if (const auto vsync = ptr.lock()) {
+            vsync->resync(getVsyncPeriod);
+        }
+    };
+}
+void Scheduler::VsyncState::resync(const GetVsyncPeriod& getVsyncPeriod) {
+    static constexpr nsecs_t kIgnoreDelay = ms2ns(500);
+    const nsecs_t now = systemTime();
+    const nsecs_t last = lastResyncTime.exchange(now);
+    if (now - last > kIgnoreDelay) {
+        scheduler.resyncToHardwareVsync(false, getVsyncPeriod());
+    }
+}
+void Scheduler::setVsyncPeriod(nsecs_t period) {
+    std::lock_guard<std::mutex> lock(mHWVsyncLock);
+    mPrimaryDispSync->setPeriod(period);
+    if (!mPrimaryHWVsyncEnabled) {
+        mPrimaryDispSync->beginResync();
+        mEventControlThread->setVsyncEnabled(true);
+        mPrimaryHWVsyncEnabled = true;
+    }
+}
+void Scheduler::addResyncSample(nsecs_t timestamp, bool* periodFlushed) {
+    bool needsHwVsync = false;
+    *periodFlushed = false;
+    {
+        std::lock_guard<std::mutex> lock(mHWVsyncLock);
+        if (mPrimaryHWVsyncEnabled) {
+            needsHwVsync = mPrimaryDispSync->addResyncSample(timestamp, periodFlushed);
+        }
+    }
+    if (needsHwVsync) {
+        enableHardwareVsync();
+    } else {
+        disableHardwareVsync(false);
+    }
+}
+void Scheduler::addPresentFence(const std::shared_ptr<FenceTime>& fenceTime) {
+    if (mPrimaryDispSync->addPresentFence(fenceTime)) {
+        enableHardwareVsync();
+    } else {
+        disableHardwareVsync(false);
+    }
+}
+void Scheduler::setIgnorePresentFences(bool ignore) {
+    mPrimaryDispSync->setIgnorePresentFences(ignore);
+}
+nsecs_t Scheduler::getDispSyncExpectedPresentTime() {
+    return mPrimaryDispSync->expectedPresentTime();
+}
+std::unique_ptr<scheduler::LayerHistory::LayerHandle> Scheduler::registerLayer(
+        std::string const& name, int windowType) {
+    RefreshRateType refreshRateType = (windowType == InputWindowInfo::TYPE_WALLPAPER)
+            ? RefreshRateType::DEFAULT
+            : RefreshRateType::PERFORMANCE;
+    const auto refreshRate = mRefreshRateConfigs.getRefreshRate(refreshRateType);
+    const uint32_t performanceFps = (refreshRate) ? refreshRate->fps : 0;
+    const auto defaultRefreshRate = mRefreshRateConfigs.getRefreshRate(RefreshRateType::DEFAULT);
+    const uint32_t defaultFps = (defaultRefreshRate) ? defaultRefreshRate->fps : 0;
+    return mLayerHistory.createLayer(name, defaultFps, performanceFps);
+}
+void Scheduler::addLayerPresentTimeAndHDR(
+        const std::unique_ptr<scheduler::LayerHistory::LayerHandle>& layerHandle,
+        nsecs_t presentTime, bool isHDR) {
+    mLayerHistory.insert(layerHandle, presentTime, isHDR);
+}
+void Scheduler::setLayerVisibility(
+        const std::unique_ptr<scheduler::LayerHistory::LayerHandle>& layerHandle, bool visible) {
+    mLayerHistory.setVisibility(layerHandle, visible);
+}
+void Scheduler::updateFpsBasedOnContent() {
+    auto [refreshRate, isHDR] = mLayerHistory.getDesiredRefreshRateAndHDR();
+    const uint32_t refreshRateRound = std::round(refreshRate);
+    RefreshRateType newRefreshRateType;
+    {
+        std::lock_guard<std::mutex> lock(mFeatureStateLock);
+        if (mFeatures.contentRefreshRate == refreshRateRound && mFeatures.isHDRContent == isHDR) {
+            return;
+        }
+        mFeatures.contentRefreshRate = refreshRateRound;
+        ATRACE_INT("ContentFPS", refreshRateRound);
+        mFeatures.isHDRContent = isHDR;
+        ATRACE_INT("ContentHDR", isHDR);
+        mFeatures.contentDetection =
+                refreshRateRound > 0 ? ContentDetectionState::On : ContentDetectionState::Off;
+        newRefreshRateType = calculateRefreshRateType();
+        if (mFeatures.refreshRateType == newRefreshRateType) {
+            return;
+        }
+        mFeatures.refreshRateType = newRefreshRateType;
+    }
+    changeRefreshRate(newRefreshRateType, ConfigEvent::Changed);
+}
+void Scheduler::setChangeRefreshRateCallback(ChangeRefreshRateCallback&& callback) {
@@ -151,3 +292 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
-    }
+    mChangeRefreshRateCallback = std::move(callback);
@@ -155 +294 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
+void Scheduler::setGetCurrentRefreshRateTypeCallback(GetCurrentRefreshRateTypeCallback&& callback) {
@@ -157,2 +296 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+    mGetCurrentRefreshRateTypeCallback = std::move(callback);
@@ -160,2 +298 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-}
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
+void Scheduler::setGetVsyncPeriodCallback(GetVsyncPeriod&& callback) {
@@ -163,3 +300 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
-    }
+    mGetVsyncPeriod = std::move(callback);
@@ -167,4 +302,3 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+void Scheduler::resetIdleTimer() {
+    if (mIdleTimer) {
+        mIdleTimer->reset();
@@ -173,4 +307,3 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+void Scheduler::notifyTouchEvent() {
+    if (mTouchTimer) {
+        mTouchTimer->reset();
@@ -177,0 +311,2 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+    if (mSupportKernelTimer && mIdleTimer) {
+        mIdleTimer->reset();
@@ -179,4 +314 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+    mLayerHistory.clearHistory();
@@ -183,0 +316,4 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+void Scheduler::setDisplayPowerState(bool normal) {
+    {
+        std::lock_guard<std::mutex> lock(mFeatureStateLock);
+        mFeatures.isDisplayPowerStateNormal = normal;
@@ -185,4 +321,2 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+    if (mDisplayPowerTimer) {
+        mDisplayPowerTimer->reset();
@@ -189,0 +324 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+    mLayerHistory.clearHistory();
@@ -191 +326,2 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
+void Scheduler::kernelIdleTimerCallback(TimerState state) {
+    ATRACE_INT("ExpiredKernelIdleTimer", static_cast<int>(state));
@@ -193,3 +329,90 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
-    }
+    if (!mGetCurrentRefreshRateTypeCallback || !mGetVsyncPeriod) return;
+    const auto type = mGetCurrentRefreshRateTypeCallback();
+    if (state == TimerState::Reset && type == RefreshRateType::PERFORMANCE) {
+        resyncToHardwareVsync(true , mGetVsyncPeriod());
+    } else if (state == TimerState::Expired && type != RefreshRateType::PERFORMANCE) {
+        disableHardwareVsync(false );
+    }
+}
+void Scheduler::idleTimerCallback(TimerState state) {
+    handleTimerStateChanged(&mFeatures.idleTimer, state, false );
+    ATRACE_INT("ExpiredIdleTimer", static_cast<int>(state));
+}
+void Scheduler::touchTimerCallback(TimerState state) {
+    const TouchState touch = state == TimerState::Reset ? TouchState::Active : TouchState::Inactive;
+    handleTimerStateChanged(&mFeatures.touch, touch, true );
+    ATRACE_INT("TouchState", static_cast<int>(touch));
+}
+void Scheduler::displayPowerTimerCallback(TimerState state) {
+    handleTimerStateChanged(&mFeatures.displayPowerTimer, state,
+                            true );
+    ATRACE_INT("ExpiredDisplayPowerTimer", static_cast<int>(state));
+}
+void Scheduler::dump(std::string& result) const {
+    std::ostringstream stream;
+    if (mIdleTimer) {
+        stream << "+  Idle timer interval: " << mIdleTimer->interval().count() << " ms\n";
+    }
+    if (mTouchTimer) {
+        stream << "+  Touch timer interval: " << mTouchTimer->interval().count() << " ms\n";
+    }
+    result.append(stream.str());
+}
+template <class T>
+void Scheduler::handleTimerStateChanged(T* currentState, T newState, bool eventOnContentDetection) {
+    ConfigEvent event = ConfigEvent::None;
+    RefreshRateType newRefreshRateType;
+    {
+        std::lock_guard<std::mutex> lock(mFeatureStateLock);
+        if (*currentState == newState) {
+            return;
+        }
+        *currentState = newState;
+        newRefreshRateType = calculateRefreshRateType();
+        if (mFeatures.refreshRateType == newRefreshRateType) {
+            return;
+        }
+        mFeatures.refreshRateType = newRefreshRateType;
+        if (eventOnContentDetection && mFeatures.contentDetection == ContentDetectionState::On) {
+            event = ConfigEvent::Changed;
+        }
+    }
+    changeRefreshRate(newRefreshRateType, event);
+}
+Scheduler::RefreshRateType Scheduler::calculateRefreshRateType() {
+    if (mForceHDRContentToDefaultRefreshRate && mFeatures.isHDRContent) {
+        return RefreshRateType::DEFAULT;
+    }
+    if (!mFeatures.isDisplayPowerStateNormal || mFeatures.displayPowerTimer == TimerState::Reset) {
+        return RefreshRateType::PERFORMANCE;
+    }
+    if (mFeatures.touch == TouchState::Active) {
+        return RefreshRateType::PERFORMANCE;
+    }
+    if (mFeatures.idleTimer == TimerState::Expired) {
+        return RefreshRateType::DEFAULT;
+    }
+    if (mFeatures.contentDetection == ContentDetectionState::Off) {
+        return RefreshRateType::PERFORMANCE;
+    }
+    const float rate = static_cast<float>(mFeatures.contentRefreshRate);
+    auto iter = min_element(mRefreshRateConfigs.getRefreshRates().cbegin(),
+                            mRefreshRateConfigs.getRefreshRates().cend(),
+                            [rate](const auto& lhs, const auto& rhs) -> bool {
+                                return std::abs(lhs.second->fps - rate) <
+                                        std::abs(rhs.second->fps - rate);
+                            });
+    RefreshRateType currRefreshRateType = iter->first;
+    constexpr float MARGIN = 0.05f;
+    float ratio = mRefreshRateConfigs.getRefreshRate(currRefreshRateType)->fps / rate;
+    if (std::abs(std::round(ratio) - ratio) > MARGIN) {
+        while (iter != mRefreshRateConfigs.getRefreshRates().cend()) {
+            ratio = iter->second->fps / rate;
+            if (std::abs(std::round(ratio) - ratio) <= MARGIN) {
+                currRefreshRateType = iter->first;
+                break;
+            }
+            ++iter;
+        }
+    }
+    return currRefreshRateType;
