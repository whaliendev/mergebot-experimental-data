diff --git a/output/frameworks_native/26b1e747-267b4c49-3264ef9a/services@surfaceflinger@SurfaceFlinger.no_comments_mergebot.cpp b/output/frameworks_native/26b1e747-267b4c49-3264ef9a/services@surfaceflinger@SurfaceFlinger.no_comments_truth.cpp
index 2fbd503..fffd75e 100644
--- a/output/frameworks_native/26b1e747-267b4c49-3264ef9a/services@surfaceflinger@SurfaceFlinger.no_comments_mergebot.cpp
+++ b/output/frameworks_native/26b1e747-267b4c49-3264ef9a/services@surfaceflinger@SurfaceFlinger.no_comments_truth.cpp
@@ -106,0 +107,2 @@ namespace {
+#pragma clang diagnostic push
+#pragma clang diagnostic error "-Wswitch-enum"
@@ -141,0 +144 @@ ui::Transform::orientation_flags fromSurfaceComposerRotation(ISurfaceComposer::R
+#pragma clang diagnostic pop
@@ -162,168 +165,14 @@ const String16 sDump("android.permission.DUMP");
-status_t SurfaceFlinger::getSupportedFrameTimestamps(
-        std::vector<FrameEvent>* outSupported) const {
-    *outSupported = {
-        FrameEvent::REQUESTED_PRESENT,
-        FrameEvent::ACQUIRE,
-        FrameEvent::LATCH,
-        FrameEvent::FIRST_REFRESH_START,
-        FrameEvent::LAST_REFRESH_START,
-        FrameEvent::GPU_COMPOSITION_DONE,
-        FrameEvent::DEQUEUE_READY,
-        FrameEvent::RELEASE,
-    };
-status_t SurfaceFlinger::getSupportedFrameTimestamps(
-        std::vector<FrameEvent>* outSupported) const {
-    *outSupported = {
-        FrameEvent::REQUESTED_PRESENT,
-        FrameEvent::ACQUIRE,
-        FrameEvent::LATCH,
-        FrameEvent::FIRST_REFRESH_START,
-        FrameEvent::LAST_REFRESH_START,
-        FrameEvent::GPU_COMPOSITION_DONE,
-        FrameEvent::DEQUEUE_READY,
-        FrameEvent::RELEASE,
-    };
-status_t SurfaceFlinger::getSupportedFrameTimestamps(
-        std::vector<FrameEvent>* outSupported) const {
-    *outSupported = {
-        FrameEvent::REQUESTED_PRESENT,
-        FrameEvent::ACQUIRE,
-        FrameEvent::LATCH,
-        FrameEvent::FIRST_REFRESH_START,
-        FrameEvent::LAST_REFRESH_START,
-        FrameEvent::GPU_COMPOSITION_DONE,
-        FrameEvent::DEQUEUE_READY,
-        FrameEvent::RELEASE,
-    };
-status_t SurfaceFlinger::getSupportedFrameTimestamps(
-        std::vector<FrameEvent>* outSupported) const {
-    *outSupported = {
-        FrameEvent::REQUESTED_PRESENT,
-        FrameEvent::ACQUIRE,
-        FrameEvent::LATCH,
-        FrameEvent::FIRST_REFRESH_START,
-        FrameEvent::LAST_REFRESH_START,
-        FrameEvent::GPU_COMPOSITION_DONE,
-        FrameEvent::DEQUEUE_READY,
-        FrameEvent::RELEASE,
-    };
-status_t SurfaceFlinger::getSupportedFrameTimestamps(
-        std::vector<FrameEvent>* outSupported) const {
-    *outSupported = {
-        FrameEvent::REQUESTED_PRESENT,
-        FrameEvent::ACQUIRE,
-        FrameEvent::LATCH,
-        FrameEvent::FIRST_REFRESH_START,
-        FrameEvent::LAST_REFRESH_START,
-        FrameEvent::GPU_COMPOSITION_DONE,
-        FrameEvent::DEQUEUE_READY,
-        FrameEvent::RELEASE,
-    };
-status_t SurfaceFlinger::getSupportedFrameTimestamps(
-        std::vector<FrameEvent>* outSupported) const {
-    *outSupported = {
-        FrameEvent::REQUESTED_PRESENT,
-        FrameEvent::ACQUIRE,
-        FrameEvent::LATCH,
-        FrameEvent::FIRST_REFRESH_START,
-        FrameEvent::LAST_REFRESH_START,
-        FrameEvent::GPU_COMPOSITION_DONE,
-        FrameEvent::DEQUEUE_READY,
-        FrameEvent::RELEASE,
-    };
-status_t SurfaceFlinger::getSupportedFrameTimestamps(
-        std::vector<FrameEvent>* outSupported) const {
-    *outSupported = {
-        FrameEvent::REQUESTED_PRESENT,
-        FrameEvent::ACQUIRE,
-        FrameEvent::LATCH,
-        FrameEvent::FIRST_REFRESH_START,
-        FrameEvent::LAST_REFRESH_START,
-        FrameEvent::GPU_COMPOSITION_DONE,
-        FrameEvent::DEQUEUE_READY,
-        FrameEvent::RELEASE,
-    };
-status_t SurfaceFlinger::getSupportedFrameTimestamps(
-        std::vector<FrameEvent>* outSupported) const {
-    *outSupported = {
-        FrameEvent::REQUESTED_PRESENT,
-        FrameEvent::ACQUIRE,
-        FrameEvent::LATCH,
-        FrameEvent::FIRST_REFRESH_START,
-        FrameEvent::LAST_REFRESH_START,
-        FrameEvent::GPU_COMPOSITION_DONE,
-        FrameEvent::DEQUEUE_READY,
-        FrameEvent::RELEASE,
-    };
-status_t SurfaceFlinger::getSupportedFrameTimestamps(
-        std::vector<FrameEvent>* outSupported) const {
-    *outSupported = {
-        FrameEvent::REQUESTED_PRESENT,
-        FrameEvent::ACQUIRE,
-        FrameEvent::LATCH,
-        FrameEvent::FIRST_REFRESH_START,
-        FrameEvent::LAST_REFRESH_START,
-        FrameEvent::GPU_COMPOSITION_DONE,
-        FrameEvent::DEQUEUE_READY,
-        FrameEvent::RELEASE,
-    };
-status_t SurfaceFlinger::getSupportedFrameTimestamps(
-        std::vector<FrameEvent>* outSupported) const {
-    *outSupported = {
-        FrameEvent::REQUESTED_PRESENT,
-        FrameEvent::ACQUIRE,
-        FrameEvent::LATCH,
-        FrameEvent::FIRST_REFRESH_START,
-        FrameEvent::LAST_REFRESH_START,
-        FrameEvent::GPU_COMPOSITION_DONE,
-        FrameEvent::DEQUEUE_READY,
-        FrameEvent::RELEASE,
-    };
-status_t SurfaceFlinger::getSupportedFrameTimestamps(
-        std::vector<FrameEvent>* outSupported) const {
-    *outSupported = {
-        FrameEvent::REQUESTED_PRESENT,
-        FrameEvent::ACQUIRE,
-        FrameEvent::LATCH,
-        FrameEvent::FIRST_REFRESH_START,
-        FrameEvent::LAST_REFRESH_START,
-        FrameEvent::GPU_COMPOSITION_DONE,
-        FrameEvent::DEQUEUE_READY,
-        FrameEvent::RELEASE,
-    };
-status_t SurfaceFlinger::getSupportedFrameTimestamps(
-        std::vector<FrameEvent>* outSupported) const {
-    *outSupported = {
-        FrameEvent::REQUESTED_PRESENT,
-        FrameEvent::ACQUIRE,
-        FrameEvent::LATCH,
-        FrameEvent::FIRST_REFRESH_START,
-        FrameEvent::LAST_REFRESH_START,
-        FrameEvent::GPU_COMPOSITION_DONE,
-        FrameEvent::DEQUEUE_READY,
-        FrameEvent::RELEASE,
-    };
-status_t SurfaceFlinger::getSupportedFrameTimestamps(
-        std::vector<FrameEvent>* outSupported) const {
-    *outSupported = {
-        FrameEvent::REQUESTED_PRESENT,
-        FrameEvent::ACQUIRE,
-        FrameEvent::LATCH,
-        FrameEvent::FIRST_REFRESH_START,
-        FrameEvent::LAST_REFRESH_START,
-        FrameEvent::GPU_COMPOSITION_DONE,
-        FrameEvent::DEQUEUE_READY,
-        FrameEvent::RELEASE,
-    };
-status_t SurfaceFlinger::getSupportedFrameTimestamps(
-        std::vector<FrameEvent>* outSupported) const {
-    *outSupported = {
-        FrameEvent::REQUESTED_PRESENT,
-        FrameEvent::ACQUIRE,
-        FrameEvent::LATCH,
-        FrameEvent::FIRST_REFRESH_START,
-        FrameEvent::LAST_REFRESH_START,
-        FrameEvent::GPU_COMPOSITION_DONE,
-        FrameEvent::DEQUEUE_READY,
-        FrameEvent::RELEASE,
-    };
+int64_t SurfaceFlinger::dispSyncPresentTimeOffset;
+bool SurfaceFlinger::useHwcForRgbToYuv;
+uint64_t SurfaceFlinger::maxVirtualDisplaySize;
+bool SurfaceFlinger::hasSyncFramework;
+bool SurfaceFlinger::useVrFlinger;
+int64_t SurfaceFlinger::maxFrameBufferAcquiredBuffers;
+bool SurfaceFlinger::hasWideColorDisplay;
+int SurfaceFlinger::primaryDisplayOrientation = DisplayState::eOrientationDefault;
+bool SurfaceFlinger::useColorManagement;
+bool SurfaceFlinger::useContextPriority;
+Dataspace SurfaceFlinger::defaultCompositionDataspace = Dataspace::V0_SRGB;
+ui::PixelFormat SurfaceFlinger::defaultCompositionPixelFormat = ui::PixelFormat::RGBA_8888;
+Dataspace SurfaceFlinger::wideColorGamutCompositionDataspace = Dataspace::V0_SRGB;
+ui::PixelFormat SurfaceFlinger::wideColorGamutCompositionPixelFormat = ui::PixelFormat::RGBA_8888;
@@ -365,2 +213,0 @@ SurfaceFlinger::SurfaceFlinger(Factory& factory) : SurfaceFlinger(factory, SkipI
-    ALOGI("SurfaceFlinger is starting");
-    hasSyncFramework {
@@ -448 +295 @@ void SurfaceFlinger::onFirstRef()
-SurfaceFlinger::~SurfaceFlinger()
+SurfaceFlinger::~SurfaceFlinger() = default;
@@ -750,2 +597,7 @@ status_t SurfaceFlinger::getSupportedFrameTimestamps(
-private:
-    const int mApi;
+    ConditionalLock _l(mStateLock,
+            std::this_thread::get_id() != mMainThreadId);
+    if (!getHwComposer().hasCapability(
+            HWC2::Capability::PresentFenceIsNotReliable)) {
+        outSupported->push_back(FrameEvent::DISPLAY_PRESENT);
+    }
+    return NO_ERROR;
@@ -1135,4 +987,9 @@ status_t SurfaceFlinger::getLayerDebugInfo(std::vector<LayerDebugInfo>* outLayer
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+status_t SurfaceFlinger::getCompositionPreference(
+        Dataspace* outDataspace, ui::PixelFormat* outPixelFormat,
+        Dataspace* outWideColorGamutDataspace,
+        ui::PixelFormat* outWideColorGamutPixelFormat) const {
+    *outDataspace = mDefaultCompositionDataspace;
+    *outPixelFormat = defaultCompositionPixelFormat;
+    *outWideColorGamutDataspace = mWideColorGamutCompositionDataspace;
+    *outWideColorGamutPixelFormat = wideColorGamutCompositionPixelFormat;
+    return NO_ERROR;
@@ -1139,0 +997,5 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+status_t SurfaceFlinger::addRegionSamplingListener(const Rect& samplingArea,
+                                                   const sp<IBinder>& stopLayerHandle,
+                                                   const sp<IRegionSamplingListener>& listener) {
+    if (!listener || samplingArea == Rect::INVALID_RECT) {
+        return BAD_VALUE;
@@ -1141,4 +1003,2 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+    mRegionSamplingThread->addListener(samplingArea, stopLayerHandle, listener);
+    return NO_ERROR;
@@ -1145,0 +1006,3 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+status_t SurfaceFlinger::removeRegionSamplingListener(const sp<IRegionSamplingListener>& listener) {
+    if (!listener) {
+        return BAD_VALUE;
@@ -1147,4 +1010,2 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+    mRegionSamplingThread->removeListener(listener);
+    return NO_ERROR;
@@ -1151,0 +1013,4 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+status_t SurfaceFlinger::getDisplayBrightnessSupport(const sp<IBinder>& displayToken,
+                                                     bool* outSupport) const {
+    if (!displayToken || !outSupport) {
+        return BAD_VALUE;
@@ -1153,4 +1018,3 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+    const auto displayId = getPhysicalDisplayIdLocked(displayToken);
+    if (!displayId) {
+        return NAME_NOT_FOUND;
@@ -1157,0 +1022,3 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+    *outSupport =
+            getHwComposer().hasDisplayCapability(displayId, HWC2::DisplayCapability::Brightness);
+    return NO_ERROR;
@@ -1159,4 +1026,4 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+status_t SurfaceFlinger::setDisplayBrightness(const sp<IBinder>& displayToken,
+                                              float brightness) const {
+    if (!displayToken) {
+        return BAD_VALUE;
@@ -1163,0 +1031,3 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+    const auto displayId = getPhysicalDisplayIdLocked(displayToken);
+    if (!displayId) {
+        return NAME_NOT_FOUND;
@@ -1165,4 +1035 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+    return getHwComposer().setDisplayBrightness(*displayId, brightness);
@@ -1169,0 +1037,4 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+status_t SurfaceFlinger::notifyPowerHint(int32_t hintId) {
+    PowerHint powerHint = static_cast<PowerHint>(hintId);
+    if (powerHint == PowerHint::INTERACTION) {
+        mScheduler->notifyTouchEvent();
@@ -1171,4 +1042 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+    return NO_ERROR;
@@ -1175,0 +1044,10 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+sp<IDisplayEventConnection> SurfaceFlinger::createDisplayEventConnection(
+        ISurfaceComposer::VsyncSource vsyncSource, ISurfaceComposer::ConfigChanged configChanged) {
+    auto resyncCallback = mScheduler->makeResyncCallback([this] {
+        Mutex::Autolock lock(mStateLock);
+        return getVsyncPeriod();
+    });
+    const auto& handle =
+            vsyncSource == eVsyncSourceSurfaceFlinger ? mSfConnectionHandle : mAppConnectionHandle;
+    return mScheduler->createDisplayEventConnection(handle, std::move(resyncCallback),
+                                                    configChanged);
@@ -1177,4 +1055,2 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+void SurfaceFlinger::waitForEvent() {
+    mEventQueue->waitMessage();
@@ -1181,0 +1058,3 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+void SurfaceFlinger::signalTransaction() {
+    mScheduler->resetIdleTimer();
+    mEventQueue->invalidate();
@@ -1183,4 +1062,3 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+void SurfaceFlinger::signalLayerUpdate() {
+    mScheduler->resetIdleTimer();
+    mEventQueue->invalidate();
@@ -1187,0 +1066,3 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+void SurfaceFlinger::signalRefresh() {
+    mRefreshPending = true;
+    mEventQueue->refresh();
@@ -1189,4 +1070,3 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+status_t SurfaceFlinger::postMessageAsync(const sp<MessageBase>& msg,
+        nsecs_t reltime, uint32_t ) {
+    return mEventQueue->postMessage(msg, reltime);
@@ -1193,0 +1074,5 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+status_t SurfaceFlinger::postMessageSync(const sp<MessageBase>& msg,
+        nsecs_t reltime, uint32_t ) {
+    status_t res = mEventQueue->postMessage(msg, reltime);
+    if (res == NO_ERROR) {
+        msg->wait();
@@ -1195,4 +1080 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+    return res;
@@ -1199,0 +1082,4 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+void SurfaceFlinger::run() {
+    do {
+        waitForEvent();
+    } while (true);
@@ -1201,4 +1087,4 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+nsecs_t SurfaceFlinger::getVsyncPeriod() const {
+    const auto displayId = getInternalDisplayIdLocked();
+    if (!displayId || !getHwComposer().isConnected(*displayId)) {
+        return 0;
@@ -1205,0 +1092,2 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+    const auto config = getHwComposer().getActiveConfig(*displayId);
+    return config ? config->getVsyncPeriod() : 0;
@@ -1207,4 +1095,6 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+void SurfaceFlinger::onVsyncReceived(int32_t sequenceId, hwc2_display_t hwcDisplayId,
+                                     int64_t timestamp) {
+    ATRACE_NAME("SF onVsync");
+    Mutex::Autolock lock(mStateLock);
+    if (sequenceId != getBE().mComposerSequenceId) {
+        return;
@@ -1211,0 +1102,2 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+    if (!getHwComposer().onVsync(hwcDisplayId, timestamp)) {
+        return;
@@ -1213,4 +1105,2 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+    if (hwcDisplayId != getHwComposer().getInternalHwcDisplayId()) {
+        return;
@@ -1217,0 +1108,4 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+    bool periodFlushed = false;
+    mScheduler->addResyncSample(timestamp, &periodFlushed);
+    if (periodFlushed) {
+        mVSyncModulator->onRefreshRateChangeCompleted();
@@ -1219,4 +1112,0 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
@@ -1223,0 +1114,3 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+void SurfaceFlinger::getCompositorTiming(CompositorTiming* compositorTiming) {
+    std::lock_guard<std::mutex> lock(getBE().mCompositorTimingLock);
+    *compositorTiming = getBE().mCompositorTiming;
@@ -1225,4 +1118,2 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+bool SurfaceFlinger::isDisplayConfigAllowed(int32_t configId) const {
+    return mAllowedDisplayConfigs.empty() || mAllowedDisplayConfigs.count(configId);
@@ -1229,0 +1121,4 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+void SurfaceFlinger::setRefreshRateTo(RefreshRateType refreshRate, Scheduler::ConfigEvent event) {
+    const auto display = getDefaultDisplayDeviceLocked();
+    if (!display || mBootStage != BootStage::FINISHED) {
+        return;
@@ -1231,4 +1126,5 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+    ATRACE_CALL();
+    const auto& refreshRateConfig = mRefreshRateConfigs.getRefreshRate(refreshRate);
+    if (!refreshRateConfig) {
+        ALOGV("Skipping refresh rate change request for unsupported rate.");
+        return;
@@ -1235,0 +1132,4 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+    const int desiredConfigId = refreshRateConfig->configId;
+    if (!isDisplayConfigAllowed(desiredConfigId)) {
+        ALOGV("Skipping config %d as it is not part of allowed configs", desiredConfigId);
+        return;
@@ -1237,4 +1137 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+    setDesiredActiveConfig({refreshRate, desiredConfigId, event});
@@ -1241,0 +1139,6 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+void SurfaceFlinger::onHotplugReceived(int32_t sequenceId, hwc2_display_t hwcDisplayId,
+                                       HWC2::Connection connection) {
+    ALOGV("%s(%d, %" PRIu64 ", %s)", __FUNCTION__, sequenceId, hwcDisplayId,
+          connection == HWC2::Connection::Connected ? "connected" : "disconnected");
+    if (sequenceId != getBE().mComposerSequenceId) {
+        return;
@@ -1243,4 +1146,4 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+    ConditionalLock lock(mStateLock, std::this_thread::get_id() != mMainThreadId);
+    mPendingHotplugEvents.emplace_back(HotplugEvent{hwcDisplayId, connection});
+    if (std::this_thread::get_id() == mMainThreadId) {
+        processDisplayHotplugEventsLocked();
@@ -1247,0 +1151 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+    setTransactionFlags(eDisplayTransactionNeeded);
@@ -1249,4 +1153,4 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+void SurfaceFlinger::onRefreshReceived(int sequenceId, hwc2_display_t ) {
+    Mutex::Autolock lock(mStateLock);
+    if (sequenceId != getBE().mComposerSequenceId) {
+        return;
@@ -1253,0 +1158 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+    repaintEverythingForHWC();
@@ -1255,4 +1160,4 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+void SurfaceFlinger::setPrimaryVsyncEnabled(bool enabled) {
+    ATRACE_CALL();
+    postMessageAsync(new LambdaMessage(
+            [=]() NO_THREAD_SAFETY_ANALYSIS { setPrimaryVsyncEnabledInternal(enabled); }));
@@ -1259,0 +1165,7 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+void SurfaceFlinger::setPrimaryVsyncEnabledInternal(bool enabled) {
+    ATRACE_CALL();
+    mHWCVsyncPendingState = enabled ? HWC2::Vsync::Enable : HWC2::Vsync::Disable;
+    if (const auto displayId = getInternalDisplayIdLocked()) {
+        sp<DisplayDevice> display = getDefaultDisplayDeviceLocked();
+        if (display && display->isPoweredOn()) {
+            setVsyncEnabledInHWC(*displayId, mHWCVsyncPendingState);
@@ -1261,4 +1172,0 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
@@ -1267,4 +1175,4 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+void SurfaceFlinger::resetDisplayState() {
+    mScheduler->disableHardwareVsync(true);
+    mDrawingState.displays.clear();
+    mDisplays.clear();
@@ -1271,0 +1180,7 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+void SurfaceFlinger::updateVrFlinger() {
+    ATRACE_CALL();
+    if (!mVrFlinger)
+        return;
+    bool vrFlingerRequestsDisplay = mVrFlingerRequestsDisplay;
+    if (vrFlingerRequestsDisplay == getHwComposer().isUsingVrComposer()) {
+        return;
@@ -1273,4 +1188,6 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+    if (vrFlingerRequestsDisplay && !getHwComposer().getComposer()->isRemote()) {
+        ALOGE("Vr flinger is only supported for remote hardware composer"
+              " service connections. Ignoring request to transition to vr"
+              " flinger.");
+        mVrFlingerRequestsDisplay = false;
+        return;
@@ -1277,0 +1195,35 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+    Mutex::Autolock _l(mStateLock);
+    sp<DisplayDevice> display = getDefaultDisplayDeviceLocked();
+    LOG_ALWAYS_FATAL_IF(!display);
+    const int currentDisplayPowerMode = display->getPowerMode();
+    for (const auto& [token, displayDevice] : mDisplays) {
+        displayDevice->getCompositionDisplay()->setOutputLayersOrderedByZ(
+                compositionengine::Output::OutputLayers());
+    }
+    display.clear();
+    if (!vrFlingerRequestsDisplay) {
+        mVrFlinger->SeizeDisplayOwnership();
+    }
+    resetDisplayState();
+    mCompositionEngine->setHwComposer(std::unique_ptr<HWComposer>());
+    mCompositionEngine->setHwComposer(getFactory().createHWComposer(
+            vrFlingerRequestsDisplay ? "vr" : getBE().mHwcServiceName));
+    getHwComposer().registerCallback(this, ++getBE().mComposerSequenceId);
+    LOG_ALWAYS_FATAL_IF(!getHwComposer().getComposer()->isRemote(),
+                        "Switched to non-remote hardware composer");
+    if (vrFlingerRequestsDisplay) {
+        mVrFlinger->GrantDisplayOwnership();
+    }
+    mVisibleRegionsDirty = true;
+    invalidateHwcGeometry();
+    display = getDefaultDisplayDeviceLocked();
+    LOG_ALWAYS_FATAL_IF(!display);
+    setPowerModeInternal(display, currentDisplayPowerMode);
+    const nsecs_t vsyncPeriod = getVsyncPeriod();
+    mAnimFrameTracker.setDisplayRefreshPeriod(vsyncPeriod);
+    mScheduler->setIgnorePresentFences(getHwComposer().isUsingVrComposer() || !hasSyncFramework);
+    DisplayStatInfo stats{0 , vsyncPeriod};
+    setCompositorTimingSnapped(stats, 0);
+    mScheduler->resyncToHardwareVsync(false, vsyncPeriod);
+    mRepaintEverything = true;
+    setTransactionFlags(eDisplayTransactionNeeded);
@@ -1279,4 +1231,41 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+bool SurfaceFlinger::previousFrameMissed() NO_THREAD_SAFETY_ANALYSIS {
+    const sp<Fence>& fence =
+            mVSyncModulator->getOffsets().sf < mPhaseOffsets->getOffsetThresholdForNextVsync()
+            ? mPreviousPresentFences[0]
+            : mPreviousPresentFences[1];
+    return fence != Fence::NO_FENCE && (fence->getStatus() == Fence::Status::Unsignaled);
+}
+void SurfaceFlinger::populateExpectedPresentTime() {
+    DisplayStatInfo stats;
+    mScheduler->getDisplayStatInfo(&stats);
+    const nsecs_t presentTime = mScheduler->getDispSyncExpectedPresentTime();
+    mExpectedPresentTime.store(mVSyncModulator->getOffsets().sf <
+                                               mPhaseOffsets->getOffsetThresholdForNextVsync()
+                                       ? presentTime
+                                       : presentTime + stats.vsyncPeriod);
+}
+void SurfaceFlinger::onMessageReceived(int32_t what) NO_THREAD_SAFETY_ANALYSIS {
+    ATRACE_CALL();
+    switch (what) {
+        case MessageQueue::INVALIDATE: {
+            populateExpectedPresentTime();
+            const TracedOrdinal<bool> frameMissed = {"FrameMissed", previousFrameMissed()};
+            const TracedOrdinal<bool> hwcFrameMissed = {"HwcFrameMissed",
+                                                        mHadDeviceComposition && frameMissed};
+            const TracedOrdinal<bool> gpuFrameMissed = {"GpuFrameMissed",
+                                                        mHadClientComposition && frameMissed};
+            if (frameMissed) {
+                mFrameMissedCount++;
+                mTimeStats->incrementMissedFrames();
+            }
+            if (hwcFrameMissed) {
+                mHwcFrameMissedCount++;
+            }
+            if (gpuFrameMissed) {
+                mGpuFrameMissedCount++;
+            }
+            if (mUseSmart90ForVideo) {
+                mScheduler->updateFpsBasedOnContent();
+            }
+            if (performSetActiveConfig()) {
+                break;
@@ -1283,0 +1273,5 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+            if (frameMissed && mPropagateBackpressure) {
+                if ((hwcFrameMissed && !gpuFrameMissed) ||
+                    mPropagateBackpressureClientComposition) {
+                    signalLayerUpdate();
+                    break;
@@ -1285,4 +1278,0 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
@@ -1289,0 +1280,8 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+            updateVrFlinger();
+            bool refreshNeeded = handleMessageTransaction();
+            refreshNeeded |= handleMessageInvalidate();
+            updateCursorAsync();
+            updateInputFlinger();
+            refreshNeeded |= mRepaintEverything;
+            if (refreshNeeded && CC_LIKELY(mBootStage != BootStage::BOOTLOADER)) {
+                signalRefresh();
@@ -1291,4 +1289 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+            break;
@@ -1295,0 +1291,3 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+        case MessageQueue::REFRESH: {
+            handleMessageRefresh();
+            break;
@@ -1297,4 +1294,0 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
@@ -1303,4 +1297,10 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+bool SurfaceFlinger::handleMessageTransaction() {
+    ATRACE_CALL();
+    uint32_t transactionFlags = peekTransactionFlags();
+    bool flushedATransaction = flushTransactionQueues();
+    bool runHandleTransaction = transactionFlags &&
+            ((transactionFlags != eTransactionFlushNeeded) || flushedATransaction);
+    if (runHandleTransaction) {
+        handleTransaction(eTransactionMask);
+    } else {
+        getTransactionFlags(eTransactionFlushNeeded);
@@ -1307,0 +1308,2 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+    if (transactionFlushNeeded()) {
+        setTransactionFlags(eTransactionFlushNeeded);
@@ -1309,4 +1311 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+    return runHandleTransaction;
@@ -1313,0 +1313,50 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+void SurfaceFlinger::handleMessageRefresh() {
+    ATRACE_CALL();
+    mRefreshPending = false;
+    compositionengine::CompositionRefreshArgs refreshArgs;
+    for (const auto& [_, display] : mDisplays) {
+        refreshArgs.outputs.push_back(display->getCompositionDisplay());
+    }
+    mDrawingState.traverseInZOrder([&refreshArgs](Layer* layer) {
+        auto compositionLayer = layer->getCompositionLayer();
+        if (compositionLayer) refreshArgs.layers.push_back(compositionLayer);
+    });
+    refreshArgs.repaintEverything = mRepaintEverything.exchange(false);
+    refreshArgs.outputColorSetting = useColorManagement
+            ? mDisplayColorSetting
+            : compositionengine::OutputColorSetting::kUnmanaged;
+    refreshArgs.colorSpaceAgnosticDataspace = mColorSpaceAgnosticDataspace;
+    refreshArgs.forceOutputColorMode = mForceColorMode;
+    refreshArgs.updatingGeometryThisFrame = mGeometryInvalid;
+    if (CC_UNLIKELY(mDrawingState.colorMatrixChanged)) {
+        refreshArgs.colorTransformMatrix = mDrawingState.colorMatrix;
+        mDrawingState.colorMatrixChanged = false;
+    }
+    refreshArgs.devOptForceClientComposition = mDebugDisableHWC || mDebugRegion;
+    if (mDebugRegion != 0) {
+        refreshArgs.devOptFlashDirtyRegionsDelay =
+                std::chrono::milliseconds(mDebugRegion > 1 ? mDebugRegion : 0);
+    }
+    mCompositionEngine->preComposition(refreshArgs);
+    rebuildLayerStacks();
+    refreshArgs.updatingGeometryThisFrame = mGeometryInvalid;
+    mCompositionEngine->present(refreshArgs);
+    mGeometryInvalid = false;
+    postFrame();
+    postComposition();
+    mHadClientComposition =
+            std::any_of(mDisplays.cbegin(), mDisplays.cend(), [](const auto& tokenDisplayPair) {
+                auto& displayDevice = tokenDisplayPair.second;
+                return displayDevice->getCompositionDisplay()->getState().usesClientComposition;
+            });
+    mHadDeviceComposition =
+            std::any_of(mDisplays.cbegin(), mDisplays.cend(), [](const auto& tokenDisplayPair) {
+                auto& displayDevice = tokenDisplayPair.second;
+                return displayDevice->getCompositionDisplay()->getState().usesDeviceComposition;
+            });
+    mVSyncModulator->onRefreshed(mHadClientComposition);
+    mLayersWithQueuedFrames.clear();
+    if (mVisibleRegionsDirty) {
+        mVisibleRegionsDirty = false;
+        if (mTracingEnabled) {
+            mTracing.notify("visibleRegionsDirty");
@@ -1315,4 +1363,0 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
@@ -1319,0 +1365,2 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+    if (mCompositionEngine->needsAnotherUpdate()) {
+        signalLayerUpdate();
@@ -1321,4 +1367,0 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
@@ -1325,0 +1369,23 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+bool SurfaceFlinger::handleMessageInvalidate() {
+    ATRACE_CALL();
+    bool refreshNeeded = handlePageFlip();
+    if (mVisibleRegionsDirty) {
+        computeLayerBounds();
+    }
+    for (auto& layer : mLayersPendingRefresh) {
+        Region visibleReg;
+        visibleReg.set(layer->getScreenBounds());
+        invalidateLayerStack(layer, visibleReg);
+    }
+    mLayersPendingRefresh.clear();
+    return refreshNeeded;
+}
+void SurfaceFlinger::updateCompositorTiming(const DisplayStatInfo& stats, nsecs_t compositeTime,
+                                            std::shared_ptr<FenceTime>& presentFenceTime) {
+    getBE().mCompositePresentTimes.push({compositeTime, presentFenceTime});
+    nsecs_t compositeToPresentLatency = -1;
+    while (!getBE().mCompositePresentTimes.empty()) {
+        SurfaceFlingerBE::CompositePresentTime& cpt = getBE().mCompositePresentTimes.front();
+        nsecs_t displayTime = cpt.display->getCachedSignalTime();
+        if (displayTime == Fence::SIGNAL_TIME_PENDING) {
+            break;
@@ -1327,4 +1393,2 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+        compositeToPresentLatency = displayTime - cpt.composite;
+        getBE().mCompositePresentTimes.pop();
@@ -1331,0 +1396,2 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+    while (getBE().mCompositePresentTimes.size() > 16) {
+        getBE().mCompositePresentTimes.pop();
@@ -1333,4 +1399 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+    setCompositorTimingSnapped(stats, compositeToPresentLatency);
@@ -1337,0 +1401,7 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+void SurfaceFlinger::setCompositorTimingSnapped(const DisplayStatInfo& stats,
+                                                nsecs_t compositeToPresentLatency) {
+    nsecs_t idealLatency = (mPhaseOffsets->getCurrentSfOffset() > 0)
+            ? (stats.vsyncPeriod - (mPhaseOffsets->getCurrentSfOffset() % stats.vsyncPeriod))
+            : ((-mPhaseOffsets->getCurrentSfOffset()) % stats.vsyncPeriod);
+    if (idealLatency <= 0) {
+        idealLatency = stats.vsyncPeriod;
@@ -1339,4 +1409,8 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+    nsecs_t bias = stats.vsyncPeriod / 2;
+    int64_t extraVsyncs = (compositeToPresentLatency - idealLatency + bias) / stats.vsyncPeriod;
+    nsecs_t snappedCompositeToPresentLatency =
+            (extraVsyncs > 0) ? idealLatency + (extraVsyncs * stats.vsyncPeriod) : idealLatency;
+    std::lock_guard<std::mutex> lock(getBE().mCompositorTimingLock);
+    getBE().mCompositorTiming.deadline = stats.vsyncTime - idealLatency;
+    getBE().mCompositorTiming.interval = stats.vsyncPeriod;
+    getBE().mCompositorTiming.presentLatency = snappedCompositeToPresentLatency;
@@ -1343,0 +1418,35 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+void SurfaceFlinger::postComposition()
+{
+    ATRACE_CALL();
+    ALOGV("postComposition");
+    nsecs_t dequeueReadyTime = systemTime();
+    for (auto& layer : mLayersWithQueuedFrames) {
+        layer->releasePendingBuffer(dequeueReadyTime);
+    }
+    const auto displayDevice = getDefaultDisplayDeviceLocked();
+    getBE().mGlCompositionDoneTimeline.updateSignalTimes();
+    std::shared_ptr<FenceTime> glCompositionDoneFenceTime;
+    if (displayDevice && displayDevice->getCompositionDisplay()->getState().usesClientComposition) {
+        glCompositionDoneFenceTime =
+                std::make_shared<FenceTime>(displayDevice->getCompositionDisplay()
+                                                    ->getRenderSurface()
+                                                    ->getClientTargetAcquireFence());
+        getBE().mGlCompositionDoneTimeline.push(glCompositionDoneFenceTime);
+    } else {
+        glCompositionDoneFenceTime = FenceTime::NO_FENCE;
+    }
+    getBE().mDisplayTimeline.updateSignalTimes();
+    mPreviousPresentFences[1] = mPreviousPresentFences[0];
+    mPreviousPresentFences[0] = displayDevice
+            ? getHwComposer().getPresentFence(*displayDevice->getId())
+            : Fence::NO_FENCE;
+    auto presentFenceTime = std::make_shared<FenceTime>(mPreviousPresentFences[0]);
+    getBE().mDisplayTimeline.push(presentFenceTime);
+    DisplayStatInfo stats;
+    mScheduler->getDisplayStatInfo(&stats);
+    updateCompositorTiming(stats, mCompositionEngine->getLastFrameRefreshTimestamp(),
+                           presentFenceTime);
+    CompositorTiming compositorTiming;
+    {
+        std::lock_guard<std::mutex> lock(getBE().mCompositorTimingLock);
+        compositorTiming = getBE().mCompositorTiming;
@@ -1345,4 +1454,7 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+    mDrawingState.traverseInZOrder([&](Layer* layer) {
+        bool frameLatched =
+                layer->onPostComposition(displayDevice->getId(), glCompositionDoneFenceTime,
+                                         presentFenceTime, compositorTiming);
+        if (frameLatched) {
+            recordBufferingStats(layer->getName().string(),
+                    layer->getOccupancyHistory(false));
@@ -1349,0 +1462,30 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+    });
+    if (presentFenceTime->isValid()) {
+        mScheduler->addPresentFence(presentFenceTime);
+    }
+    if (!hasSyncFramework) {
+        if (displayDevice && getHwComposer().isConnected(*displayDevice->getId()) &&
+            displayDevice->isPoweredOn()) {
+            mScheduler->enableHardwareVsync();
+        }
+    }
+    if (mAnimCompositionPending) {
+        mAnimCompositionPending = false;
+        if (presentFenceTime->isValid()) {
+            mAnimFrameTracker.setActualPresentFence(
+                    std::move(presentFenceTime));
+        } else if (displayDevice && getHwComposer().isConnected(*displayDevice->getId())) {
+            const nsecs_t presentTime =
+                    getHwComposer().getRefreshTimestamp(*displayDevice->getId());
+            mAnimFrameTracker.setActualPresentTime(presentTime);
+        }
+        mAnimFrameTracker.advanceFrame();
+    }
+    mTimeStats->incrementTotalFrames();
+    if (mHadClientComposition) {
+        mTimeStats->incrementClientCompositionFrames();
+    }
+    mTimeStats->setPresentFenceGlobal(presentFenceTime);
+    if (displayDevice && getHwComposer().isConnected(*displayDevice->getId()) &&
+        !displayDevice->isPoweredOn()) {
+        return;
@@ -1351,4 +1493,10 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+    nsecs_t currentTime = systemTime();
+    if (mHasPoweredOff) {
+        mHasPoweredOff = false;
+    } else {
+        nsecs_t elapsedTime = currentTime - getBE().mLastSwapTime;
+        size_t numPeriods = static_cast<size_t>(elapsedTime / stats.vsyncPeriod);
+        if (numPeriods < SurfaceFlingerBE::NUM_BUCKETS - 1) {
+            getBE().mFrameBuckets[numPeriods] += elapsedTime;
+        } else {
+            getBE().mFrameBuckets[SurfaceFlingerBE::NUM_BUCKETS - 1] += elapsedTime;
@@ -1355,0 +1504 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+        getBE().mTotalTime += elapsedTime;
@@ -1357,4 +1506,15 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+    getBE().mLastSwapTime = currentTime;
+    {
+        std::lock_guard lock(mTexturePoolMutex);
+        if (mTexturePool.size() < mTexturePoolSize) {
+            const size_t refillCount = mTexturePoolSize - mTexturePool.size();
+            const size_t offset = mTexturePool.size();
+            mTexturePool.resize(mTexturePoolSize);
+            getRenderEngine().genTextures(refillCount, mTexturePool.data() + offset);
+            ATRACE_INT("TexturePoolSize", mTexturePool.size());
+        } else if (mTexturePool.size() > mTexturePoolSize) {
+            const size_t deleteCount = mTexturePool.size() - mTexturePoolSize;
+            const size_t offset = mTexturePoolSize;
+            getRenderEngine().deleteTextures(deleteCount, mTexturePool.data() + offset);
+            mTexturePool.resize(mTexturePoolSize);
+            ATRACE_INT("TexturePoolSize", mTexturePool.size());
@@ -1363,4 +1523,4 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+    mTransactionCompletedThread.addPresentFence(mPreviousPresentFences[0]);
+    mTransactionCompletedThread.sendCallbacks();
+    if (mLumaSampling && mRegionSamplingThread) {
+        mRegionSamplingThread->notifyNewContent();
@@ -1367,0 +1528,2 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+    if (ATRACE_ENABLED()) {
+        ATRACE_INT64("Total Buffer Size", GraphicBufferAllocator::get().getTotalSize());
@@ -1369,4 +1530,0 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
@@ -1373,0 +1532,7 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+void SurfaceFlinger::computeLayerBounds() {
+    for (const auto& pair : mDisplays) {
+        const auto& displayDevice = pair.second;
+        const auto display = displayDevice->getCompositionDisplay();
+        for (const auto& layer : mDrawingState.layersSortedByZ) {
+            if (!display->belongsInOutput(layer->getLayerStack(), layer->getPrimaryDisplayOnly())) {
+                continue;
@@ -1375,4 +1540 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+            layer->computeBounds(displayDevice->getViewport().toFloatRect(), ui::Transform());
@@ -1381,4 +1542,0 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
@@ -1385,0 +1544,23 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+void SurfaceFlinger::rebuildLayerStacks() {
+    ATRACE_CALL();
+    ALOGV("rebuildLayerStacks");
+    if (CC_UNLIKELY(mVisibleRegionsDirty)) {
+        ATRACE_NAME("rebuildLayerStacks VR Dirty");
+        invalidateHwcGeometry();
+        for (const auto& pair : mDisplays) {
+            const auto& displayDevice = pair.second;
+            auto display = displayDevice->getCompositionDisplay();
+            const auto& displayState = display->getState();
+            Region opaqueRegion;
+            Region dirtyRegion;
+            compositionengine::Output::OutputLayers layersSortedByZ;
+            compositionengine::Output::ReleasedLayers releasedLayers;
+            Vector<sp<Layer>> deprecated_layersSortedByZ;
+            const ui::Transform& tr = displayState.transform;
+            const Rect bounds = displayState.bounds;
+            if (displayState.isEnabled) {
+                computeVisibleRegions(displayDevice, dirtyRegion, opaqueRegion);
+                mDrawingState.traverseInZOrder([&](Layer* layer) {
+                    auto compositionLayer = layer->getCompositionLayer();
+                    if (compositionLayer == nullptr) {
+                        return;
@@ -1387,4 +1568,29 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+                    const auto displayId = displayDevice->getId();
+                    sp<compositionengine::LayerFE> layerFE = compositionLayer->getLayerFE();
+                    LOG_ALWAYS_FATAL_IF(layerFE.get() == nullptr);
+                    bool needsOutputLayer = false;
+                    if (display->belongsInOutput(layer->getLayerStack(),
+                                                 layer->getPrimaryDisplayOnly())) {
+                        Region drawRegion(tr.transform(
+                                layer->visibleNonTransparentRegion));
+                        drawRegion.andSelf(bounds);
+                        if (!drawRegion.isEmpty()) {
+                            needsOutputLayer = true;
+                        }
+                    }
+                    if (needsOutputLayer) {
+                        layersSortedByZ.emplace_back(
+                                display->getOrCreateOutputLayer(displayId, compositionLayer,
+                                                                layerFE));
+                        deprecated_layersSortedByZ.add(layer);
+                        auto& outputLayerState = layersSortedByZ.back()->editState();
+                        outputLayerState.visibleRegion =
+                                tr.transform(layer->visibleRegion.intersect(displayState.viewport));
+                    } else if (displayId) {
+                        bool hasExistingOutputLayer =
+                                display->getOutputLayerForLayer(compositionLayer.get()) != nullptr;
+                        bool hasQueuedFrames = std::find(mLayersWithQueuedFrames.cbegin(),
+                                                         mLayersWithQueuedFrames.cend(),
+                                                         layer) != mLayersWithQueuedFrames.cend();
+                        if (hasExistingOutputLayer && hasQueuedFrames) {
+                            releasedLayers.push_back(layer);
@@ -1393,4 +1599 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+                });
@@ -1397,0 +1601,7 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+            display->setOutputLayersOrderedByZ(std::move(layersSortedByZ));
+            display->setReleasedLayers(std::move(releasedLayers));
+            displayDevice->setVisibleLayersSortedByZ(deprecated_layersSortedByZ);
+            Region undefinedRegion{bounds};
+            undefinedRegion.subtractSelf(tr.transform(opaqueRegion));
+            display->editState().undefinedRegion = undefinedRegion;
+            display->editState().dirtyRegion.orSelf(dirtyRegion);
@@ -1399,4 +1608,0 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
@@ -1405,4 +1611,7 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+void SurfaceFlinger::postFrame()
+{
+    const auto display = getDefaultDisplayDeviceLocked();
+    if (display && getHwComposer().isConnected(*display->getId())) {
+        uint32_t flipCount = display->getPageFlipCount();
+        if (flipCount % LOG_FRAME_STATS_PERIOD == 0) {
+            logFrameStats();
@@ -1411,4 +1619,0 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
@@ -1415,0 +1621,18 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+void SurfaceFlinger::handleTransaction(uint32_t transactionFlags)
+{
+    ATRACE_CALL();
+    State drawingState(mDrawingState);
+    Mutex::Autolock _l(mStateLock);
+    mDebugInTransaction = systemTime();
+    mVSyncModulator->onTransactionHandled();
+    transactionFlags = getTransactionFlags(eTransactionMask);
+    handleTransactionLocked(transactionFlags);
+    mDebugInTransaction = 0;
+    invalidateHwcGeometry();
+}
+void SurfaceFlinger::processDisplayHotplugEventsLocked() {
+    for (const auto& event : mPendingHotplugEvents) {
+        const std::optional<DisplayIdentificationInfo> info =
+                getHwComposer().onHotplug(event.hwcDisplayId, event.connection);
+        if (!info) {
+            continue;
@@ -1417,4 +1640,10 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+        if (event.connection == HWC2::Connection::Connected) {
+            if (!mPhysicalDisplayTokens.count(info->id)) {
+                ALOGV("Creating display %s", to_string(info->id).c_str());
+                mPhysicalDisplayTokens[info->id] = new BBinder();
+                DisplayDeviceState state;
+                state.displayId = info->id;
+                state.isSecure = true;
+                state.displayName = info->name;
+                mCurrentState.displays.add(mPhysicalDisplayTokens[info->id], state);
+                mInterceptor->saveDisplayCreation(state);
@@ -1421,0 +1651,527 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+        } else {
+            ALOGV("Removing display %s", to_string(info->id).c_str());
+            ssize_t index = mCurrentState.displays.indexOfKey(mPhysicalDisplayTokens[info->id]);
+            if (index >= 0) {
+                const DisplayDeviceState& state = mCurrentState.displays.valueAt(index);
+                mInterceptor->saveDisplayDeletion(state.sequenceId);
+                mCurrentState.displays.removeItemsAt(index);
+            }
+            mPhysicalDisplayTokens.erase(info->id);
+        }
+        processDisplayChangesLocked();
+    }
+    mPendingHotplugEvents.clear();
+}
+void SurfaceFlinger::dispatchDisplayHotplugEvent(PhysicalDisplayId displayId, bool connected) {
+    mScheduler->onHotplugReceived(mAppConnectionHandle, displayId, connected);
+    mScheduler->onHotplugReceived(mSfConnectionHandle, displayId, connected);
+}
+sp<DisplayDevice> SurfaceFlinger::setupNewDisplayDeviceInternal(
+        const wp<IBinder>& displayToken, const std::optional<DisplayId>& displayId,
+        const DisplayDeviceState& state, const sp<compositionengine::DisplaySurface>& dispSurface,
+        const sp<IGraphicBufferProducer>& producer) {
+    DisplayDeviceCreationArgs creationArgs(this, displayToken, displayId);
+    creationArgs.sequenceId = state.sequenceId;
+    creationArgs.isVirtual = state.isVirtual();
+    creationArgs.isSecure = state.isSecure;
+    creationArgs.displaySurface = dispSurface;
+    creationArgs.hasWideColorGamut = false;
+    creationArgs.supportedPerFrameMetadata = 0;
+    creationArgs.powerAdvisor = displayId ? &mPowerAdvisor : nullptr;
+    const bool isInternalDisplay = displayId && displayId == getInternalDisplayIdLocked();
+    creationArgs.isPrimary = isInternalDisplay;
+    if (useColorManagement && displayId) {
+        std::vector<ColorMode> modes = getHwComposer().getColorModes(*displayId);
+        for (ColorMode colorMode : modes) {
+            if (isWideColorMode(colorMode)) {
+                creationArgs.hasWideColorGamut = true;
+            }
+            std::vector<RenderIntent> renderIntents =
+                    getHwComposer().getRenderIntents(*displayId, colorMode);
+            creationArgs.hwcColorModes.emplace(colorMode, renderIntents);
+        }
+    }
+    if (displayId) {
+        getHwComposer().getHdrCapabilities(*displayId, &creationArgs.hdrCapabilities);
+        creationArgs.supportedPerFrameMetadata =
+                getHwComposer().getSupportedPerFrameMetadata(*displayId);
+    }
+    auto nativeWindowSurface = getFactory().createNativeWindowSurface(producer);
+    auto nativeWindow = nativeWindowSurface->getNativeWindow();
+    creationArgs.nativeWindow = nativeWindow;
+    if (state.isVirtual()) {
+        nativeWindow->setSwapInterval(nativeWindow.get(), 0);
+    }
+    creationArgs.displayInstallOrientation =
+            isInternalDisplay ? primaryDisplayOrientation : DisplayState::eOrientationDefault;
+    creationArgs.initialPowerMode = state.isVirtual() ? HWC_POWER_MODE_NORMAL : HWC_POWER_MODE_OFF;
+    sp<DisplayDevice> display = getFactory().createDisplayDevice(std::move(creationArgs));
+    if (maxFrameBufferAcquiredBuffers >= 3) {
+        nativeWindowSurface->preallocateBuffers();
+    }
+    ColorMode defaultColorMode = ColorMode::NATIVE;
+    Dataspace defaultDataSpace = Dataspace::UNKNOWN;
+    if (display->hasWideColorGamut()) {
+        defaultColorMode = ColorMode::SRGB;
+        defaultDataSpace = Dataspace::V0_SRGB;
+    }
+    display->getCompositionDisplay()->setColorProfile(
+            compositionengine::Output::ColorProfile{defaultColorMode, defaultDataSpace,
+                                                    RenderIntent::COLORIMETRIC,
+                                                    Dataspace::UNKNOWN});
+    if (!state.isVirtual()) {
+        LOG_ALWAYS_FATAL_IF(!displayId);
+        display->setActiveConfig(getHwComposer().getActiveConfigIndex(*displayId));
+    }
+    display->setLayerStack(state.layerStack);
+    display->setProjection(state.orientation, state.viewport, state.frame);
+    display->setDisplayName(state.displayName);
+    return display;
+}
+void SurfaceFlinger::processDisplayChangesLocked() {
+    const KeyedVector<wp<IBinder>, DisplayDeviceState>& curr(mCurrentState.displays);
+    const KeyedVector<wp<IBinder>, DisplayDeviceState>& draw(mDrawingState.displays);
+    if (!curr.isIdenticalTo(draw)) {
+        mVisibleRegionsDirty = true;
+        const size_t cc = curr.size();
+        size_t dc = draw.size();
+        for (size_t i = 0; i < dc;) {
+            const ssize_t j = curr.indexOfKey(draw.keyAt(i));
+            if (j < 0) {
+                if (const auto display = getDisplayDeviceLocked(draw.keyAt(i))) {
+                    const auto displayId = display->getId();
+                    display->disconnect();
+                    if (!display->isVirtual()) {
+                        LOG_ALWAYS_FATAL_IF(!displayId);
+                        dispatchDisplayHotplugEvent(displayId->value, false);
+                    }
+                }
+                mDisplays.erase(draw.keyAt(i));
+            } else {
+                const DisplayDeviceState& state(curr[j]);
+                const wp<IBinder>& displayToken = curr.keyAt(j);
+                const sp<IBinder> state_binder = IInterface::asBinder(state.surface);
+                const sp<IBinder> draw_binder = IInterface::asBinder(draw[i].surface);
+                if (state_binder != draw_binder) {
+                    if (const auto display = getDisplayDeviceLocked(displayToken)) {
+                        display->disconnect();
+                    }
+                    mDisplays.erase(displayToken);
+                    mDrawingState.displays.removeItemsAt(i);
+                    dc--;
+                    continue;
+                }
+                if (const auto display = getDisplayDeviceLocked(displayToken)) {
+                    if (state.layerStack != draw[i].layerStack) {
+                        display->setLayerStack(state.layerStack);
+                    }
+                    if ((state.orientation != draw[i].orientation) ||
+                        (state.viewport != draw[i].viewport) || (state.frame != draw[i].frame)) {
+                        display->setProjection(state.orientation, state.viewport, state.frame);
+                    }
+                    if (state.width != draw[i].width || state.height != draw[i].height) {
+                        display->setDisplaySize(state.width, state.height);
+                    }
+                }
+            }
+            ++i;
+        }
+        for (size_t i = 0; i < cc; i++) {
+            if (draw.indexOfKey(curr.keyAt(i)) < 0) {
+                const DisplayDeviceState& state(curr[i]);
+                sp<compositionengine::DisplaySurface> dispSurface;
+                sp<IGraphicBufferProducer> producer;
+                sp<IGraphicBufferProducer> bqProducer;
+                sp<IGraphicBufferConsumer> bqConsumer;
+                getFactory().createBufferQueue(&bqProducer, &bqConsumer, false);
+                std::optional<DisplayId> displayId;
+                if (state.isVirtual()) {
+                    if (state.surface != nullptr) {
+                        if (mUseHwcVirtualDisplays || getHwComposer().isUsingVrComposer()) {
+                            int width = 0;
+                            int status = state.surface->query(NATIVE_WINDOW_WIDTH, &width);
+                            ALOGE_IF(status != NO_ERROR, "Unable to query width (%d)", status);
+                            int height = 0;
+                            status = state.surface->query(NATIVE_WINDOW_HEIGHT, &height);
+                            ALOGE_IF(status != NO_ERROR, "Unable to query height (%d)", status);
+                            int intFormat = 0;
+                            status = state.surface->query(NATIVE_WINDOW_FORMAT, &intFormat);
+                            ALOGE_IF(status != NO_ERROR, "Unable to query format (%d)", status);
+                            auto format = static_cast<ui::PixelFormat>(intFormat);
+                            displayId =
+                                    getHwComposer().allocateVirtualDisplay(width, height, &format);
+                        }
+                        sp<VirtualDisplaySurface> vds =
+                                new VirtualDisplaySurface(getHwComposer(), displayId, state.surface,
+                                                          bqProducer, bqConsumer,
+                                                          state.displayName);
+                        dispSurface = vds;
+                        producer = vds;
+                    }
+                } else {
+                    ALOGE_IF(state.surface != nullptr,
+                             "adding a supported display, but rendering "
+                             "surface is provided (%p), ignoring it",
+                             state.surface.get());
+                    displayId = state.displayId;
+                    LOG_ALWAYS_FATAL_IF(!displayId);
+                    dispSurface = new FramebufferSurface(getHwComposer(), *displayId, bqConsumer);
+                    producer = bqProducer;
+                }
+                const wp<IBinder>& displayToken = curr.keyAt(i);
+                if (dispSurface != nullptr) {
+                    mDisplays.emplace(displayToken,
+                                      setupNewDisplayDeviceInternal(displayToken, displayId, state,
+                                                                    dispSurface, producer));
+                    if (!state.isVirtual()) {
+                        LOG_ALWAYS_FATAL_IF(!displayId);
+                        dispatchDisplayHotplugEvent(displayId->value, true);
+                    }
+                }
+            }
+        }
+    }
+    mDrawingState.displays = mCurrentState.displays;
+}
+void SurfaceFlinger::handleTransactionLocked(uint32_t transactionFlags)
+{
+    const nsecs_t expectedPresentTime = mExpectedPresentTime.load();
+    mCurrentState.traverseInZOrder([expectedPresentTime](Layer* layer) {
+        layer->notifyAvailableFrames(expectedPresentTime);
+    });
+    if ((transactionFlags & eTraversalNeeded) || mTraversalNeededMainThread) {
+        mCurrentState.traverseInZOrder([&](Layer* layer) {
+            uint32_t trFlags = layer->getTransactionFlags(eTransactionNeeded);
+            if (!trFlags) return;
+            const uint32_t flags = layer->doTransaction(0);
+            if (flags & Layer::eVisibleRegion)
+                mVisibleRegionsDirty = true;
+            if (flags & Layer::eInputInfoChanged) {
+                mInputInfoChanged = true;
+            }
+        });
+        mTraversalNeededMainThread = false;
+    }
+    if (transactionFlags & eDisplayTransactionNeeded) {
+        processDisplayChangesLocked();
+        processDisplayHotplugEventsLocked();
+    }
+    if (transactionFlags & (eDisplayLayerStackChanged|eDisplayTransactionNeeded)) {
+        sp<const DisplayDevice> hintDisplay;
+        uint32_t currentlayerStack = 0;
+        bool first = true;
+        mCurrentState.traverseInZOrder([&](Layer* layer) {
+            uint32_t layerStack = layer->getLayerStack();
+            if (first || currentlayerStack != layerStack) {
+                currentlayerStack = layerStack;
+                hintDisplay = nullptr;
+                for (const auto& [token, display] : mDisplays) {
+                    if (display->getCompositionDisplay()
+                                ->belongsInOutput(layer->getLayerStack(),
+                                                  layer->getPrimaryDisplayOnly())) {
+                        if (hintDisplay) {
+                            hintDisplay = nullptr;
+                            break;
+                        } else {
+                            hintDisplay = display;
+                        }
+                    }
+                }
+            }
+            if (!hintDisplay) {
+                hintDisplay = getDefaultDisplayDeviceLocked();
+            }
+            if (hintDisplay) {
+                layer->updateTransformHint(hintDisplay);
+            }
+            first = false;
+        });
+    }
+    if (mLayersAdded) {
+        mLayersAdded = false;
+        mVisibleRegionsDirty = true;
+    }
+    if (mLayersRemoved) {
+        mLayersRemoved = false;
+        mVisibleRegionsDirty = true;
+        mDrawingState.traverseInZOrder([&](Layer* layer) {
+            if (mLayersPendingRemoval.indexOf(layer) >= 0) {
+                Region visibleReg;
+                visibleReg.set(layer->getScreenBounds());
+                invalidateLayerStack(layer, visibleReg);
+            }
+        });
+    }
+    commitInputWindowCommands();
+    commitTransaction();
+}
+void SurfaceFlinger::updateInputFlinger() {
+    ATRACE_CALL();
+    if (!mInputFlinger) {
+        return;
+    }
+    if (mVisibleRegionsDirty || mInputInfoChanged) {
+        mInputInfoChanged = false;
+        updateInputWindowInfo();
+    } else if (mInputWindowCommands.syncInputWindows) {
+        setInputWindowsFinished();
+    }
+    executeInputWindowCommands();
+}
+void SurfaceFlinger::updateInputWindowInfo() {
+    std::vector<InputWindowInfo> inputHandles;
+    mDrawingState.traverseInReverseZOrder([&](Layer* layer) {
+        if (layer->hasInput()) {
+            inputHandles.push_back(layer->fillInputInfo());
+        }
+    });
+    mInputFlinger->setInputWindows(inputHandles,
+                                   mInputWindowCommands.syncInputWindows ? mSetInputWindowsListener
+                                                                         : nullptr);
+}
+void SurfaceFlinger::commitInputWindowCommands() {
+    mInputWindowCommands = mPendingInputWindowCommands;
+    mPendingInputWindowCommands.clear();
+}
+void SurfaceFlinger::executeInputWindowCommands() {
+    for (const auto& transferTouchFocusCommand : mInputWindowCommands.transferTouchFocusCommands) {
+        if (transferTouchFocusCommand.fromToken != nullptr &&
+            transferTouchFocusCommand.toToken != nullptr &&
+            transferTouchFocusCommand.fromToken != transferTouchFocusCommand.toToken) {
+            mInputFlinger->transferTouchFocus(transferTouchFocusCommand.fromToken,
+                                              transferTouchFocusCommand.toToken);
+        }
+    }
+    mInputWindowCommands.clear();
+}
+void SurfaceFlinger::updateCursorAsync()
+{
+    compositionengine::CompositionRefreshArgs refreshArgs;
+    for (const auto& [_, display] : mDisplays) {
+        if (display->getId()) {
+            refreshArgs.outputs.push_back(display->getCompositionDisplay());
+        }
+    }
+    mCompositionEngine->updateCursorAsync(refreshArgs);
+}
+void SurfaceFlinger::commitTransaction()
+{
+    withTracingLock([&]() {
+        if (!mLayersPendingRemoval.isEmpty()) {
+            for (const auto& l : mLayersPendingRemoval) {
+                recordBufferingStats(l->getName().string(), l->getOccupancyHistory(true));
+                if (l->isRemovedFromCurrentState()) {
+                    l->latchAndReleaseBuffer();
+                }
+                if (!l->getParent()) {
+                    mOffscreenLayers.emplace(l.get());
+                }
+            }
+            mLayersPendingRemoval.clear();
+        }
+        mAnimCompositionPending = mAnimTransactionPending;
+        mDrawingState = mCurrentState;
+        mCurrentState.colorMatrixChanged = false;
+        mDrawingState.traverseInZOrder([&](Layer* layer) {
+            layer->commitChildList();
+            if (mOffscreenLayers.count(layer)) {
+                mOffscreenLayers.erase(layer);
+            }
+        });
+        commitOffscreenLayers();
+    });
+    mTransactionPending = false;
+    mAnimTransactionPending = false;
+    mTransactionCV.broadcast();
+}
+void SurfaceFlinger::withTracingLock(std::function<void()> lockedOperation) {
+    if (mTracingEnabledChanged) {
+        mTracingEnabled = mTracing.isEnabled();
+        mTracingEnabledChanged = false;
+    }
+    std::unique_lock<std::mutex> lock;
+    if (mTracingEnabled) {
+        lock = std::unique_lock<std::mutex>(mDrawingStateLock);
+    }
+    lockedOperation();
+    if (mTracingEnabled) {
+        lock.unlock();
+    }
+}
+void SurfaceFlinger::commitOffscreenLayers() {
+    for (Layer* offscreenLayer : mOffscreenLayers) {
+        offscreenLayer->traverseInZOrder(LayerVector::StateSet::Drawing, [](Layer* layer) {
+            uint32_t trFlags = layer->getTransactionFlags(eTransactionNeeded);
+            if (!trFlags) return;
+            layer->doTransaction(0);
+            layer->commitChildList();
+        });
+    }
+}
+void SurfaceFlinger::computeVisibleRegions(const sp<const DisplayDevice>& displayDevice,
+                                           Region& outDirtyRegion, Region& outOpaqueRegion) {
+    ATRACE_CALL();
+    ALOGV("computeVisibleRegions");
+    auto display = displayDevice->getCompositionDisplay();
+    Region aboveOpaqueLayers;
+    Region aboveCoveredLayers;
+    Region dirty;
+    outDirtyRegion.clear();
+    mDrawingState.traverseInReverseZOrder([&](Layer* layer) {
+        const Layer::State& s(layer->getDrawingState());
+        if (!display->belongsInOutput(layer->getLayerStack(), layer->getPrimaryDisplayOnly())) {
+            return;
+        }
+        Region opaqueRegion;
+        Region visibleRegion;
+        Region coveredRegion;
+        Region transparentRegion;
+        if (CC_LIKELY(layer->isVisible())) {
+            const bool translucent = !layer->isOpaque(s);
+            Rect bounds(layer->getScreenBounds());
+            visibleRegion.set(bounds);
+            ui::Transform tr = layer->getTransform();
+            if (!visibleRegion.isEmpty()) {
+                if (translucent) {
+                    if (tr.preserveRects()) {
+                        transparentRegion = tr.transform(layer->getActiveTransparentRegion(s));
+                    } else {
+                        transparentRegion.clear();
+                    }
+                }
+                const int32_t layerOrientation = tr.getOrientation();
+                if (layer->getAlpha() == 1.0f && !translucent &&
+                        layer->getRoundedCornerState().radius == 0.0f &&
+                        ((layerOrientation & ui::Transform::ROT_INVALID) == false)) {
+                    opaqueRegion = visibleRegion;
+                }
+            }
+        }
+        if (visibleRegion.isEmpty()) {
+            layer->clearVisibilityRegions();
+            return;
+        }
+        coveredRegion = aboveCoveredLayers.intersect(visibleRegion);
+        aboveCoveredLayers.orSelf(visibleRegion);
+        visibleRegion.subtractSelf(aboveOpaqueLayers);
+        if (layer->contentDirty) {
+            dirty = visibleRegion;
+            dirty.orSelf(layer->visibleRegion);
+            layer->contentDirty = false;
+        } else {
+            const Region newExposed = visibleRegion - coveredRegion;
+            const Region oldVisibleRegion = layer->visibleRegion;
+            const Region oldCoveredRegion = layer->coveredRegion;
+            const Region oldExposed = oldVisibleRegion - oldCoveredRegion;
+            dirty = (visibleRegion&oldCoveredRegion) | (newExposed-oldExposed);
+        }
+        dirty.subtractSelf(aboveOpaqueLayers);
+        outDirtyRegion.orSelf(dirty);
+        aboveOpaqueLayers.orSelf(opaqueRegion);
+        layer->setVisibleRegion(visibleRegion);
+        layer->setCoveredRegion(coveredRegion);
+        layer->setVisibleNonTransparentRegion(
+                visibleRegion.subtract(transparentRegion));
+    });
+    outOpaqueRegion = aboveOpaqueLayers;
+}
+void SurfaceFlinger::invalidateLayerStack(const sp<const Layer>& layer, const Region& dirty) {
+    for (const auto& [token, displayDevice] : mDisplays) {
+        auto display = displayDevice->getCompositionDisplay();
+        if (display->belongsInOutput(layer->getLayerStack(), layer->getPrimaryDisplayOnly())) {
+            display->editState().dirtyRegion.orSelf(dirty);
+        }
+    }
+}
+bool SurfaceFlinger::handlePageFlip()
+{
+    ATRACE_CALL();
+    ALOGV("handlePageFlip");
+    nsecs_t latchTime = systemTime();
+    bool visibleRegions = false;
+    bool frameQueued = false;
+    bool newDataLatched = false;
+    const nsecs_t expectedPresentTime = mExpectedPresentTime.load();
+    mDrawingState.traverseInZOrder([&](Layer* layer) {
+        if (layer->hasReadyFrame()) {
+            frameQueued = true;
+            if (layer->shouldPresentNow(expectedPresentTime)) {
+                mLayersWithQueuedFrames.push_back(layer);
+            } else {
+                ATRACE_NAME("!layer->shouldPresentNow()");
+                layer->useEmptyDamage();
+            }
+        } else {
+            layer->useEmptyDamage();
+        }
+    });
+    for (Layer* offscreenLayer : mOffscreenLayers) {
+        offscreenLayer->traverseInZOrder(LayerVector::StateSet::Drawing,
+                                         [&](Layer* l) { l->latchAndReleaseBuffer(); });
+    }
+    if (!mLayersWithQueuedFrames.empty()) {
+        Mutex::Autolock lock(mStateLock);
+        for (auto& layer : mLayersWithQueuedFrames) {
+            if (layer->latchBuffer(visibleRegions, latchTime, expectedPresentTime)) {
+                mLayersPendingRefresh.push_back(layer);
+            }
+            layer->useSurfaceDamage();
+            if (layer->isBufferLatched()) {
+                newDataLatched = true;
+            }
+        }
+    }
+    mVisibleRegionsDirty |= visibleRegions;
+    if (frameQueued && (mLayersWithQueuedFrames.empty() || !newDataLatched)) {
+        signalLayerUpdate();
+    }
+    if (CC_UNLIKELY(mBootStage == BootStage::BOOTLOADER && newDataLatched)) {
+        ALOGI("Enter boot animation");
+        mBootStage = BootStage::BOOTANIMATION;
+    }
+    return !mLayersWithQueuedFrames.empty() && newDataLatched;
+}
+void SurfaceFlinger::invalidateHwcGeometry()
+{
+    mGeometryInvalid = true;
+}
+status_t SurfaceFlinger::addClientLayer(const sp<Client>& client, const sp<IBinder>& handle,
+                                        const sp<IGraphicBufferProducer>& gbc, const sp<Layer>& lbc,
+                                        const sp<IBinder>& parentHandle,
+                                        const sp<Layer>& parentLayer, bool addToCurrentState) {
+    {
+        Mutex::Autolock _l(mStateLock);
+        sp<Layer> parent;
+        if (parentHandle != nullptr) {
+            parent = fromHandle(parentHandle);
+            if (parent == nullptr) {
+                return NAME_NOT_FOUND;
+            }
+        } else {
+            parent = parentLayer;
+        }
+        if (mNumLayers >= MAX_LAYERS) {
+            ALOGE("AddClientLayer failed, mNumLayers (%zu) >= MAX_LAYERS (%zu)", mNumLayers.load(),
+                  MAX_LAYERS);
+            return NO_MEMORY;
+        }
+        mLayersByLocalBinderToken.emplace(handle->localBinder(), lbc);
+        if (parent == nullptr && addToCurrentState) {
+            mCurrentState.layersSortedByZ.add(lbc);
+        } else if (parent == nullptr) {
+            lbc->onRemovedFromCurrentState();
+        } else if (parent->isRemovedFromCurrentState()) {
+            parent->addChild(lbc);
+            lbc->onRemovedFromCurrentState();
+        } else {
+            parent->addChild(lbc);
+        }
+        if (gbc != nullptr) {
+            mGraphicBufferProducerList.insert(IInterface::asBinder(gbc).get());
+            LOG_ALWAYS_FATAL_IF(mGraphicBufferProducerList.size() >
+                                        mMaxGraphicBufferProducerListSize,
+                                "Suspected IGBP leak: %zu IGBPs (%zu max), %zu Layers",
+                                mGraphicBufferProducerList.size(),
+                                mMaxGraphicBufferProducerListSize, mNumLayers.load());
+        }
+        mLayersAdded = true;
@@ -1423,4 +2179,2 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+    client->attachLayer(handle, lbc);
+    return NO_ERROR;
@@ -1427,0 +2182,2 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+uint32_t SurfaceFlinger::peekTransactionFlags() {
+    return mTransactionFlags;
@@ -1429,4 +2185,2 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+uint32_t SurfaceFlinger::getTransactionFlags(uint32_t flags) {
+    return mTransactionFlags.fetch_and(~flags) & flags;
@@ -1433,0 +2188,2 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+uint32_t SurfaceFlinger::setTransactionFlags(uint32_t flags) {
+    return setTransactionFlags(flags, Scheduler::TransactionStart::NORMAL);
@@ -1435,4 +2191,6 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+uint32_t SurfaceFlinger::setTransactionFlags(uint32_t flags,
+                                             Scheduler::TransactionStart transactionStart) {
+    uint32_t old = mTransactionFlags.fetch_or(flags);
+    mVSyncModulator->setTransactionStart(transactionStart);
+    if ((old & flags)==0) {
+        signalTransaction();
@@ -1439,0 +2198 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+    return old;
@@ -1441,4 +2200,15 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+bool SurfaceFlinger::flushTransactionQueues() {
+    std::vector<const TransactionState> transactions;
+    bool flushedATransaction = false;
+    {
+        Mutex::Autolock _l(mStateLock);
+        auto it = mTransactionQueues.begin();
+        while (it != mTransactionQueues.end()) {
+            auto& [applyToken, transactionQueue] = *it;
+            while (!transactionQueue.empty()) {
+                const auto& transaction = transactionQueue.front();
+                if (!transactionIsReadyToBeApplied(transaction.desiredPresentTime,
+                                                   true ,
+                                                   transaction.states)) {
+                    setTransactionFlags(eTransactionFlushNeeded);
+                    break;
@@ -1445,0 +2216,14 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+                transactions.push_back(transaction);
+                applyTransactionState(transaction.states, transaction.displays, transaction.flags,
+                                      mPendingInputWindowCommands, transaction.desiredPresentTime,
+                                      transaction.buffer, transaction.callback,
+                                      transaction.postTime, transaction.privileged,
+                                                       true);
+                transactionQueue.pop();
+                flushedATransaction = true;
+            }
+            if (transactionQueue.empty()) {
+                it = mTransactionQueues.erase(it);
+                mTransactionCV.broadcast();
+            } else {
+                it = std::next(it, 1);
@@ -1447,4 +2230,0 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
@@ -1453,4 +2233 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+    return flushedATransaction;
@@ -1457,0 +2235,2 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+bool SurfaceFlinger::transactionFlushNeeded() {
+    return !mTransactionQueues.empty();
@@ -1459,4 +2238,9 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+bool SurfaceFlinger::transactionIsReadyToBeApplied(int64_t desiredPresentTime,
+                                                   bool useCachedExpectedPresentTime,
+                                                   const Vector<ComposerState>& states) {
+    if (!useCachedExpectedPresentTime)
+        populateExpectedPresentTime();
+    const nsecs_t expectedPresentTime = mExpectedPresentTime.load();
+    if (desiredPresentTime >= 0 && desiredPresentTime >= expectedPresentTime &&
+        desiredPresentTime < expectedPresentTime + s2ns(1)) {
+        return false;
@@ -1463,0 +2248,4 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+    for (const ComposerState& state : states) {
+        const layer_state_t& s = state.state;
+        if (!(s.what & layer_state_t::eAcquireFenceChanged)) {
+            continue;
@@ -1465,4 +2253,2 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+        if (s.acquireFence && s.acquireFence->getStatus() == Fence::Status::Unsignaled) {
+            return false;
@@ -1471,4 +2257 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+    return true;
@@ -1475,0 +2259,20 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+void SurfaceFlinger::setTransactionState(const Vector<ComposerState>& states,
+                                         const Vector<DisplayState>& displays, uint32_t flags,
+                                         const sp<IBinder>& applyToken,
+                                         const InputWindowCommands& inputWindowCommands,
+                                         int64_t desiredPresentTime,
+                                         const client_cache_t& uncacheBuffer,
+                                         const std::vector<ListenerCallbacks>& listenerCallbacks) {
+    ATRACE_CALL();
+    const int64_t postTime = systemTime();
+    bool privileged = callingThreadHasUnscopedSurfaceFlingerAccess();
+    Mutex::Autolock _l(mStateLock);
+    auto itr = mTransactionQueues.find(applyToken);
+    if (flags & eAnimation) {
+        while (itr != mTransactionQueues.end()) {
+            status_t err = mTransactionCV.waitRelative(mStateLock, s2ns(5));
+            if (CC_UNLIKELY(err != NO_ERROR)) {
+                ALOGW_IF(err == TIMED_OUT,
+                         "setTransactionState timed out "
+                         "waiting for animation frame to apply");
+                break;
@@ -1477,4 +2280 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+            itr = mTransactionQueues.find(applyToken);
@@ -1483,4 +2283,7 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+    if (itr != mTransactionQueues.end() || !transactionIsReadyToBeApplied(
+            desiredPresentTime, false , states)) {
+        mTransactionQueues[applyToken].emplace(states, displays, flags, desiredPresentTime,
+                                               uncacheBuffer, listenerCallbacks, postTime,
+                                               privileged);
+        setTransactionFlags(eTransactionFlushNeeded);
+        return;
@@ -1487,0 +2291,20 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+    applyTransactionState(states, displays, flags, inputWindowCommands, desiredPresentTime,
+                          uncacheBuffer, listenerCallbacks, postTime, privileged);
+}
+void SurfaceFlinger::applyTransactionState(const Vector<ComposerState>& states,
+                                           const Vector<DisplayState>& displays, uint32_t flags,
+                                           const InputWindowCommands& inputWindowCommands,
+                                           const int64_t desiredPresentTime,
+                                           const client_cache_t& uncacheBuffer,
+                                           const std::vector<ListenerCallbacks>& listenerCallbacks,
+                                           const int64_t postTime, bool privileged,
+                                           bool isMainThread) {
+    uint32_t transactionFlags = 0;
+    if (flags & eAnimation) {
+        while (!isMainThread && mAnimTransactionPending) {
+            status_t err = mTransactionCV.waitRelative(mStateLock, s2ns(5));
+            if (CC_UNLIKELY(err != NO_ERROR)) {
+                ALOGW_IF(err == TIMED_OUT, "setTransactionState timed out "
+                        "waiting for previous animation frame");
+                mAnimTransactionPending = false;
+                break;
@@ -1489,4 +2311,0 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
@@ -1495,4 +2314,2 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+    for (const DisplayState& display : displays) {
+        transactionFlags |= setDisplayStateLocked(display);
@@ -1499,0 +2317,2 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+    if (!listenerCallbacks.empty()) {
+        mTransactionCompletedThread.run();
@@ -1501,4 +2320,2 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+    for (const auto& listenerCallback : listenerCallbacks) {
+        mTransactionCompletedThread.startRegistration(listenerCallback);
@@ -1505,0 +2323,4 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+    uint32_t clientStateFlags = 0;
+    for (const ComposerState& state : states) {
+        clientStateFlags |= setClientStateLocked(state, desiredPresentTime, listenerCallbacks,
+                                                 postTime, privileged);
@@ -1507,4 +2328,2 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+    for (const auto& listenerCallback : listenerCallbacks) {
+        mTransactionCompletedThread.endRegistration(listenerCallback);
@@ -1511,0 +2331,2 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+    if (!(clientStateFlags & eTraversalNeeded) && !listenerCallbacks.empty()) {
+        mTransactionCompletedThread.sendCallbacks();
@@ -1513,4 +2334,5 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+    transactionFlags |= clientStateFlags;
+    transactionFlags |= addInputWindowCommands(inputWindowCommands);
+    if (uncacheBuffer.isValid()) {
+        ClientCache::getInstance().erase(uncacheBuffer);
+        getRenderEngine().unbindExternalTextureBuffer(uncacheBuffer.id);
@@ -1517,0 +2340,3 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+    if (transactionFlags == 0 &&
+            ((flags & eSynchronous) || (flags & eAnimation))) {
+        transactionFlags = eTransactionNeeded;
@@ -1519,4 +2344,3 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+    if (isMainThread && (transactionFlags & eTraversalNeeded)) {
+        transactionFlags = transactionFlags & (~eTraversalNeeded);
+        mTraversalNeededMainThread = true;
@@ -1523,0 +2348,3 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+    if (transactionFlags) {
+        if (mInterceptor->isEnabled()) {
+            mInterceptor->saveTransaction(states, mCurrentState.displays, displays, flags);
@@ -1525,4 +2352,5 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+        const auto start = (flags & eEarlyWakeup) ? Scheduler::TransactionStart::EARLY
+                                                  : Scheduler::TransactionStart::NORMAL;
+        setTransactionFlags(transactionFlags, start);
+        if (flags & eSynchronous) {
+            mTransactionPending = true;
@@ -1529,0 +2358,2 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+        if (flags & eAnimation) {
+            mAnimTransactionPending = true;
@@ -1531,4 +2361,2 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+        if (mPendingInputWindowCommands.syncInputWindows) {
+            mPendingSyncInputWindows = true;
@@ -1535,0 +2364,7 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+        while (!isMainThread && (mTransactionPending || mPendingSyncInputWindows)) {
+            status_t err = mTransactionCV.waitRelative(mStateLock, s2ns(5));
+            if (CC_UNLIKELY(err != NO_ERROR)) {
+                ALOGW_IF(err == TIMED_OUT, "setTransactionState timed out!");
+                mTransactionPending = false;
+                mPendingSyncInputWindows = false;
+                break;
@@ -1537,4 +2371,0 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
@@ -1543,4 +2373,0 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
@@ -1547,0 +2375,10 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+uint32_t SurfaceFlinger::setDisplayStateLocked(const DisplayState& s) {
+    const ssize_t index = mCurrentState.displays.indexOfKey(s.token);
+    if (index < 0) return 0;
+    uint32_t flags = 0;
+    DisplayDeviceState& state = mCurrentState.displays.editValueAt(index);
+    const uint32_t what = s.what;
+    if (what & DisplayState::eSurfaceChanged) {
+        if (IInterface::asBinder(state.surface) != IInterface::asBinder(s.surface)) {
+            state.surface = s.surface;
+            flags |= eDisplayTransactionNeeded;
@@ -1549,4 +2385,0 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
@@ -1553,0 +2387,4 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+    if (what & DisplayState::eLayerStackChanged) {
+        if (state.layerStack != s.layerStack) {
+            state.layerStack = s.layerStack;
+            flags |= eDisplayTransactionNeeded;
@@ -1555,4 +2391,0 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
@@ -1559,0 +2393,4 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+    if (what & DisplayState::eDisplayProjectionChanged) {
+        if (state.orientation != s.orientation) {
+            state.orientation = s.orientation;
+            flags |= eDisplayTransactionNeeded;
@@ -1561,4 +2398,3 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+        if (state.frame != s.frame) {
+            state.frame = s.frame;
+            flags |= eDisplayTransactionNeeded;
@@ -1565,0 +2402,3 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+        if (state.viewport != s.viewport) {
+            state.viewport = s.viewport;
+            flags |= eDisplayTransactionNeeded;
@@ -1567,4 +2405,0 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
@@ -1571,0 +2407,4 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+    if (what & DisplayState::eDisplaySizeChanged) {
+        if (state.width != s.width) {
+            state.width = s.width;
+            flags |= eDisplayTransactionNeeded;
@@ -1573,4 +2412,3 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+        if (state.height != s.height) {
+            state.height = s.height;
+            flags |= eDisplayTransactionNeeded;
@@ -1579,4 +2417 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+    return flags;
@@ -1583,0 +2419,9 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+bool SurfaceFlinger::callingThreadHasUnscopedSurfaceFlingerAccess() {
+    IPCThreadState* ipc = IPCThreadState::self();
+    const int pid = ipc->getCallingPid();
+    const int uid = ipc->getCallingUid();
+    if ((uid != AID_GRAPHICS && uid != AID_SYSTEM) &&
+        !PermissionCache::checkPermission(sAccessSurfaceFlinger, pid, uid)) {
+        return false;
+    }
+    return true;
@@ -1585,4 +2429,34 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+uint32_t SurfaceFlinger::setClientStateLocked(
+        const ComposerState& composerState, int64_t desiredPresentTime,
+        const std::vector<ListenerCallbacks>& listenerCallbacks, int64_t postTime,
+        bool privileged) {
+    const layer_state_t& s = composerState.state;
+    sp<Layer> layer(fromHandle(s.surface));
+    if (layer == nullptr) {
+        for (auto& listenerCallback : listenerCallbacks) {
+            mTransactionCompletedThread.registerUnpresentedCallbackHandle(
+                    new CallbackHandle(listenerCallback.transactionCompletedListener,
+                                       listenerCallback.callbackIds, s.surface));
+        }
+        return 0;
+    }
+    uint32_t flags = 0;
+    const uint64_t what = s.what;
+    bool geometryAppliesWithResize =
+            what & layer_state_t::eGeometryAppliesWithResize;
+    if (what & layer_state_t::eDeferTransaction_legacy) {
+        layer->pushPendingState();
+    }
+    if (what & layer_state_t::ePositionChanged) {
+        if (layer->setPosition(s.x, s.y, !geometryAppliesWithResize)) {
+            flags |= eTraversalNeeded;
+        }
+    }
+    if (what & layer_state_t::eLayerChanged) {
+        const auto& p = layer->getParent();
+        if (p == nullptr) {
+            ssize_t idx = mCurrentState.layersSortedByZ.indexOf(layer);
+            if (layer->setLayer(s.z) && idx >= 0) {
+                mCurrentState.layersSortedByZ.removeAt(idx);
+                mCurrentState.layersSortedByZ.add(layer);
+                flags |= eTransactionNeeded|eTraversalNeeded;
@@ -1589,0 +2464,18 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+        } else {
+            if (p->setChildLayer(layer, s.z)) {
+                flags |= eTransactionNeeded|eTraversalNeeded;
+            }
+        }
+    }
+    if (what & layer_state_t::eRelativeLayerChanged) {
+        const auto& p = layer->getParent();
+        if (p == nullptr) {
+            ssize_t idx = mCurrentState.layersSortedByZ.indexOf(layer);
+            if (layer->setRelativeLayer(s.relativeLayerHandle, s.z) && idx >= 0) {
+                mCurrentState.layersSortedByZ.removeAt(idx);
+                mCurrentState.layersSortedByZ.add(layer);
+                flags |= eTransactionNeeded|eTraversalNeeded;
+            }
+        } else {
+            if (p->setChildRelativeLayer(layer, s.relativeLayerHandle, s.z)) {
+                flags |= eTransactionNeeded|eTraversalNeeded;
@@ -1591,4 +2482,0 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
@@ -1597,4 +2485,3 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+    if (what & layer_state_t::eSizeChanged) {
+        if (layer->setSize(s.w, s.h)) {
+            flags |= eTraversalNeeded;
@@ -1603,4 +2490,3 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+    if (what & layer_state_t::eAlphaChanged) {
+        if (layer->setAlpha(s.alpha))
+            flags |= eTraversalNeeded;
@@ -1607,0 +2494,3 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+    if (what & layer_state_t::eColorChanged) {
+        if (layer->setColor(s.color))
+            flags |= eTraversalNeeded;
@@ -1609,4 +2498,3 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+    if (what & layer_state_t::eColorTransformChanged) {
+        if (layer->setColorTransform(s.colorTransform)) {
+            flags |= eTraversalNeeded;
@@ -1615,4 +2503,3 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+    if (what & layer_state_t::eBackgroundColorChanged) {
+        if (layer->setBackgroundColor(s.color, s.bgColorAlpha, s.bgColorDataspace)) {
+            flags |= eTraversalNeeded;
@@ -1621,4 +2508,3 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+    if (what & layer_state_t::eMatrixChanged) {
+        if (layer->setMatrix(s.matrix, privileged))
+            flags |= eTraversalNeeded;
@@ -1625,0 +2512,3 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+    if (what & layer_state_t::eTransparentRegionChanged) {
+        if (layer->setTransparentRegionHint(s.transparentRegion))
+            flags |= eTraversalNeeded;
@@ -1627,4 +2516,3 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+    if (what & layer_state_t::eFlagsChanged) {
+        if (layer->setFlags(s.flags, s.mask))
+            flags |= eTraversalNeeded;
@@ -1631,0 +2520,3 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+    if (what & layer_state_t::eCropChanged_legacy) {
+        if (layer->setCrop_legacy(s.crop_legacy, !geometryAppliesWithResize))
+            flags |= eTraversalNeeded;
@@ -1633,4 +2524,3 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+    if (what & layer_state_t::eCornerRadiusChanged) {
+        if (layer->setCornerRadius(s.cornerRadius))
+            flags |= eTraversalNeeded;
@@ -1637,0 +2528,13 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+    if (what & layer_state_t::eLayerStackChanged) {
+        ssize_t idx = mCurrentState.layersSortedByZ.indexOf(layer);
+        if (layer->hasParent()) {
+            ALOGE("Attempt to set layer stack on layer with parent (%s) is invalid",
+                    layer->getName().string());
+        } else if (idx < 0) {
+            ALOGE("Attempt to set layer stack on layer without parent (%s) that "
+                    "that also does not appear in the top level layer list. Something"
+                    " has gone wrong.", layer->getName().string());
+        } else if (layer->setLayerStack(s.layerStack)) {
+            mCurrentState.layersSortedByZ.removeAt(idx);
+            mCurrentState.layersSortedByZ.add(layer);
+            flags |= eTransactionNeeded|eTraversalNeeded|eDisplayLayerStackChanged;
@@ -1639,4 +2541,0 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
@@ -1643,0 +2543,12 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+    if (what & layer_state_t::eDeferTransaction_legacy) {
+        if (s.barrierHandle_legacy != nullptr) {
+            layer->deferTransactionUntil_legacy(s.barrierHandle_legacy, s.frameNumber_legacy);
+        } else if (s.barrierGbp_legacy != nullptr) {
+            const sp<IGraphicBufferProducer>& gbp = s.barrierGbp_legacy;
+            if (authenticateSurfaceTextureLocked(gbp)) {
+                const auto& otherLayer =
+                    (static_cast<MonitoredProducer*>(gbp.get()))->getLayer();
+                layer->deferTransactionUntil_legacy(otherLayer, s.frameNumber_legacy);
+            } else {
+                ALOGE("Attempt to defer transaction to to an"
+                        " unrecognized GraphicBufferProducer");
@@ -1645,4 +2555,0 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
@@ -1651,4 +2558,3 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+    if (what & layer_state_t::eReparentChildren) {
+        if (layer->reparentChildren(s.reparentHandle)) {
+            flags |= eTransactionNeeded|eTraversalNeeded;
@@ -1657,4 +2563,2 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+    if (what & layer_state_t::eDetachChildren) {
+        layer->detachChildren();
@@ -1661,0 +2566,2 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+    if (what & layer_state_t::eOverrideScalingModeChanged) {
+        layer->setOverrideScalingMode(s.overrideScalingMode);
@@ -1663,4 +2569,2 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+    if (what & layer_state_t::eTransformChanged) {
+        if (layer->setTransform(s.transform)) flags |= eTraversalNeeded;
@@ -1667,0 +2572,3 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+    if (what & layer_state_t::eTransformToDisplayInverseChanged) {
+        if (layer->setTransformToDisplayInverse(s.transformToDisplayInverse))
+            flags |= eTraversalNeeded;
@@ -1669,4 +2576,2 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+    if (what & layer_state_t::eCropChanged) {
+        if (layer->setCrop(s.crop)) flags |= eTraversalNeeded;
@@ -1673,0 +2579,2 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+    if (what & layer_state_t::eFrameChanged) {
+        if (layer->setFrame(s.frame)) flags |= eTraversalNeeded;
@@ -1675,4 +2582,2 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+    if (what & layer_state_t::eAcquireFenceChanged) {
+        if (layer->setAcquireFence(s.acquireFence)) flags |= eTraversalNeeded;
@@ -1679,0 +2585,2 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+    if (what & layer_state_t::eDataspaceChanged) {
+        if (layer->setDataspace(s.dataspace)) flags |= eTraversalNeeded;
@@ -1681,4 +2588,2 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+    if (what & layer_state_t::eHdrMetadataChanged) {
+        if (layer->setHdrMetadata(s.hdrMetadata)) flags |= eTraversalNeeded;
@@ -1685,0 +2591,2 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+    if (what & layer_state_t::eSurfaceDamageRegionChanged) {
+        if (layer->setSurfaceDamageRegion(s.surfaceDamageRegion)) flags |= eTraversalNeeded;
@@ -1687,4 +2594,2 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+    if (what & layer_state_t::eApiChanged) {
+        if (layer->setApi(s.api)) flags |= eTraversalNeeded;
@@ -1691,0 +2597,2 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+    if (what & layer_state_t::eSidebandStreamChanged) {
+        if (layer->setSidebandStream(s.sidebandStream)) flags |= eTraversalNeeded;
@@ -1693,4 +2600,6 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+    if (what & layer_state_t::eInputInfoChanged) {
+        if (privileged) {
+            layer->setInputInfo(s.inputInfo);
+            flags |= eTraversalNeeded;
+        } else {
+            ALOGE("Attempt to update InputWindowInfo without permission ACCESS_SURFACE_FLINGER");
@@ -1699,4 +2608,2 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+    if (what & layer_state_t::eMetadataChanged) {
+        if (layer->setMetadata(s.metadata)) flags |= eTraversalNeeded;
@@ -1703,0 +2611,3 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+    if (what & layer_state_t::eColorSpaceAgnosticChanged) {
+        if (layer->setColorSpaceAgnostic(s.colorSpaceAgnostic)) {
+            flags |= eTraversalNeeded;
@@ -1705,4 +2614,0 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
@@ -1709,0 +2616,5 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+    if (what & layer_state_t::eReparent) {
+        bool hadParent = layer->hasParent();
+        if (layer->reparent(s.parentHandleForChild)) {
+            if (!hadParent) {
+                mCurrentState.layersSortedByZ.remove(layer);
@@ -1711,4 +2622 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+            flags |= eTransactionNeeded | eTraversalNeeded;
@@ -1717,4 +2625,4 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+    std::vector<sp<CallbackHandle>> callbackHandles;
+    if ((what & layer_state_t::eHasListenerCallbacksChanged) && (!listenerCallbacks.empty())) {
+        for (const auto& [listener, callbackIds] : listenerCallbacks) {
+            callbackHandles.emplace_back(new CallbackHandle(listener, callbackIds, s.surface));
@@ -1723,4 +2631,13 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+    bool bufferChanged = what & layer_state_t::eBufferChanged;
+    bool cacheIdChanged = what & layer_state_t::eCachedBufferChanged;
+    sp<GraphicBuffer> buffer;
+    if (bufferChanged && cacheIdChanged && s.buffer != nullptr) {
+        buffer = s.buffer;
+        bool success = ClientCache::getInstance().add(s.cachedBuffer, s.buffer);
+        if (success) {
+            getRenderEngine().cacheExternalTextureBuffer(s.buffer);
+            success = ClientCache::getInstance()
+                              .registerErasedRecipient(s.cachedBuffer,
+                                                       wp<ClientCache::ErasedRecipient>(this));
+            if (!success) {
+                getRenderEngine().unbindExternalTextureBuffer(s.buffer->getId());
@@ -1729,4 +2646,4 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+    } else if (cacheIdChanged) {
+        buffer = ClientCache::getInstance().get(s.cachedBuffer);
+    } else if (bufferChanged) {
+        buffer = s.buffer;
@@ -1733,0 +2651,3 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+    if (buffer) {
+        if (layer->setBuffer(buffer, postTime, desiredPresentTime, s.cachedBuffer)) {
+            flags |= eTraversalNeeded;
@@ -1735,4 +2654,0 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
@@ -1739,0 +2656,2 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+    if (layer->setTransactionCompletedListeners(callbackHandles)) flags |= eTraversalNeeded;
+    return flags;
@@ -1741,4 +2659,4 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+uint32_t SurfaceFlinger::addInputWindowCommands(const InputWindowCommands& inputWindowCommands) {
+    uint32_t flags = 0;
+    if (!inputWindowCommands.transferTouchFocusCommands.empty()) {
+        flags |= eTraversalNeeded;
@@ -1745,0 +2664,2 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+    if (inputWindowCommands.syncInputWindows) {
+        flags |= eTraversalNeeded;
@@ -1747,4 +2667,2 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+    mPendingInputWindowCommands.merge(inputWindowCommands);
+    return flags;
@@ -1751,0 +2670,10 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+status_t SurfaceFlinger::createLayer(const String8& name, const sp<Client>& client, uint32_t w,
+                                     uint32_t h, PixelFormat format, uint32_t flags,
+                                     LayerMetadata metadata, sp<IBinder>* handle,
+                                     sp<IGraphicBufferProducer>* gbp,
+                                     const sp<IBinder>& parentHandle,
+                                     const sp<Layer>& parentLayer) {
+    if (int32_t(w|h) < 0) {
+        ALOGE("createLayer() failed, w or h is negative (w=%d, h=%d)",
+                int(w), int(h));
+        return BAD_VALUE;
@@ -1753,4 +2681,28 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+    ALOG_ASSERT(parentLayer == nullptr || parentHandle == nullptr,
+            "Expected only one of parentLayer or parentHandle to be non-null. "
+            "Programmer error?");
+    status_t result = NO_ERROR;
+    sp<Layer> layer;
+    String8 uniqueName = getUniqueLayerName(name);
+    bool primaryDisplayOnly = false;
+    if (metadata.has(METADATA_WINDOW_TYPE)) {
+        int32_t windowType = metadata.getInt32(METADATA_WINDOW_TYPE, 0);
+        if (windowType == 441731) {
+            metadata.setInt32(METADATA_WINDOW_TYPE, InputWindowInfo::TYPE_NAVIGATION_BAR_PANEL);
+            primaryDisplayOnly = true;
+        }
+    }
+    switch (flags & ISurfaceComposerClient::eFXSurfaceMask) {
+        case ISurfaceComposerClient::eFXSurfaceBufferQueue:
+            result = createBufferQueueLayer(client, uniqueName, w, h, flags, std::move(metadata),
+                                            format, handle, gbp, &layer);
+            break;
+        case ISurfaceComposerClient::eFXSurfaceBufferState:
+            result = createBufferStateLayer(client, uniqueName, w, h, flags, std::move(metadata),
+                                            handle, &layer);
+            break;
+        case ISurfaceComposerClient::eFXSurfaceColor:
+            if (w > 0 || h > 0) {
+                ALOGE("createLayer() failed, w or h cannot be set for color layer (w=%d, h=%d)",
+                      int(w), int(h));
+                return BAD_VALUE;
@@ -1757,0 +2710,8 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+            result = createColorLayer(client, uniqueName, w, h, flags, std::move(metadata), handle,
+                                      &layer);
+            break;
+        case ISurfaceComposerClient::eFXSurfaceContainer:
+            if (w > 0 || h > 0) {
+                ALOGE("createLayer() failed, w or h cannot be set for container layer (w=%d, h=%d)",
+                      int(w), int(h));
+                return BAD_VALUE;
@@ -1759,4 +2719,6 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+            result = createContainerLayer(client, uniqueName, w, h, flags, std::move(metadata),
+                                          handle, &layer);
+            break;
+        default:
+            result = BAD_VALUE;
+            break;
@@ -1763,0 +2726,2 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+    if (result != NO_ERROR) {
+        return result;
@@ -1765,4 +2729,2 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+    if (primaryDisplayOnly) {
+        layer->setPrimaryDisplayOnly();
@@ -1769,0 +2732,5 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+    bool addToCurrentState = callingThreadHasUnscopedSurfaceFlingerAccess();
+    result = addClientLayer(client, *handle, *gbp, layer, parentHandle, parentLayer,
+                            addToCurrentState);
+    if (result != NO_ERROR) {
+        return result;
@@ -1771,4 +2738,3 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+    mInterceptor->saveSurfaceCreation(layer);
+    setTransactionFlags(eTransactionNeeded);
+    return result;
@@ -1775,0 +2742,12 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+String8 SurfaceFlinger::getUniqueLayerName(const String8& name)
+{
+    bool matchFound = true;
+    uint32_t dupeCounter = 0;
+    String8 uniqueName = name + "#" + String8(std::to_string(dupeCounter).c_str());
+    Mutex::Autolock lock(mStateLock);
+    while (matchFound) {
+        matchFound = false;
+        mCurrentState.traverseInZOrder([&](Layer* layer) {
+            if (layer->getName() == uniqueName) {
+                matchFound = true;
+                uniqueName = name + "#" + String8(std::to_string(++dupeCounter).c_str());
@@ -1777,4 +2755 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+        });
@@ -1781,0 +2757,18 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+    ALOGV_IF(dupeCounter > 0, "duplicate layer name: changing %s to %s", name.c_str(),
+             uniqueName.c_str());
+    return uniqueName;
+}
+status_t SurfaceFlinger::createBufferQueueLayer(const sp<Client>& client, const String8& name,
+                                                uint32_t w, uint32_t h, uint32_t flags,
+                                                LayerMetadata metadata, PixelFormat& format,
+                                                sp<IBinder>* handle,
+                                                sp<IGraphicBufferProducer>* gbp,
+                                                sp<Layer>* outLayer) {
+    switch (format) {
+    case PIXEL_FORMAT_TRANSPARENT:
+    case PIXEL_FORMAT_TRANSLUCENT:
+        format = PIXEL_FORMAT_RGBA_8888;
+        break;
+    case PIXEL_FORMAT_OPAQUE:
+        format = PIXEL_FORMAT_RGBX_8888;
+        break;
@@ -1783,4 +2776,20 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+    sp<BufferQueueLayer> layer = getFactory().createBufferQueueLayer(
+            LayerCreationArgs(this, client, name, w, h, flags, std::move(metadata)));
+    status_t err = layer->setDefaultBufferProperties(w, h, format);
+    if (err == NO_ERROR) {
+        *handle = layer->getHandle();
+        *gbp = layer->getProducer();
+        *outLayer = layer;
+    }
+    ALOGE_IF(err, "createBufferQueueLayer() failed (%s)", strerror(-err));
+    return err;
+}
+status_t SurfaceFlinger::createBufferStateLayer(const sp<Client>& client, const String8& name,
+                                                uint32_t w, uint32_t h, uint32_t flags,
+                                                LayerMetadata metadata, sp<IBinder>* handle,
+                                                sp<Layer>* outLayer) {
+    sp<BufferStateLayer> layer = getFactory().createBufferStateLayer(
+            LayerCreationArgs(this, client, name, w, h, flags, std::move(metadata)));
+    *handle = layer->getHandle();
+    *outLayer = layer;
+    return NO_ERROR;
@@ -1787,0 +2797,7 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+status_t SurfaceFlinger::createColorLayer(const sp<Client>& client, const String8& name, uint32_t w,
+                                          uint32_t h, uint32_t flags, LayerMetadata metadata,
+                                          sp<IBinder>* handle, sp<Layer>* outLayer) {
+    *outLayer = getFactory().createColorLayer(
+            LayerCreationArgs(this, client, name, w, h, flags, std::move(metadata)));
+    *handle = (*outLayer)->getHandle();
+    return NO_ERROR;
@@ -1789,4 +2805,8 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+status_t SurfaceFlinger::createContainerLayer(const sp<Client>& client, const String8& name,
+                                              uint32_t w, uint32_t h, uint32_t flags,
+                                              LayerMetadata metadata, sp<IBinder>* handle,
+                                              sp<Layer>* outLayer) {
+    *outLayer = getFactory().createContainerLayer(
+            LayerCreationArgs(this, client, name, w, h, flags, std::move(metadata)));
+    *handle = (*outLayer)->getHandle();
+    return NO_ERROR;
@@ -1793,0 +2814,4 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+void SurfaceFlinger::markLayerPendingRemovalLocked(const sp<Layer>& layer) {
+    mLayersPendingRemoval.add(layer);
+    mLayersRemoved = true;
+    setTransactionFlags(eTransactionNeeded);
@@ -1795,4 +2819,13 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+void SurfaceFlinger::onHandleDestroyed(sp<Layer>& layer)
+{
+    Mutex::Autolock lock(mStateLock);
+    if (layer->getParent() == nullptr) {
+        mCurrentState.layersSortedByZ.remove(layer);
+    }
+    markLayerPendingRemovalLocked(layer);
+    auto it = mLayersByLocalBinderToken.begin();
+    while (it != mLayersByLocalBinderToken.end()) {
+        if (it->second == layer) {
+            it = mLayersByLocalBinderToken.erase(it);
+        } else {
+            it++;
@@ -1801,4 +2834 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+    layer.clear();
@@ -1805,0 +2836,39 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+void SurfaceFlinger::onInitializeDisplays() {
+    const auto display = getDefaultDisplayDeviceLocked();
+    if (!display) return;
+    const sp<IBinder> token = display->getDisplayToken().promote();
+    LOG_ALWAYS_FATAL_IF(token == nullptr);
+    Vector<ComposerState> state;
+    Vector<DisplayState> displays;
+    DisplayState d;
+    d.what = DisplayState::eDisplayProjectionChanged |
+             DisplayState::eLayerStackChanged;
+    d.token = token;
+    d.layerStack = 0;
+    d.orientation = DisplayState::eOrientationDefault;
+    d.frame.makeInvalid();
+    d.viewport.makeInvalid();
+    d.width = 0;
+    d.height = 0;
+    displays.add(d);
+    setTransactionState(state, displays, 0, nullptr, mPendingInputWindowCommands, -1, {}, {});
+    setPowerModeInternal(display, HWC_POWER_MODE_NORMAL);
+    const nsecs_t vsyncPeriod = getVsyncPeriod();
+    mAnimFrameTracker.setDisplayRefreshPeriod(vsyncPeriod);
+    DisplayStatInfo stats{0 , vsyncPeriod};
+    setCompositorTimingSnapped(stats, 0);
+}
+void SurfaceFlinger::initializeDisplays() {
+    postMessageAsync(
+            new LambdaMessage([this]() NO_THREAD_SAFETY_ANALYSIS { onInitializeDisplays(); }));
+}
+void SurfaceFlinger::setVsyncEnabledInHWC(DisplayId displayId, HWC2::Vsync enabled) {
+    if (mHWCVsyncState != enabled) {
+        getHwComposer().setVsyncEnabled(displayId, enabled);
+        mHWCVsyncState = enabled;
+    }
+}
+void SurfaceFlinger::setPowerModeInternal(const sp<DisplayDevice>& display, int mode) {
+    if (display->isVirtual()) {
+        ALOGE("%s: Invalid operation on virtual display", __FUNCTION__);
+        return;
@@ -1807,4 +2876,6 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+    const auto displayId = display->getId();
+    LOG_ALWAYS_FATAL_IF(!displayId);
+    ALOGD("Setting power mode %d on display %s", mode, to_string(*displayId).c_str());
+    int currentMode = display->getPowerMode();
+    if (mode == currentMode) {
+        return;
@@ -1811,0 +2883,3 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+    display->setPowerMode(mode);
+    if (mInterceptor->isEnabled()) {
+        mInterceptor->savePowerModeUpdate(display->getSequenceId(), mode);
@@ -1813,4 +2887,6 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+    if (currentMode == HWC_POWER_MODE_OFF) {
+        getHwComposer().setPowerMode(*displayId, mode);
+        if (display->isPrimary() && mode != HWC_POWER_MODE_DOZE_SUSPEND) {
+            setVsyncEnabledInHWC(*displayId, mHWCVsyncPendingState);
+            mScheduler->onScreenAcquired(mAppConnectionHandle);
+            mScheduler->resyncToHardwareVsync(true, getVsyncPeriod());
@@ -1817,0 +2894,26 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+        mVisibleRegionsDirty = true;
+        mHasPoweredOff = true;
+        repaintEverything();
+        struct sched_param param = {0};
+        param.sched_priority = 1;
+        if (sched_setscheduler(0, SCHED_FIFO, &param) != 0) {
+            ALOGW("Couldn't set SCHED_FIFO on display on");
+        }
+    } else if (mode == HWC_POWER_MODE_OFF) {
+        struct sched_param param = {0};
+        if (sched_setscheduler(0, SCHED_OTHER, &param) != 0) {
+            ALOGW("Couldn't set SCHED_OTHER on display off");
+        }
+        if (display->isPrimary() && currentMode != HWC_POWER_MODE_DOZE_SUSPEND) {
+            mScheduler->disableHardwareVsync(true);
+            mScheduler->onScreenReleased(mAppConnectionHandle);
+        }
+        setVsyncEnabledInHWC(*displayId, HWC2::Vsync::Disable);
+        getHwComposer().setPowerMode(*displayId, mode);
+        mVisibleRegionsDirty = true;
+    } else if (mode == HWC_POWER_MODE_DOZE ||
+               mode == HWC_POWER_MODE_NORMAL) {
+        getHwComposer().setPowerMode(*displayId, mode);
+        if (display->isPrimary() && currentMode == HWC_POWER_MODE_DOZE_SUSPEND) {
+            mScheduler->onScreenAcquired(mAppConnectionHandle);
+            mScheduler->resyncToHardwareVsync(true, getVsyncPeriod());
@@ -1819,4 +2921,4 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+    } else if (mode == HWC_POWER_MODE_DOZE_SUSPEND) {
+        if (display->isPrimary()) {
+            mScheduler->disableHardwareVsync(true);
+            mScheduler->onScreenReleased(mAppConnectionHandle);
@@ -1823,0 +2926,4 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+        getHwComposer().setPowerMode(*displayId, mode);
+    } else {
+        ALOGE("Attempting to set unknown power mode: %d\n", mode);
+        getHwComposer().setPowerMode(*displayId, mode);
@@ -1825,4 +2931,4 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+    if (display->isPrimary()) {
+        mTimeStats->setPowerMode(mode);
+        mRefreshRateStats.setPowerMode(mode);
+        mScheduler->setDisplayPowerState(mode == HWC_POWER_MODE_NORMAL);
@@ -1829,0 +2936 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+    ALOGD("Finished setting power mode %d on display %s", mode, to_string(*displayId).c_str());
@@ -1831,4 +2938,10 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+void SurfaceFlinger::setPowerMode(const sp<IBinder>& displayToken, int mode) {
+    postMessageSync(new LambdaMessage([&]() NO_THREAD_SAFETY_ANALYSIS {
+        const auto display = getDisplayDevice(displayToken);
+        if (!display) {
+            ALOGE("Attempt to set power mode %d for invalid display token %p", mode,
+                  displayToken.get());
+        } else if (display->isVirtual()) {
+            ALOGW("Attempt to set power mode %d for virtual display", mode);
+        } else {
+            setPowerModeInternal(display, mode);
@@ -1835,0 +2949 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+    }));
@@ -1837,4 +2951,42 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+status_t SurfaceFlinger::doDump(int fd, const DumpArgs& args,
+                                bool asProto) NO_THREAD_SAFETY_ANALYSIS {
+    std::string result;
+    IPCThreadState* ipc = IPCThreadState::self();
+    const int pid = ipc->getCallingPid();
+    const int uid = ipc->getCallingUid();
+    if ((uid != AID_SHELL) &&
+            !PermissionCache::checkPermission(sDump, pid, uid)) {
+        StringAppendF(&result, "Permission Denial: can't dump SurfaceFlinger from pid=%d, uid=%d\n",
+                      pid, uid);
+    } else {
+        status_t err = mStateLock.timedLock(s2ns(1));
+        bool locked = (err == NO_ERROR);
+        if (!locked) {
+            StringAppendF(&result,
+                          "SurfaceFlinger appears to be unresponsive (%s [%d]), dumping anyways "
+                          "(no locks held)\n",
+                          strerror(-err), err);
+        }
+        using namespace std::string_literals;
+        static const std::unordered_map<std::string, Dumper> dumpers = {
+                {"--display-id"s, dumper(&SurfaceFlinger::dumpDisplayIdentificationData)},
+                {"--dispsync"s,
+                 dumper([this](std::string& s) { mScheduler->getPrimaryDispSync().dump(s); })},
+                {"--frame-events"s, dumper(&SurfaceFlinger::dumpFrameEventsLocked)},
+                {"--latency"s, argsDumper(&SurfaceFlinger::dumpStatsLocked)},
+                {"--latency-clear"s, argsDumper(&SurfaceFlinger::clearStatsLocked)},
+                {"--list"s, dumper(&SurfaceFlinger::listLayersLocked)},
+                {"--static-screen"s, dumper(&SurfaceFlinger::dumpStaticScreenStats)},
+                {"--timestats"s, protoDumper(&SurfaceFlinger::dumpTimeStats)},
+                {"--vsync"s, dumper(&SurfaceFlinger::dumpVSync)},
+                {"--wide-color"s, dumper(&SurfaceFlinger::dumpWideColorInfo)},
+        };
+        const auto flag = args.empty() ? ""s : std::string(String8(args[0]));
+        const auto it = dumpers.find(flag);
+        if (it != dumpers.end()) {
+            (it->second)(args, asProto, result);
+        } else if (!asProto) {
+            dumpAllLocked(args, result);
+        }
+        if (locked) {
+            mStateLock.unlock();
@@ -1841,0 +2994,9 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+        if (it == dumpers.end()) {
+            const LayersProto layersProto = dumpProtoFromMainThread();
+            if (asProto) {
+                result.append(layersProto.SerializeAsString());
+            } else {
+                const auto layerTree = LayerProtoParser::generateLayerTree(layersProto);
+                result.append(LayerProtoParser::layerTreeToString(layerTree));
+                result.append("\n");
+                dumpOffscreenLayers(result);
@@ -1843,4 +3003,0 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
@@ -1849,4 +3006,2 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+    write(fd, result.c_str(), result.size());
+    return NO_ERROR;
@@ -1853,0 +3009,3 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+status_t SurfaceFlinger::dumpCritical(int fd, const DumpArgs&, bool asProto) {
+    if (asProto && mTracing.isEnabled()) {
+        mTracing.writeToFileAsync();
@@ -1855,4 +3013 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
-void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent configEvent) {
-    std::lock_guard<std::mutex> lock(mCallbackLock);
-    if (mChangeRefreshRateCallback) {
-        mChangeRefreshRateCallback(refreshRateType, configEvent);
+    return doDump(fd, DumpArgs(), asProto);
@@ -1859,0 +3015,797 @@ void Scheduler::changeRefreshRate(RefreshRateType refreshRateType, ConfigEvent c
+void SurfaceFlinger::listLayersLocked(std::string& result) const {
+    mCurrentState.traverseInZOrder(
+            [&](Layer* layer) { StringAppendF(&result, "%s\n", layer->getName().string()); });
+}
+void SurfaceFlinger::dumpStatsLocked(const DumpArgs& args, std::string& result) const {
+    StringAppendF(&result, "%" PRId64 "\n", getVsyncPeriod());
+    if (args.size() > 1) {
+        const auto name = String8(args[1]);
+        mCurrentState.traverseInZOrder([&](Layer* layer) {
+            if (name == layer->getName()) {
+                layer->dumpFrameStats(result);
+            }
+        });
+    } else {
+        mAnimFrameTracker.dumpStats(result);
+    }
+}
+void SurfaceFlinger::clearStatsLocked(const DumpArgs& args, std::string&) {
+    mCurrentState.traverseInZOrder([&](Layer* layer) {
+        if (args.size() < 2 || String8(args[1]) == layer->getName()) {
+            layer->clearFrameStats();
+        }
+    });
+    mAnimFrameTracker.clearStats();
+}
+void SurfaceFlinger::dumpTimeStats(const DumpArgs& args, bool asProto, std::string& result) const {
+    mTimeStats->parseArgs(asProto, args, result);
+}
+void SurfaceFlinger::logFrameStats() {
+    mDrawingState.traverseInZOrder([&](Layer* layer) {
+        layer->logFrameStats();
+    });
+    mAnimFrameTracker.logAndResetStats(String8("<win-anim>"));
+}
+void SurfaceFlinger::appendSfConfigString(std::string& result) const {
+    result.append(" [sf");
+    if (isLayerTripleBufferingDisabled())
+        result.append(" DISABLE_TRIPLE_BUFFERING");
+    StringAppendF(&result, " PRESENT_TIME_OFFSET=%" PRId64, dispSyncPresentTimeOffset);
+    StringAppendF(&result, " FORCE_HWC_FOR_RBG_TO_YUV=%d", useHwcForRgbToYuv);
+    StringAppendF(&result, " MAX_VIRT_DISPLAY_DIM=%" PRIu64, maxVirtualDisplaySize);
+    StringAppendF(&result, " RUNNING_WITHOUT_SYNC_FRAMEWORK=%d", !hasSyncFramework);
+    StringAppendF(&result, " NUM_FRAMEBUFFER_SURFACE_BUFFERS=%" PRId64,
+                  maxFrameBufferAcquiredBuffers);
+    result.append("]");
+}
+void SurfaceFlinger::dumpVSync(std::string& result) const {
+    mScheduler->dump(result);
+    StringAppendF(&result, "+  Smart video mode: %s\n\n", mUseSmart90ForVideo ? "on" : "off");
+    mRefreshRateStats.dump(result);
+    result.append("\n");
+    mPhaseOffsets->dump(result);
+    StringAppendF(&result,
+                  "      present offset: %9" PRId64 " ns\t     VSYNC period: %9" PRId64 " ns\n\n",
+                  dispSyncPresentTimeOffset, getVsyncPeriod());
+    StringAppendF(&result, "Allowed Display Configs: ");
+    for (const auto& [type, rate] : mRefreshRateConfigs.getRefreshRates()) {
+        if (rate && isDisplayConfigAllowed(rate->configId)) {
+            StringAppendF(&result, "%" PRIu32 " Hz, ", rate->fps);
+        }
+    }
+    StringAppendF(&result, "(config override by backdoor: %s)\n\n",
+                  mDebugDisplayConfigSetByBackdoor ? "yes" : "no");
+    mScheduler->dump(mAppConnectionHandle, result);
+}
+void SurfaceFlinger::dumpStaticScreenStats(std::string& result) const {
+    result.append("Static screen stats:\n");
+    for (size_t b = 0; b < SurfaceFlingerBE::NUM_BUCKETS - 1; ++b) {
+        float bucketTimeSec = getBE().mFrameBuckets[b] / 1e9;
+        float percent = 100.0f *
+                static_cast<float>(getBE().mFrameBuckets[b]) / getBE().mTotalTime;
+        StringAppendF(&result, "  < %zd frames: %.3f s (%.1f%%)\n", b + 1, bucketTimeSec, percent);
+    }
+    float bucketTimeSec = getBE().mFrameBuckets[SurfaceFlingerBE::NUM_BUCKETS - 1] / 1e9;
+    float percent = 100.0f *
+            static_cast<float>(getBE().mFrameBuckets[SurfaceFlingerBE::NUM_BUCKETS - 1]) / getBE().mTotalTime;
+    StringAppendF(&result, "  %zd+ frames: %.3f s (%.1f%%)\n", SurfaceFlingerBE::NUM_BUCKETS - 1,
+                  bucketTimeSec, percent);
+}
+void SurfaceFlinger::recordBufferingStats(const char* layerName,
+        std::vector<OccupancyTracker::Segment>&& history) {
+    Mutex::Autolock lock(getBE().mBufferingStatsMutex);
+    auto& stats = getBE().mBufferingStats[layerName];
+    for (const auto& segment : history) {
+        if (!segment.usedThirdBuffer) {
+            stats.twoBufferTime += segment.totalTime;
+        }
+        if (segment.occupancyAverage < 1.0f) {
+            stats.doubleBufferedTime += segment.totalTime;
+        } else if (segment.occupancyAverage < 2.0f) {
+            stats.tripleBufferedTime += segment.totalTime;
+        }
+        ++stats.numSegments;
+        stats.totalTime += segment.totalTime;
+    }
+}
+void SurfaceFlinger::dumpFrameEventsLocked(std::string& result) {
+    result.append("Layer frame timestamps:\n");
+    const LayerVector& currentLayers = mCurrentState.layersSortedByZ;
+    const size_t count = currentLayers.size();
+    for (size_t i=0 ; i<count ; i++) {
+        currentLayers[i]->dumpFrameEvents(result);
+    }
+}
+void SurfaceFlinger::dumpBufferingStats(std::string& result) const {
+    result.append("Buffering stats:\n");
+    result.append("  [Layer name] <Active time> <Two buffer> "
+            "<Double buffered> <Triple buffered>\n");
+    Mutex::Autolock lock(getBE().mBufferingStatsMutex);
+    typedef std::tuple<std::string, float, float, float> BufferTuple;
+    std::map<float, BufferTuple, std::greater<float>> sorted;
+    for (const auto& statsPair : getBE().mBufferingStats) {
+        const char* name = statsPair.first.c_str();
+        const SurfaceFlingerBE::BufferingStats& stats = statsPair.second;
+        if (stats.numSegments == 0) {
+            continue;
+        }
+        float activeTime = ns2ms(stats.totalTime) / 1000.0f;
+        float twoBufferRatio = static_cast<float>(stats.twoBufferTime) /
+                stats.totalTime;
+        float doubleBufferRatio = static_cast<float>(
+                stats.doubleBufferedTime) / stats.totalTime;
+        float tripleBufferRatio = static_cast<float>(
+                stats.tripleBufferedTime) / stats.totalTime;
+        sorted.insert({activeTime, {name, twoBufferRatio,
+                doubleBufferRatio, tripleBufferRatio}});
+    }
+    for (const auto& sortedPair : sorted) {
+        float activeTime = sortedPair.first;
+        const BufferTuple& values = sortedPair.second;
+        StringAppendF(&result, "  [%s] %.2f %.3f %.3f %.3f\n", std::get<0>(values).c_str(),
+                      activeTime, std::get<1>(values), std::get<2>(values), std::get<3>(values));
+    }
+    result.append("\n");
+}
+void SurfaceFlinger::dumpDisplayIdentificationData(std::string& result) const {
+    for (const auto& [token, display] : mDisplays) {
+        const auto displayId = display->getId();
+        if (!displayId) {
+            continue;
+        }
+        const auto hwcDisplayId = getHwComposer().fromPhysicalDisplayId(*displayId);
+        if (!hwcDisplayId) {
+            continue;
+        }
+        StringAppendF(&result,
+                      "Display %s (HWC display %" PRIu64 "): ", to_string(*displayId).c_str(),
+                      *hwcDisplayId);
+        uint8_t port;
+        DisplayIdentificationData data;
+        if (!getHwComposer().getDisplayIdentificationData(*hwcDisplayId, &port, &data)) {
+            result.append("no identification data\n");
+            continue;
+        }
+        if (!isEdid(data)) {
+            result.append("unknown identification data: ");
+            for (uint8_t byte : data) {
+                StringAppendF(&result, "%x ", byte);
+            }
+            result.append("\n");
+            continue;
+        }
+        const auto edid = parseEdid(data);
+        if (!edid) {
+            result.append("invalid EDID: ");
+            for (uint8_t byte : data) {
+                StringAppendF(&result, "%x ", byte);
+            }
+            result.append("\n");
+            continue;
+        }
+        StringAppendF(&result, "port=%u pnpId=%s displayName=\"", port, edid->pnpId.data());
+        result.append(edid->displayName.data(), edid->displayName.length());
+        result.append("\"\n");
+    }
+}
+void SurfaceFlinger::dumpWideColorInfo(std::string& result) const {
+    StringAppendF(&result, "Device has wide color built-in display: %d\n", hasWideColorDisplay);
+    StringAppendF(&result, "Device uses color management: %d\n", useColorManagement);
+    StringAppendF(&result, "DisplayColorSetting: %s\n",
+                  decodeDisplayColorSetting(mDisplayColorSetting).c_str());
+    for (const auto& [token, display] : mDisplays) {
+        const auto displayId = display->getId();
+        if (!displayId) {
+            continue;
+        }
+        StringAppendF(&result, "Display %s color modes:\n", to_string(*displayId).c_str());
+        std::vector<ColorMode> modes = getHwComposer().getColorModes(*displayId);
+        for (auto&& mode : modes) {
+            StringAppendF(&result, "    %s (%d)\n", decodeColorMode(mode).c_str(), mode);
+        }
+        ColorMode currentMode = display->getCompositionDisplay()->getState().colorMode;
+        StringAppendF(&result, "    Current color mode: %s (%d)\n",
+                      decodeColorMode(currentMode).c_str(), currentMode);
+    }
+    result.append("\n");
+}
+LayersProto SurfaceFlinger::dumpDrawingStateProto(uint32_t traceFlags) const {
+    LayersProto layersProto;
+    mDrawingState.traverseInZOrder([&](Layer* layer) {
+        LayerProto* layerProto = layersProto.add_layers();
+        layer->writeToProtoDrawingState(layerProto, traceFlags);
+        layer->writeToProtoCommonState(layerProto, LayerVector::StateSet::Drawing, traceFlags);
+    });
+    return layersProto;
+}
+void SurfaceFlinger::dumpOffscreenLayersProto(LayersProto& layersProto, uint32_t traceFlags) const {
+    LayerProto* rootProto = layersProto.add_layers();
+    const int32_t offscreenRootLayerId = INT32_MAX - 2;
+    rootProto->set_id(offscreenRootLayerId);
+    rootProto->set_name("Offscreen Root");
+    for (Layer* offscreenLayer : mOffscreenLayers) {
+        rootProto->add_children(offscreenLayer->sequence);
+        LayerProto* layerProto = layersProto.add_layers();
+        offscreenLayer->writeToProtoDrawingState(layerProto, traceFlags);
+        offscreenLayer->writeToProtoCommonState(layerProto, LayerVector::StateSet::Drawing,
+                                                traceFlags);
+        layerProto->set_parent(offscreenRootLayerId);
+        offscreenLayer->traverseInZOrder(LayerVector::StateSet::Drawing, [&](Layer* layer) {
+            if (layer == offscreenLayer) {
+                return;
+            }
+            LayerProto* childProto = layersProto.add_layers();
+            layer->writeToProtoDrawingState(childProto, traceFlags);
+            layer->writeToProtoCommonState(childProto, LayerVector::StateSet::Drawing, traceFlags);
+        });
+    }
+}
+LayersProto SurfaceFlinger::dumpProtoFromMainThread(uint32_t traceFlags) {
+    LayersProto layersProto;
+    postMessageSync(new LambdaMessage([&]() { layersProto = dumpDrawingStateProto(traceFlags); }));
+    return layersProto;
+}
+void SurfaceFlinger::dumpOffscreenLayers(std::string& result) {
+    result.append("Offscreen Layers:\n");
+    postMessageSync(new LambdaMessage([&]() {
+        for (Layer* offscreenLayer : mOffscreenLayers) {
+            offscreenLayer->traverseInZOrder(LayerVector::StateSet::Drawing, [&](Layer* layer) {
+                layer->dumpCallingUidPid(result);
+            });
+        }
+    }));
+}
+void SurfaceFlinger::dumpAllLocked(const DumpArgs& args, std::string& result) const {
+    const bool colorize = !args.empty() && args[0] == String16("--color");
+    Colorizer colorizer(colorize);
+    const nsecs_t now = systemTime();
+    const nsecs_t inTransaction(mDebugInTransaction);
+    nsecs_t inTransactionDuration = (inTransaction) ? now-inTransaction : 0;
+    colorizer.bold(result);
+    result.append("Build configuration:");
+    colorizer.reset(result);
+    appendSfConfigString(result);
+    appendUiConfigString(result);
+    appendGuiConfigString(result);
+    result.append("\n");
+    result.append("\nDisplay identification data:\n");
+    dumpDisplayIdentificationData(result);
+    result.append("\nWide-Color information:\n");
+    dumpWideColorInfo(result);
+    colorizer.bold(result);
+    result.append("Sync configuration: ");
+    colorizer.reset(result);
+    result.append(SyncFeatures::getInstance().toString());
+    result.append("\n\n");
+    colorizer.bold(result);
+    result.append("Scheduler:\n");
+    colorizer.reset(result);
+    dumpVSync(result);
+    result.append("\n");
+    dumpStaticScreenStats(result);
+    result.append("\n");
+    StringAppendF(&result, "Total missed frame count: %u\n", mFrameMissedCount.load());
+    StringAppendF(&result, "HWC missed frame count: %u\n", mHwcFrameMissedCount.load());
+    StringAppendF(&result, "GPU missed frame count: %u\n\n", mGpuFrameMissedCount.load());
+    dumpBufferingStats(result);
+    colorizer.bold(result);
+    StringAppendF(&result, "Visible layers (count = %zu)\n", mNumLayers.load());
+    StringAppendF(&result, "GraphicBufferProducers: %zu, max %zu\n",
+                  mGraphicBufferProducerList.size(), mMaxGraphicBufferProducerListSize);
+    colorizer.reset(result);
+    {
+        StringAppendF(&result, "Composition layers\n");
+        mDrawingState.traverseInZOrder([&](Layer* layer) {
+            auto compositionLayer = layer->getCompositionLayer();
+            if (compositionLayer) compositionLayer->dump(result);
+        });
+    }
+    colorizer.bold(result);
+    StringAppendF(&result, "Displays (%zu entries)\n", mDisplays.size());
+    colorizer.reset(result);
+    for (const auto& [token, display] : mDisplays) {
+        display->dump(result);
+    }
+    result.append("\n");
+    colorizer.bold(result);
+    result.append("SurfaceFlinger global state:\n");
+    colorizer.reset(result);
+    getRenderEngine().dump(result);
+    DebugEGLImageTracker::getInstance()->dump(result);
+    if (const auto display = getDefaultDisplayDeviceLocked()) {
+        display->getCompositionDisplay()->getState().undefinedRegion.dump(result,
+                                                                          "undefinedRegion");
+        StringAppendF(&result, "  orientation=%d, isPoweredOn=%d\n", display->getOrientation(),
+                      display->isPoweredOn());
+    }
+    StringAppendF(&result,
+                  "  transaction-flags         : %08x\n"
+                  "  gpu_to_cpu_unsupported    : %d\n",
+                  mTransactionFlags.load(), !mGpuToCpuSupported);
+    if (const auto displayId = getInternalDisplayIdLocked();
+        displayId && getHwComposer().isConnected(*displayId)) {
+        const auto activeConfig = getHwComposer().getActiveConfig(*displayId);
+        StringAppendF(&result,
+                      "  refresh-rate              : %f fps\n"
+                      "  x-dpi                     : %f\n"
+                      "  y-dpi                     : %f\n",
+                      1e9 / activeConfig->getVsyncPeriod(), activeConfig->getDpiX(),
+                      activeConfig->getDpiY());
+    }
+    StringAppendF(&result, "  transaction time: %f us\n", inTransactionDuration / 1000.0);
+    mTracing.dump(result);
+    result.append("\n");
+    for (const auto& [token, display] : mDisplays) {
+        const auto displayId = display->getId();
+        if (!displayId) {
+            continue;
+        }
+        StringAppendF(&result, "Display %s HWC layers:\n", to_string(*displayId).c_str());
+        Layer::miniDumpHeader(result);
+        const sp<DisplayDevice> displayDevice = display;
+        mCurrentState.traverseInZOrder(
+                [&](Layer* layer) { layer->miniDump(result, displayDevice); });
+        result.append("\n");
+    }
+    colorizer.bold(result);
+    result.append("h/w composer state:\n");
+    colorizer.reset(result);
+    bool hwcDisabled = mDebugDisableHWC || mDebugRegion;
+    StringAppendF(&result, "  h/w composer %s\n", hwcDisabled ? "disabled" : "enabled");
+    getHwComposer().dump(result);
+    const GraphicBufferAllocator& alloc(GraphicBufferAllocator::get());
+    alloc.dump(result);
+    if (mVrFlingerRequestsDisplay && mVrFlinger) {
+        result.append("VrFlinger state:\n");
+        result.append(mVrFlinger->Dump());
+        result.append("\n");
+    }
+    result.append(mTimeStats->miniDump());
+    result.append("\n");
+}
+void SurfaceFlinger::updateColorMatrixLocked() {
+    mat4 colorMatrix;
+    if (mGlobalSaturationFactor != 1.0f) {
+        float3 luminance{0.213f, 0.715f, 0.072f};
+        luminance *= 1.0f - mGlobalSaturationFactor;
+        mat4 saturationMatrix = mat4(
+            vec4{luminance.r + mGlobalSaturationFactor, luminance.r, luminance.r, 0.0f},
+            vec4{luminance.g, luminance.g + mGlobalSaturationFactor, luminance.g, 0.0f},
+            vec4{luminance.b, luminance.b, luminance.b + mGlobalSaturationFactor, 0.0f},
+            vec4{0.0f, 0.0f, 0.0f, 1.0f}
+        );
+        colorMatrix = mClientColorMatrix * saturationMatrix * mDaltonizer();
+    } else {
+        colorMatrix = mClientColorMatrix * mDaltonizer();
+    }
+    if (mCurrentState.colorMatrix != colorMatrix) {
+        mCurrentState.colorMatrix = colorMatrix;
+        mCurrentState.colorMatrixChanged = true;
+        setTransactionFlags(eTransactionNeeded);
+    }
+}
+status_t SurfaceFlinger::CheckTransactCodeCredentials(uint32_t code) {
+#pragma clang diagnostic push
+#pragma clang diagnostic error "-Wswitch-enum"
+    switch (static_cast<ISurfaceComposerTag>(code)) {
+        case BOOT_FINISHED:
+        case CLEAR_ANIMATION_FRAME_STATS:
+        case CREATE_DISPLAY:
+        case DESTROY_DISPLAY:
+        case ENABLE_VSYNC_INJECTIONS:
+        case GET_ANIMATION_FRAME_STATS:
+        case GET_HDR_CAPABILITIES:
+        case SET_ACTIVE_CONFIG:
+        case SET_ALLOWED_DISPLAY_CONFIGS:
+        case GET_ALLOWED_DISPLAY_CONFIGS:
+        case SET_ACTIVE_COLOR_MODE:
+        case INJECT_VSYNC:
+        case SET_POWER_MODE:
+        case GET_DISPLAYED_CONTENT_SAMPLING_ATTRIBUTES:
+        case SET_DISPLAY_CONTENT_SAMPLING_ENABLED:
+        case GET_DISPLAYED_CONTENT_SAMPLE:
+        case NOTIFY_POWER_HINT: {
+            if (!callingThreadHasUnscopedSurfaceFlingerAccess()) {
+                IPCThreadState* ipc = IPCThreadState::self();
+                ALOGE("Permission Denial: can't access SurfaceFlinger pid=%d, uid=%d",
+                        ipc->getCallingPid(), ipc->getCallingUid());
+                return PERMISSION_DENIED;
+            }
+            return OK;
+        }
+        case GET_LAYER_DEBUG_INFO: {
+            IPCThreadState* ipc = IPCThreadState::self();
+            const int pid = ipc->getCallingPid();
+            const int uid = ipc->getCallingUid();
+            if ((uid != AID_SHELL) && !PermissionCache::checkPermission(sDump, pid, uid)) {
+                ALOGE("Layer debug info permission denied for pid=%d, uid=%d", pid, uid);
+                return PERMISSION_DENIED;
+            }
+            return OK;
+        }
+        case CREATE_DISPLAY_EVENT_CONNECTION:
+        case AUTHENTICATE_SURFACE:
+        case GET_ACTIVE_COLOR_MODE:
+        case GET_ACTIVE_CONFIG:
+        case GET_PHYSICAL_DISPLAY_IDS:
+        case GET_PHYSICAL_DISPLAY_TOKEN:
+        case GET_DISPLAY_COLOR_MODES:
+        case GET_DISPLAY_NATIVE_PRIMARIES:
+        case GET_DISPLAY_CONFIGS:
+        case GET_DISPLAY_STATS:
+        case GET_SUPPORTED_FRAME_TIMESTAMPS:
+        case SET_TRANSACTION_STATE:
+        case CREATE_CONNECTION:
+        case GET_COLOR_MANAGEMENT:
+        case GET_COMPOSITION_PREFERENCE:
+        case GET_PROTECTED_CONTENT_SUPPORT:
+        case IS_WIDE_COLOR_DISPLAY:
+        case GET_DISPLAY_BRIGHTNESS_SUPPORT:
+        case SET_DISPLAY_BRIGHTNESS: {
+            return OK;
+        }
+        case CAPTURE_LAYERS: {
+            IPCThreadState* ipc = IPCThreadState::self();
+            const int pid = ipc->getCallingPid();
+            const int uid = ipc->getCallingUid();
+            if ((uid != AID_GRAPHICS && uid != AID_MEDIA) &&
+                !PermissionCache::checkPermission(sReadFramebuffer, pid, uid)) {
+                ALOGE("Permission Denial: can't capture layer pid=%d, uid=%d", pid, uid);
+                return PERMISSION_DENIED;
+            }
+            return OK;
+        }
+        case CAPTURE_SCREEN:
+        case ADD_REGION_SAMPLING_LISTENER:
+        case REMOVE_REGION_SAMPLING_LISTENER: {
+            IPCThreadState* ipc = IPCThreadState::self();
+            const int pid = ipc->getCallingPid();
+            const int uid = ipc->getCallingUid();
+            if ((uid != AID_GRAPHICS) &&
+                !PermissionCache::checkPermission(sReadFramebuffer, pid, uid)) {
+                ALOGE("Permission Denial: can't read framebuffer pid=%d, uid=%d", pid, uid);
+                return PERMISSION_DENIED;
+            }
+            return OK;
+        }
+        case CONNECT_DISPLAY_UNUSED:
+        case CREATE_GRAPHIC_BUFFER_ALLOC_UNUSED: {
+            ALOGE("Attempting to access SurfaceFlinger with unused code: %u", code);
+            return PERMISSION_DENIED;
+        }
+        case CAPTURE_SCREEN_BY_ID: {
+            IPCThreadState* ipc = IPCThreadState::self();
+            const int uid = ipc->getCallingUid();
+            if (uid == AID_ROOT || uid == AID_GRAPHICS || uid == AID_SYSTEM || uid == AID_SHELL) {
+                return OK;
+            }
+            return PERMISSION_DENIED;
+        }
+    }
+    if (code == IBinder::INTERFACE_TRANSACTION || code == IBinder::DUMP_TRANSACTION ||
+        code == IBinder::PING_TRANSACTION || code == IBinder::SHELL_COMMAND_TRANSACTION ||
+        code == IBinder::SYSPROPS_TRANSACTION) {
+        return OK;
+    }
+    if (code >= 1000 && code <= 1035) {
+        ALOGV("Accessing SurfaceFlinger through backdoor code: %u", code);
+        return OK;
+    }
+    ALOGE("Permission Denial: SurfaceFlinger did not recognize request code: %u", code);
+    return PERMISSION_DENIED;
+#pragma clang diagnostic pop
+}
+status_t SurfaceFlinger::onTransact(uint32_t code, const Parcel& data, Parcel* reply,
+                                    uint32_t flags) {
+    status_t credentialCheck = CheckTransactCodeCredentials(code);
+    if (credentialCheck != OK) {
+        return credentialCheck;
+    }
+    status_t err = BnSurfaceComposer::onTransact(code, data, reply, flags);
+    if (err == UNKNOWN_TRANSACTION || err == PERMISSION_DENIED) {
+        CHECK_INTERFACE(ISurfaceComposer, data, reply);
+        IPCThreadState* ipc = IPCThreadState::self();
+        const int uid = ipc->getCallingUid();
+        if (CC_UNLIKELY(uid != AID_SYSTEM
+                && !PermissionCache::checkCallingPermission(sHardwareTest))) {
+            const int pid = ipc->getCallingPid();
+            ALOGE("Permission Denial: "
+                    "can't access SurfaceFlinger pid=%d, uid=%d", pid, uid);
+            return PERMISSION_DENIED;
+        }
+        int n;
+        switch (code) {
+            case 1000:
+            case 1001:
+                return NO_ERROR;
+            case 1002:
+                n = data.readInt32();
+                mDebugRegion = n ? n : (mDebugRegion ? 0 : 1);
+                invalidateHwcGeometry();
+                repaintEverything();
+                return NO_ERROR;
+            case 1004:{
+                repaintEverything();
+                return NO_ERROR;
+            }
+            case 1005:{
+                Mutex::Autolock _l(mStateLock);
+                setTransactionFlags(
+                        eTransactionNeeded|
+                        eDisplayTransactionNeeded|
+                        eTraversalNeeded);
+                return NO_ERROR;
+            }
+            case 1006:{
+                signalRefresh();
+                return NO_ERROR;
+            }
+            case 1008:
+                n = data.readInt32();
+                mDebugDisableHWC = n != 0;
+                invalidateHwcGeometry();
+                repaintEverything();
+                return NO_ERROR;
+            case 1009:
+                n = data.readInt32();
+                mDebugDisableTransformHint = n != 0;
+                invalidateHwcGeometry();
+                repaintEverything();
+                return NO_ERROR;
+            case 1010:
+                reply->writeInt32(0);
+                reply->writeInt32(0);
+                reply->writeInt32(mDebugRegion);
+                reply->writeInt32(0);
+                reply->writeInt32(mDebugDisableHWC);
+                return NO_ERROR;
+            case 1013: {
+                const auto display = getDefaultDisplayDevice();
+                if (!display) {
+                    return NAME_NOT_FOUND;
+                }
+                reply->writeInt32(display->getPageFlipCount());
+                return NO_ERROR;
+            }
+            case 1014: {
+                Mutex::Autolock _l(mStateLock);
+                n = data.readInt32();
+                switch (n % 10) {
+                    case 1:
+                        mDaltonizer.setType(ColorBlindnessType::Protanomaly);
+                        break;
+                    case 2:
+                        mDaltonizer.setType(ColorBlindnessType::Deuteranomaly);
+                        break;
+                    case 3:
+                        mDaltonizer.setType(ColorBlindnessType::Tritanomaly);
+                        break;
+                    default:
+                        mDaltonizer.setType(ColorBlindnessType::None);
+                        break;
+                }
+                if (n >= 10) {
+                    mDaltonizer.setMode(ColorBlindnessMode::Correction);
+                } else {
+                    mDaltonizer.setMode(ColorBlindnessMode::Simulation);
+                }
+                updateColorMatrixLocked();
+                return NO_ERROR;
+            }
+            case 1015: {
+                Mutex::Autolock _l(mStateLock);
+                n = data.readInt32();
+                if (n) {
+                    for (size_t i = 0 ; i < 4; i++) {
+                        for (size_t j = 0; j < 4; j++) {
+                            mClientColorMatrix[i][j] = data.readFloat();
+                        }
+                    }
+                } else {
+                    mClientColorMatrix = mat4();
+                }
+                float4 lastRow(transpose(mClientColorMatrix)[3]);
+                if (any(greaterThan(abs(lastRow - float4{0, 0, 0, 1}), float4{1e-4f}))) {
+                    ALOGE("The color transform's last row must be (0, 0, 0, 1)");
+                }
+                updateColorMatrixLocked();
+                return NO_ERROR;
+            }
+            case 1016: {
+                return NAME_NOT_FOUND;
+            }
+            case 1017: {
+                n = data.readInt32();
+                mForceFullDamage = n != 0;
+                return NO_ERROR;
+            }
+            case 1018: {
+                n = data.readInt32();
+                mScheduler->setPhaseOffset(mAppConnectionHandle, static_cast<nsecs_t>(n));
+                return NO_ERROR;
+            }
+            case 1019: {
+                n = data.readInt32();
+                mScheduler->setPhaseOffset(mSfConnectionHandle, static_cast<nsecs_t>(n));
+                return NO_ERROR;
+            }
+            case 1020: {
+                n = data.readInt32();
+                if (n) {
+                    ALOGV("Interceptor enabled");
+                    mInterceptor->enable(mDrawingState.layersSortedByZ, mDrawingState.displays);
+                }
+                else{
+                    ALOGV("Interceptor disabled");
+                    mInterceptor->disable();
+                }
+                return NO_ERROR;
+            }
+            case 1021: {
+                n = data.readInt32();
+                mUseHwcVirtualDisplays = !n;
+                return NO_ERROR;
+            }
+            case 1022: {
+                Mutex::Autolock _l(mStateLock);
+                mGlobalSaturationFactor = std::max(0.0f, std::min(data.readFloat(), 2.0f));
+                updateColorMatrixLocked();
+                return NO_ERROR;
+            }
+            case 1023: {
+                int32_t colorMode;
+                mDisplayColorSetting = static_cast<DisplayColorSetting>(data.readInt32());
+                if (data.readInt32(&colorMode) == NO_ERROR) {
+                    mForceColorMode = static_cast<ColorMode>(colorMode);
+                }
+                invalidateHwcGeometry();
+                repaintEverything();
+                return NO_ERROR;
+            }
+            case 1024: {
+                return NAME_NOT_FOUND;
+            }
+            case 1025: {
+                n = data.readInt32();
+                if (n) {
+                    ALOGD("LayerTracing enabled");
+                    Mutex::Autolock lock(mStateLock);
+                    mTracingEnabledChanged = true;
+                    mTracing.enable();
+                    reply->writeInt32(NO_ERROR);
+                } else {
+                    ALOGD("LayerTracing disabled");
+                    bool writeFile = false;
+                    {
+                        Mutex::Autolock lock(mStateLock);
+                        mTracingEnabledChanged = true;
+                        writeFile = mTracing.disable();
+                    }
+                    if (writeFile) {
+                        reply->writeInt32(mTracing.writeToFile());
+                    } else {
+                        reply->writeInt32(NO_ERROR);
+                    }
+                }
+                return NO_ERROR;
+            }
+            case 1026: {
+                reply->writeBool(mTracing.isEnabled());
+                return NO_ERROR;
+            }
+            case 1027: {
+                const auto display = getDefaultDisplayDevice();
+                if (!display) {
+                    return NAME_NOT_FOUND;
+                }
+                DisplayColorSetting setting = static_cast<DisplayColorSetting>(data.readInt32());
+                switch (setting) {
+                    case DisplayColorSetting::kManaged:
+                        reply->writeBool(useColorManagement);
+                        break;
+                    case DisplayColorSetting::kUnmanaged:
+                        reply->writeBool(true);
+                        break;
+                    case DisplayColorSetting::kEnhanced:
+                        reply->writeBool(display->hasRenderIntent(RenderIntent::ENHANCE));
+                        break;
+                    default:
+                        reply->writeBool(
+                                display->hasRenderIntent(static_cast<RenderIntent>(setting)));
+                        break;
+                }
+                return NO_ERROR;
+            }
+            case 1028: {
+                Mutex::Autolock _l(mStateLock);
+                reply->writeBool(getHwComposer().isUsingVrComposer());
+                return NO_ERROR;
+            }
+            case 1029: {
+                n = data.readInt32();
+                if (n <= 0 || n > MAX_TRACING_MEMORY) {
+                    ALOGW("Invalid buffer size: %d KB", n);
+                    reply->writeInt32(BAD_VALUE);
+                    return BAD_VALUE;
+                }
+                ALOGD("Updating trace buffer to %d KB", n);
+                mTracing.setBufferSize(n * 1024);
+                reply->writeInt32(NO_ERROR);
+                return NO_ERROR;
+            }
+            case 1030: {
+                reply->writeBool(useColorManagement);
+                return NO_ERROR;
+            }
+            case 1031: {
+                Mutex::Autolock _l(mStateLock);
+                n = data.readInt32();
+                if (n) {
+                    n = data.readInt32();
+                    if (n) {
+                        Dataspace dataspace = static_cast<Dataspace>(n);
+                        if (!validateCompositionDataspace(dataspace)) {
+                            return BAD_VALUE;
+                        }
+                        mDefaultCompositionDataspace = dataspace;
+                    }
+                    n = data.readInt32();
+                    if (n) {
+                        Dataspace dataspace = static_cast<Dataspace>(n);
+                        if (!validateCompositionDataspace(dataspace)) {
+                            return BAD_VALUE;
+                        }
+                        mWideColorGamutCompositionDataspace = dataspace;
+                    }
+                } else {
+                    mDefaultCompositionDataspace = defaultCompositionDataspace;
+                    mWideColorGamutCompositionDataspace = wideColorGamutCompositionDataspace;
+                }
+                return NO_ERROR;
+            }
+            case 1033: {
+                n = data.readUint32();
+                ALOGD("Updating trace flags to 0x%x", n);
+                mTracing.setTraceFlags(n);
+                reply->writeInt32(NO_ERROR);
+                return NO_ERROR;
+            }
+            case 1034: {
+                n = data.readInt32();
+                if (n && !mRefreshRateOverlay) {
+                    RefreshRateType type;
+                    {
+                        std::lock_guard<std::mutex> lock(mActiveConfigLock);
+                        type = mDesiredActiveConfig.type;
+                    }
+                    mRefreshRateOverlay = std::make_unique<RefreshRateOverlay>(*this);
+                    mRefreshRateOverlay->changeRefreshRate(type);
+                } else if (!n) {
+                    mRefreshRateOverlay.reset();
+                }
+                return NO_ERROR;
+            }
+            case 1035: {
+                n = data.readInt32();
+                mDebugDisplayConfigSetByBackdoor = false;
+                if (n >= 0) {
+                    const auto displayToken = getInternalDisplayToken();
+                    status_t result = setAllowedDisplayConfigs(displayToken, {n});
+                    if (result != NO_ERROR) {
+                        return result;
+                    }
+                    mDebugDisplayConfigSetByBackdoor = true;
+                }
+                return NO_ERROR;
+            }
+        }
+    }
+    return err;
+}
+void SurfaceFlinger::repaintEverything() {
+    mRepaintEverything = true;
+    signalTransaction();
+}
+void SurfaceFlinger::repaintEverythingForHWC() {
+    mRepaintEverything = true;
+    mEventQueue->invalidate();
@@ -1863,3 +3815 @@ public:
-    ~WindowDisconnector() {
-        native_window_api_disconnect(mWindow, mApi);
-    }
+    WindowDisconnector(ANativeWindow* window, int api) : mWindow(window), mApi(api) {}
@@ -1870 +3820 @@ private:
-    const int mApi;
+    ANativeWindow* mWindow;
@@ -2380,0 +4331,7 @@ void SurfaceFlinger::bufferErased(const client_cache_t& clientCacheId) {
+}
+#if defined(__gl_h_)
+#error "don't include gl/gl.h in this file"
+#endif
+#if defined(__gl2_h_)
+#error "don't include gl2/gl2.h in this file"
+#endif
