--- a/output/frameworks_native/61d0f848-cae2ee03-995b2469/services@surfaceflinger@SurfaceFlinger.no_comments_mergebot.cpp
+++ b/output/frameworks_native/61d0f848-cae2ee03-995b2469/services@surfaceflinger@SurfaceFlinger.no_comments_truth.cpp
@@ -19 +18,0 @@
-#include <compositionengine/Layer.h>
@@ -22,2 +20,0 @@
-#include <compositionengine/impl/LayerCompositionState.h>
-#include <compositionengine/impl/OutputLayerCompositionState.h>
@@ -71 +67,0 @@
-#include "ColorLayer.h"
@@ -92 +87,0 @@
-#include "Scheduler/InjectVSyncSource.h"
@@ -132,0 +128 @@ using ui::RenderIntent;
+namespace hal = android::hardware::graphics::composer::hal;
@@ -133,0 +130,2 @@ namespace {
+#pragma clang diagnostic push
+#pragma clang diagnostic error "-Wswitch-enum"
@@ -155 +153,26 @@ bool isWideColorMode(const ColorMode colorMode) {
-explicit UnnecessaryLock(Mutex& mutex) ACQUIRE(mutex) {
+#pragma clang diagnostic pop
+template <typename Mutex>
+struct SCOPED_CAPABILITY ConditionalLockGuard {
+    ConditionalLockGuard(Mutex& mutex, bool lock) ACQUIRE(mutex) : mutex(mutex), lock(lock) {
+        if (lock) mutex.lock();
+    }
+    ~ConditionalLockGuard() RELEASE() {
+        if (lock) mutex.unlock();
+    }
+    Mutex& mutex;
+    const bool lock;
+};
+using ConditionalLock = ConditionalLockGuard<Mutex>;
+struct SCOPED_CAPABILITY TimedLock {
+    TimedLock(Mutex& mutex, nsecs_t timeout, const char* whence) ACQUIRE(mutex)
+          : mutex(mutex), status(mutex.timedLock(timeout)) {
+        ALOGE_IF(!locked(), "%s timed out locking: %s (%d)", whence, strerror(-status), status);
+    }
+    ~TimedLock() RELEASE() {
+        if (locked()) mutex.unlock();
+    }
+    bool locked() const { return status == NO_ERROR; }
+    Mutex& mutex;
+    const status_t status;
+};
+struct SCOPED_CAPABILITY UnnecessaryLock {
@@ -158 +181 @@ explicit UnnecessaryLock(Mutex& mutex) ACQUIRE(mutex) {
-}
+};
@@ -174,2 +197,2 @@ public:
-    mCallback(callback){}
-    ~FrameRateFlexibilityToken(){ mCallback(); }
+    FrameRateFlexibilityToken(std::function<void()> callback) : mCallback(callback) {}
+    virtual ~FrameRateFlexibilityToken() { mCallback(); }
@@ -179 +201,0 @@ private:
-using ConditionalLock = ConditionalLockGuard<Mutex>;
@@ -186,168 +208,17 @@ const char* KERNEL_IDLE_TIMER_PROP = "graphics.display.kernel_idle_timer.enabled
-status_t SurfaceFlinger::getSupportedFrameTimestamps(
-        std::vector<FrameEvent>* outSupported) const {
-    *outSupported = {
-        FrameEvent::REQUESTED_PRESENT,
-        FrameEvent::ACQUIRE,
-        FrameEvent::LATCH,
-        FrameEvent::FIRST_REFRESH_START,
-        FrameEvent::LAST_REFRESH_START,
-        FrameEvent::GPU_COMPOSITION_DONE,
-        FrameEvent::DEQUEUE_READY,
-        FrameEvent::RELEASE,
-    };
-status_t SurfaceFlinger::getSupportedFrameTimestamps(
-        std::vector<FrameEvent>* outSupported) const {
-    *outSupported = {
-        FrameEvent::REQUESTED_PRESENT,
-        FrameEvent::ACQUIRE,
-        FrameEvent::LATCH,
-        FrameEvent::FIRST_REFRESH_START,
-        FrameEvent::LAST_REFRESH_START,
-        FrameEvent::GPU_COMPOSITION_DONE,
-        FrameEvent::DEQUEUE_READY,
-        FrameEvent::RELEASE,
-    };
-status_t SurfaceFlinger::getSupportedFrameTimestamps(
-        std::vector<FrameEvent>* outSupported) const {
-    *outSupported = {
-        FrameEvent::REQUESTED_PRESENT,
-        FrameEvent::ACQUIRE,
-        FrameEvent::LATCH,
-        FrameEvent::FIRST_REFRESH_START,
-        FrameEvent::LAST_REFRESH_START,
-        FrameEvent::GPU_COMPOSITION_DONE,
-        FrameEvent::DEQUEUE_READY,
-        FrameEvent::RELEASE,
-    };
-status_t SurfaceFlinger::getSupportedFrameTimestamps(
-        std::vector<FrameEvent>* outSupported) const {
-    *outSupported = {
-        FrameEvent::REQUESTED_PRESENT,
-        FrameEvent::ACQUIRE,
-        FrameEvent::LATCH,
-        FrameEvent::FIRST_REFRESH_START,
-        FrameEvent::LAST_REFRESH_START,
-        FrameEvent::GPU_COMPOSITION_DONE,
-        FrameEvent::DEQUEUE_READY,
-        FrameEvent::RELEASE,
-    };
-status_t SurfaceFlinger::getSupportedFrameTimestamps(
-        std::vector<FrameEvent>* outSupported) const {
-    *outSupported = {
-        FrameEvent::REQUESTED_PRESENT,
-        FrameEvent::ACQUIRE,
-        FrameEvent::LATCH,
-        FrameEvent::FIRST_REFRESH_START,
-        FrameEvent::LAST_REFRESH_START,
-        FrameEvent::GPU_COMPOSITION_DONE,
-        FrameEvent::DEQUEUE_READY,
-        FrameEvent::RELEASE,
-    };
-status_t SurfaceFlinger::getSupportedFrameTimestamps(
-        std::vector<FrameEvent>* outSupported) const {
-    *outSupported = {
-        FrameEvent::REQUESTED_PRESENT,
-        FrameEvent::ACQUIRE,
-        FrameEvent::LATCH,
-        FrameEvent::FIRST_REFRESH_START,
-        FrameEvent::LAST_REFRESH_START,
-        FrameEvent::GPU_COMPOSITION_DONE,
-        FrameEvent::DEQUEUE_READY,
-        FrameEvent::RELEASE,
-    };
-status_t SurfaceFlinger::getSupportedFrameTimestamps(
-        std::vector<FrameEvent>* outSupported) const {
-    *outSupported = {
-        FrameEvent::REQUESTED_PRESENT,
-        FrameEvent::ACQUIRE,
-        FrameEvent::LATCH,
-        FrameEvent::FIRST_REFRESH_START,
-        FrameEvent::LAST_REFRESH_START,
-        FrameEvent::GPU_COMPOSITION_DONE,
-        FrameEvent::DEQUEUE_READY,
-        FrameEvent::RELEASE,
-    };
-status_t SurfaceFlinger::getSupportedFrameTimestamps(
-        std::vector<FrameEvent>* outSupported) const {
-    *outSupported = {
-        FrameEvent::REQUESTED_PRESENT,
-        FrameEvent::ACQUIRE,
-        FrameEvent::LATCH,
-        FrameEvent::FIRST_REFRESH_START,
-        FrameEvent::LAST_REFRESH_START,
-        FrameEvent::GPU_COMPOSITION_DONE,
-        FrameEvent::DEQUEUE_READY,
-        FrameEvent::RELEASE,
-    };
-status_t SurfaceFlinger::getSupportedFrameTimestamps(
-        std::vector<FrameEvent>* outSupported) const {
-    *outSupported = {
-        FrameEvent::REQUESTED_PRESENT,
-        FrameEvent::ACQUIRE,
-        FrameEvent::LATCH,
-        FrameEvent::FIRST_REFRESH_START,
-        FrameEvent::LAST_REFRESH_START,
-        FrameEvent::GPU_COMPOSITION_DONE,
-        FrameEvent::DEQUEUE_READY,
-        FrameEvent::RELEASE,
-    };
-status_t SurfaceFlinger::getSupportedFrameTimestamps(
-        std::vector<FrameEvent>* outSupported) const {
-    *outSupported = {
-        FrameEvent::REQUESTED_PRESENT,
-        FrameEvent::ACQUIRE,
-        FrameEvent::LATCH,
-        FrameEvent::FIRST_REFRESH_START,
-        FrameEvent::LAST_REFRESH_START,
-        FrameEvent::GPU_COMPOSITION_DONE,
-        FrameEvent::DEQUEUE_READY,
-        FrameEvent::RELEASE,
-    };
-status_t SurfaceFlinger::getSupportedFrameTimestamps(
-        std::vector<FrameEvent>* outSupported) const {
-    *outSupported = {
-        FrameEvent::REQUESTED_PRESENT,
-        FrameEvent::ACQUIRE,
-        FrameEvent::LATCH,
-        FrameEvent::FIRST_REFRESH_START,
-        FrameEvent::LAST_REFRESH_START,
-        FrameEvent::GPU_COMPOSITION_DONE,
-        FrameEvent::DEQUEUE_READY,
-        FrameEvent::RELEASE,
-    };
-status_t SurfaceFlinger::getSupportedFrameTimestamps(
-        std::vector<FrameEvent>* outSupported) const {
-    *outSupported = {
-        FrameEvent::REQUESTED_PRESENT,
-        FrameEvent::ACQUIRE,
-        FrameEvent::LATCH,
-        FrameEvent::FIRST_REFRESH_START,
-        FrameEvent::LAST_REFRESH_START,
-        FrameEvent::GPU_COMPOSITION_DONE,
-        FrameEvent::DEQUEUE_READY,
-        FrameEvent::RELEASE,
-    };
-status_t SurfaceFlinger::getSupportedFrameTimestamps(
-        std::vector<FrameEvent>* outSupported) const {
-    *outSupported = {
-        FrameEvent::REQUESTED_PRESENT,
-        FrameEvent::ACQUIRE,
-        FrameEvent::LATCH,
-        FrameEvent::FIRST_REFRESH_START,
-        FrameEvent::LAST_REFRESH_START,
-        FrameEvent::GPU_COMPOSITION_DONE,
-        FrameEvent::DEQUEUE_READY,
-        FrameEvent::RELEASE,
-    };
-status_t SurfaceFlinger::getSupportedFrameTimestamps(
-        std::vector<FrameEvent>* outSupported) const {
-    *outSupported = {
-        FrameEvent::REQUESTED_PRESENT,
-        FrameEvent::ACQUIRE,
-        FrameEvent::LATCH,
-        FrameEvent::FIRST_REFRESH_START,
-        FrameEvent::LAST_REFRESH_START,
-        FrameEvent::GPU_COMPOSITION_DONE,
-        FrameEvent::DEQUEUE_READY,
-        FrameEvent::RELEASE,
-    };
+int64_t SurfaceFlinger::dispSyncPresentTimeOffset;
+bool SurfaceFlinger::useHwcForRgbToYuv;
+uint64_t SurfaceFlinger::maxVirtualDisplaySize;
+bool SurfaceFlinger::hasSyncFramework;
+bool SurfaceFlinger::useVrFlinger;
+int64_t SurfaceFlinger::maxFrameBufferAcquiredBuffers;
+uint32_t SurfaceFlinger::maxGraphicsWidth;
+uint32_t SurfaceFlinger::maxGraphicsHeight;
+bool SurfaceFlinger::hasWideColorDisplay;
+ui::Rotation SurfaceFlinger::internalDisplayOrientation = ui::ROTATION_0;
+bool SurfaceFlinger::useColorManagement;
+bool SurfaceFlinger::useContextPriority;
+Dataspace SurfaceFlinger::defaultCompositionDataspace = Dataspace::V0_SRGB;
+ui::PixelFormat SurfaceFlinger::defaultCompositionPixelFormat = ui::PixelFormat::RGBA_8888;
+Dataspace SurfaceFlinger::wideColorGamutCompositionDataspace = Dataspace::V0_SRGB;
+ui::PixelFormat SurfaceFlinger::wideColorGamutCompositionPixelFormat = ui::PixelFormat::RGBA_8888;
+bool SurfaceFlinger::useFrameRateApi;
@@ -390,2 +260,0 @@ SurfaceFlinger::SurfaceFlinger(Factory& factory) : SurfaceFlinger(factory, SkipI
-    ALOGI("SurfaceFlinger is starting");
-    hasSyncFramework {
@@ -475,0 +345 @@ SurfaceFlinger::SurfaceFlinger(Factory& factory) : SurfaceFlinger(factory, SkipI
+SurfaceFlinger::~SurfaceFlinger() = default;
@@ -479 +348,0 @@ void SurfaceFlinger::onFirstRef() {
-SurfaceFlinger::~SurfaceFlinger()
@@ -601,5 +469,0 @@ void SurfaceFlinger::bootFinished()
-<<<<<<< HEAD
-    static_cast<void>(schedule([this] {
-||||||| 995b24692c
-    postMessageAsync(new LambdaMessage([this]() NO_THREAD_SAFETY_ANALYSIS {
-=======
@@ -607 +471 @@ void SurfaceFlinger::bootFinished()
-    postMessageAsync(new LambdaMessage([=]() NO_THREAD_SAFETY_ANALYSIS {
+    static_cast<void>(schedule([=] {
@@ -613 +476,0 @@ void SurfaceFlinger::bootFinished()
->>>>>>> cae2ee03
@@ -753,2 +616,6 @@ status_t SurfaceFlinger::getSupportedFrameTimestamps(
-private:
-    const int mApi;
+    ConditionalLock _l(mStateLock,
+            std::this_thread::get_id() != mMainThreadId);
+    if (!getHwComposer().hasCapability(hal::Capability::PRESENT_FENCE_IS_NOT_RELIABLE)) {
+        outSupported->push_back(FrameEvent::DISPLAY_PRESENT);
+    }
+    return NO_ERROR;
@@ -1238,4 +1110,9 @@ status_t SurfaceFlinger::getLayerDebugInfo(std::vector<LayerDebugInfo>* outLayer
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
+status_t SurfaceFlinger::getCompositionPreference(
+        Dataspace* outDataspace, ui::PixelFormat* outPixelFormat,
+        Dataspace* outWideColorGamutDataspace,
+        ui::PixelFormat* outWideColorGamutPixelFormat) const {
+    *outDataspace = mDefaultCompositionDataspace;
+    *outPixelFormat = defaultCompositionPixelFormat;
+    *outWideColorGamutDataspace = mWideColorGamutCompositionDataspace;
+    *outWideColorGamutPixelFormat = wideColorGamutCompositionPixelFormat;
+    return NO_ERROR;
@@ -1243,7 +1120,5 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
+status_t SurfaceFlinger::addRegionSamplingListener(const Rect& samplingArea,
+                                                   const sp<IBinder>& stopLayerHandle,
+                                                   const sp<IRegionSamplingListener>& listener) {
+    if (!listener || samplingArea == Rect::INVALID_RECT) {
+        return BAD_VALUE;
@@ -1251,6 +1126,3 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
+    const wp<Layer> stopLayer = fromHandle(stopLayerHandle);
+    mRegionSamplingThread->addListener(samplingArea, stopLayer, listener);
+    return NO_ERROR;
@@ -1258,3 +1130,3 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
+status_t SurfaceFlinger::removeRegionSamplingListener(const sp<IRegionSamplingListener>& listener) {
+    if (!listener) {
+        return BAD_VALUE;
@@ -1261,0 +1134,2 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
+    mRegionSamplingThread->removeListener(listener);
+    return NO_ERROR;
@@ -1263,4 +1137,4 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
+status_t SurfaceFlinger::getDisplayBrightnessSupport(const sp<IBinder>& displayToken,
+                                                     bool* outSupport) const {
+    if (!displayToken || !outSupport) {
+        return BAD_VALUE;
@@ -1268,7 +1142,4 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
+    Mutex::Autolock lock(mStateLock);
+    const auto displayId = getPhysicalDisplayIdLocked(displayToken);
+    if (!displayId) {
+        return NAME_NOT_FOUND;
@@ -1276,6 +1147,3 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
+    *outSupport =
+            getHwComposer().hasDisplayCapability(*displayId, hal::DisplayCapability::BRIGHTNESS);
+    return NO_ERROR;
@@ -1283,3 +1151,3 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
+status_t SurfaceFlinger::setDisplayBrightness(const sp<IBinder>& displayToken, float brightness) {
+    if (!displayToken) {
+        return BAD_VALUE;
@@ -1286,0 +1155,6 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
+    return promise::chain(schedule([=]() MAIN_THREAD {
+               if (const auto displayId = getPhysicalDisplayIdLocked(displayToken)) {
+                   return getHwComposer().setDisplayBrightness(*displayId, brightness);
+               } else {
+                   ALOGE("%s: Invalid display token %p", __FUNCTION__, displayToken.get());
+                   return promise::yield<status_t>(NAME_NOT_FOUND);
@@ -1288,4 +1162,3 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
+           }))
+            .then([](std::future<status_t> task) { return task; })
+            .get();
@@ -1293,7 +1166,4 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
+status_t SurfaceFlinger::notifyPowerHint(int32_t hintId) {
+    PowerHint powerHint = static_cast<PowerHint>(hintId);
+    if (powerHint == PowerHint::INTERACTION) {
+        mScheduler->notifyTouchEvent();
@@ -1301,6 +1171 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
+    return NO_ERROR;
@@ -1308,3 +1173,34 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
+sp<IDisplayEventConnection> SurfaceFlinger::createDisplayEventConnection(
+        ISurfaceComposer::VsyncSource vsyncSource, ISurfaceComposer::ConfigChanged configChanged) {
+    const auto& handle =
+            vsyncSource == eVsyncSourceSurfaceFlinger ? mSfConnectionHandle : mAppConnectionHandle;
+    return mScheduler->createDisplayEventConnection(handle, configChanged);
+}
+void SurfaceFlinger::signalTransaction() {
+    mScheduler->resetIdleTimer();
+    mPowerAdvisor.notifyDisplayUpdateImminent();
+    mEventQueue->invalidate();
+}
+void SurfaceFlinger::signalLayerUpdate() {
+    mScheduler->resetIdleTimer();
+    mPowerAdvisor.notifyDisplayUpdateImminent();
+    mEventQueue->invalidate();
+}
+void SurfaceFlinger::signalRefresh() {
+    mRefreshPending = true;
+    mEventQueue->refresh();
+}
+nsecs_t SurfaceFlinger::getVsyncPeriod() const {
+    const auto displayId = getInternalDisplayIdLocked();
+    if (!displayId || !getHwComposer().isConnected(*displayId)) {
+        return 0;
+    }
+    return getHwComposer().getDisplayVsyncPeriod(*displayId);
+}
+void SurfaceFlinger::onVsyncReceived(int32_t sequenceId, hal::HWDisplayId hwcDisplayId,
+                                     int64_t timestamp,
+                                     std::optional<hal::VsyncPeriodNanos> vsyncPeriod) {
+    ATRACE_NAME("SF onVsync");
+    Mutex::Autolock lock(mStateLock);
+    if (sequenceId != getBE().mComposerSequenceId) {
+        return;
@@ -1311,0 +1208,2 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
+    if (!getHwComposer().onVsync(hwcDisplayId, timestamp)) {
+        return;
@@ -1313,3 +1211 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
+    if (hwcDisplayId != getHwComposer().getInternalHwcDisplayId()) {
@@ -1318,7 +1214,4 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
+    bool periodFlushed = false;
+    mScheduler->addResyncSample(timestamp, vsyncPeriod, &periodFlushed);
+    if (periodFlushed) {
+        mVSyncModulator->onRefreshRateChangeCompleted();
@@ -1326,6 +1218,0 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
@@ -1333,3 +1220,3 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
+void SurfaceFlinger::getCompositorTiming(CompositorTiming* compositorTiming) {
+    std::lock_guard<std::mutex> lock(getBE().mCompositorTimingLock);
+    *compositorTiming = getBE().mCompositorTiming;
@@ -1336,0 +1224,2 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
+bool SurfaceFlinger::isDisplayConfigAllowed(HwcConfigIndexType configId) const {
+    return mRefreshRateConfigs->isConfigAllowed(configId);
@@ -1338,3 +1227,4 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
+void SurfaceFlinger::changeRefreshRateLocked(const RefreshRate& refreshRate,
+                                             Scheduler::ConfigEvent event) {
+    const auto display = getDefaultDisplayDeviceLocked();
+    if (!display || mBootStage != BootStage::FINISHED) {
@@ -1343,7 +1233,5 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
+    ATRACE_CALL();
+    if (!isDisplayConfigAllowed(refreshRate.getConfigId())) {
+        ALOGV("Skipping config %d as it is not part of allowed configs",
+              refreshRate.getConfigId().value());
+        return;
@@ -1351,6 +1239 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
+    setDesiredActiveConfig({refreshRate.getConfigId(), event});
@@ -1358,3 +1241,11 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
+void SurfaceFlinger::onHotplugReceived(int32_t sequenceId, hal::HWDisplayId hwcDisplayId,
+                                       hal::Connection connection) {
+    ALOGV("%s(%d, %" PRIu64 ", %s)", __FUNCTION__, sequenceId, hwcDisplayId,
+          connection == hal::Connection::CONNECTED ? "connected" : "disconnected");
+    if (sequenceId != getBE().mComposerSequenceId) {
+        return;
+    }
+    ConditionalLock lock(mStateLock, std::this_thread::get_id() != mMainThreadId);
+    mPendingHotplugEvents.emplace_back(HotplugEvent{hwcDisplayId, connection});
+    if (std::this_thread::get_id() == mMainThreadId) {
+        processDisplayHotplugEventsLocked();
@@ -1361,0 +1253 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
+    setTransactionFlags(eDisplayTransactionNeeded);
@@ -1363,3 +1255,5 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
+void SurfaceFlinger::onVsyncPeriodTimingChangedReceived(
+        int32_t sequenceId, hal::HWDisplayId ,
+        const hal::VsyncPeriodChangeTimeline& updatedTimeline) {
+    Mutex::Autolock lock(mStateLock);
+    if (sequenceId != getBE().mComposerSequenceId) {
@@ -1368,7 +1262 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
+    mScheduler->onNewVsyncPeriodChangeTimeline(updatedTimeline);
@@ -1376,6 +1264 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
+void SurfaceFlinger::onSeamlessPossible(int32_t , hal::HWDisplayId ) {
@@ -1383,3 +1266,4 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
+void SurfaceFlinger::onRefreshReceived(int sequenceId, hal::HWDisplayId ) {
+    Mutex::Autolock lock(mStateLock);
+    if (sequenceId != getBE().mComposerSequenceId) {
+        return;
@@ -1386,0 +1271 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
+    repaintEverythingForHWC();
@@ -1388,4 +1273,3 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
+void SurfaceFlinger::setPrimaryVsyncEnabled(bool enabled) {
+    ATRACE_CALL();
+    static_cast<void>(schedule([=]() MAIN_THREAD { setPrimaryVsyncEnabledInternal(enabled); }));
@@ -1393,7 +1277,7 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
+void SurfaceFlinger::setPrimaryVsyncEnabledInternal(bool enabled) {
+    ATRACE_CALL();
+    mHWCVsyncPendingState = enabled ? hal::Vsync::ENABLE : hal::Vsync::DISABLE;
+    if (const auto displayId = getInternalDisplayIdLocked()) {
+        sp<DisplayDevice> display = getDefaultDisplayDeviceLocked();
+        if (display && display->isPoweredOn()) {
+            getHwComposer().setVsyncEnabled(*displayId, mHWCVsyncPendingState);
@@ -1401,6 +1284,0 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
@@ -1408,3 +1285,0 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
@@ -1411,0 +1287,4 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
+void SurfaceFlinger::resetDisplayState() {
+    mScheduler->disableHardwareVsync(true);
+    mDrawingState.displays.clear();
+    mDisplays.clear();
@@ -1413,3 +1292,6 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
+void SurfaceFlinger::updateVrFlinger() {
+    ATRACE_CALL();
+    if (!mVrFlinger)
+        return;
+    bool vrFlingerRequestsDisplay = mVrFlingerRequestsDisplay;
+    if (vrFlingerRequestsDisplay == getHwComposer().isUsingVrComposer()) {
@@ -1418,7 +1300,6 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
+    if (vrFlingerRequestsDisplay && !getHwComposer().getComposer()->isRemote()) {
+        ALOGE("Vr flinger is only supported for remote hardware composer"
+              " service connections. Ignoring request to transition to vr"
+              " flinger.");
+        mVrFlingerRequestsDisplay = false;
+        return;
@@ -1426,6 +1307,34 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
+    Mutex::Autolock _l(mStateLock);
+    sp<DisplayDevice> display = getDefaultDisplayDeviceLocked();
+    LOG_ALWAYS_FATAL_IF(!display);
+    const hal::PowerMode currentDisplayPowerMode = display->getPowerMode();
+    for (const auto& [token, displayDevice] : mDisplays) {
+        displayDevice->getCompositionDisplay()->clearOutputLayers();
+    }
+    display.clear();
+    if (!vrFlingerRequestsDisplay) {
+        mVrFlinger->SeizeDisplayOwnership();
+    }
+    resetDisplayState();
+    mCompositionEngine->setHwComposer(std::unique_ptr<HWComposer>());
+    mCompositionEngine->setHwComposer(getFactory().createHWComposer(
+            vrFlingerRequestsDisplay ? "vr" : getBE().mHwcServiceName));
+    mCompositionEngine->getHwComposer().setConfiguration(this, ++getBE().mComposerSequenceId);
+    LOG_ALWAYS_FATAL_IF(!getHwComposer().getComposer()->isRemote(),
+                        "Switched to non-remote hardware composer");
+    if (vrFlingerRequestsDisplay) {
+        mVrFlinger->GrantDisplayOwnership();
+    }
+    mVisibleRegionsDirty = true;
+    invalidateHwcGeometry();
+    display = getDefaultDisplayDeviceLocked();
+    LOG_ALWAYS_FATAL_IF(!display);
+    setPowerModeInternal(display, currentDisplayPowerMode);
+    const nsecs_t vsyncPeriod = getVsyncPeriod();
+    mAnimFrameTracker.setDisplayRefreshPeriod(vsyncPeriod);
+    mScheduler->setIgnorePresentFences(getHwComposer().isUsingVrComposer() || !hasSyncFramework);
+    DisplayStatInfo stats{0 , vsyncPeriod};
+    setCompositorTimingSnapped(stats, 0);
+    mScheduler->resyncToHardwareVsync(false, vsyncPeriod);
+    mRepaintEverything = true;
+    setTransactionFlags(eDisplayTransactionNeeded);
@@ -1433,3 +1342,9 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
+sp<Fence> SurfaceFlinger::previousFrameFence() {
+    return mVSyncModulator->getOffsets().sf > 0 ? mPreviousPresentFences[0]
+                                                : mPreviousPresentFences[1];
+}
+bool SurfaceFlinger::previousFramePending(int graceTimeMs) {
+    ATRACE_CALL();
+    const sp<Fence>& fence = previousFrameFence();
+    if (fence == Fence::NO_FENCE) {
+        return false;
@@ -1436,0 +1352,2 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
+    const status_t status = fence->wait(graceTimeMs);
+    return status == -ETIME;
@@ -1438,4 +1355,4 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
+nsecs_t SurfaceFlinger::previousFramePresentTime() {
+    const sp<Fence>& fence = previousFrameFence();
+    if (fence == Fence::NO_FENCE) {
+        return Fence::SIGNAL_TIME_INVALID;
@@ -1443,7 +1360 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
+    return fence->getSignalTime();
@@ -1451,6 +1362,5 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
+nsecs_t SurfaceFlinger::calculateExpectedPresentTime(nsecs_t now) const {
+    DisplayStatInfo stats;
+    mScheduler->getDisplayStatInfo(&stats);
+    const nsecs_t presentTime = mScheduler->getDispSyncExpectedPresentTime(now);
+    return mVSyncModulator->getOffsets().sf > 0 ? presentTime : presentTime + stats.vsyncPeriod;
@@ -1458,2 +1368,5 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::NoChange:
+void SurfaceFlinger::onMessageReceived(int32_t what, nsecs_t expectedVSyncTime) {
+    ATRACE_CALL();
+    switch (what) {
+        case MessageQueue::INVALIDATE: {
+            onMessageInvalidate(expectedVSyncTime);
@@ -1461,0 +1375,3 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
+        case MessageQueue::REFRESH: {
+            onMessageRefresh();
+            break;
@@ -1463,4 +1378,0 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
@@ -1468,7 +1379,0 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
@@ -1476,6 +1381,65 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
+void SurfaceFlinger::onMessageInvalidate(nsecs_t expectedVSyncTime) {
+    ATRACE_CALL();
+    const nsecs_t frameStart = systemTime();
+    const nsecs_t lastExpectedPresentTime = mExpectedPresentTime.load();
+    mExpectedPresentTime = expectedVSyncTime;
+    const int graceTimeForPresentFenceMs =
+            (mPropagateBackpressure &&
+             (mPropagateBackpressureClientComposition || !mHadClientComposition))
+            ? 1
+            : 0;
+    const TracedOrdinal<bool> framePending = {"PrevFramePending",
+                                              previousFramePending(graceTimeForPresentFenceMs)};
+    DisplayStatInfo stats;
+    mScheduler->getDisplayStatInfo(&stats);
+    const nsecs_t frameMissedSlop = stats.vsyncPeriod / 2;
+    const nsecs_t previousPresentTime = previousFramePresentTime();
+    const TracedOrdinal<bool> frameMissed = {"PrevFrameMissed",
+                                             framePending ||
+                                                     (previousPresentTime >= 0 &&
+                                                      (lastExpectedPresentTime <
+                                                       previousPresentTime - frameMissedSlop))};
+    const TracedOrdinal<bool> hwcFrameMissed = {"PrevHwcFrameMissed",
+                                                mHadDeviceComposition && frameMissed};
+    const TracedOrdinal<bool> gpuFrameMissed = {"PrevGpuFrameMissed",
+                                                mHadClientComposition && frameMissed};
+    if (frameMissed) {
+        mFrameMissedCount++;
+        mTimeStats->incrementMissedFrames();
+        if (mMissedFrameJankCount == 0) {
+            mMissedFrameJankStart = systemTime();
+        }
+        mMissedFrameJankCount++;
+    }
+    if (hwcFrameMissed) {
+        mHwcFrameMissedCount++;
+    }
+    if (gpuFrameMissed) {
+        mGpuFrameMissedCount++;
+    }
+    if (mSetActiveConfigPending) {
+        if (framePending) {
+            mEventQueue->invalidate();
+            return;
+        }
+        mSetActiveConfigPending = false;
+        ON_MAIN_THREAD(setActiveConfigInternal());
+    }
+    if (framePending && mPropagateBackpressure) {
+        if ((hwcFrameMissed && !gpuFrameMissed) || mPropagateBackpressureClientComposition) {
+            signalLayerUpdate();
+            return;
+        }
+    }
+    static constexpr nsecs_t kMinJankyDuration =
+            std::chrono::duration_cast<std::chrono::nanoseconds>(100ms).count();
+    static constexpr nsecs_t kMaxJankyDuration =
+            std::chrono::duration_cast<std::chrono::nanoseconds>(1s).count();
+    nsecs_t jankDurationToUpload = -1;
+    if (!mIsUserBuild && mMissedFrameJankCount > 0) {
+        const auto display = ON_MAIN_THREAD(getDefaultDisplayDeviceLocked());
+        if (display && display->getPowerMode() == hal::PowerMode::ON) {
+            const nsecs_t currentTime = systemTime();
+            const nsecs_t jankDuration = currentTime - mMissedFrameJankStart;
+            if (jankDuration > kMinJankyDuration && jankDuration < kMaxJankyDuration) {
+                jankDurationToUpload = jankDuration;
@@ -1483,3 +1447,3 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
+            if (jankDuration > kMinJankyDuration) {
+                mMissedFrameJankCount = 0;
+                mMissedFrameJankStart = 0;
@@ -1488,4 +1451,0 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
@@ -1493,7 +1453,4 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
+    updateVrFlinger();
+    if (mTracingEnabledChanged) {
+        mTracingEnabled = mTracing.isEnabled();
+        mTracingEnabledChanged = false;
@@ -1501,6 +1458,10 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
+    bool refreshNeeded;
+    {
+        ConditionalLockGuard<std::mutex> lock(mTracingLock, mTracingEnabled);
+        refreshNeeded = handleMessageTransaction();
+        refreshNeeded |= handleMessageInvalidate();
+        if (mTracingEnabled) {
+            mAddCompositionStateToTrace =
+                    mTracing.flagIsSetLocked(SurfaceTracing::TRACE_COMPOSITION);
+            if (mVisibleRegionsDirty && !mAddCompositionStateToTrace) {
+                mTracing.notifyLocked("visibleRegionsDirty");
@@ -1508,3 +1468,0 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
@@ -1513,4 +1471,3 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
+    {
+        Mutex::Autolock _l(mStateLock);
+        mScheduler->chooseRefreshRateForContent();
@@ -1518,7 +1475,8 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
+    ON_MAIN_THREAD(performSetActiveConfig());
+    updateCursorAsync();
+    updateInputFlinger();
+    refreshNeeded |= mRepaintEverything;
+    if (refreshNeeded && CC_LIKELY(mBootStage != BootStage::BOOTLOADER)) {
+        mLastJankDuration = jankDurationToUpload;
+        if (mFrameStartTime <= 0) {
+            mFrameStartTime = frameStart;
@@ -1526,6 +1484 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
+        signalRefresh();
@@ -1533,3 +1485,0 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
@@ -1536,0 +1487,12 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
+bool SurfaceFlinger::handleMessageTransaction() {
+    ATRACE_CALL();
+    uint32_t transactionFlags = peekTransactionFlags();
+    bool flushedATransaction = flushTransactionQueues();
+    bool runHandleTransaction =
+            (transactionFlags && (transactionFlags != eTransactionFlushNeeded)) ||
+            flushedATransaction ||
+            mForceTraversal;
+    if (runHandleTransaction) {
+        handleTransaction(eTransactionMask);
+    } else {
+        getTransactionFlags(eTransactionFlushNeeded);
@@ -1538,4 +1500,2 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
+    if (transactionFlushNeeded()) {
+        setTransactionFlags(eTransactionFlushNeeded);
@@ -1543,7 +1503 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
+    return runHandleTransaction;
@@ -1551,6 +1505,61 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
+void SurfaceFlinger::onMessageRefresh() {
+    ATRACE_CALL();
+    mRefreshPending = false;
+    compositionengine::CompositionRefreshArgs refreshArgs;
+    const auto& displays = ON_MAIN_THREAD(mDisplays);
+    refreshArgs.outputs.reserve(displays.size());
+    for (const auto& [_, display] : displays) {
+        refreshArgs.outputs.push_back(display->getCompositionDisplay());
+    }
+    mDrawingState.traverseInZOrder([&refreshArgs](Layer* layer) {
+        if (auto layerFE = layer->getCompositionEngineLayerFE())
+            refreshArgs.layers.push_back(layerFE);
+    });
+    refreshArgs.layersWithQueuedFrames.reserve(mLayersWithQueuedFrames.size());
+    for (sp<Layer> layer : mLayersWithQueuedFrames) {
+        if (auto layerFE = layer->getCompositionEngineLayerFE())
+            refreshArgs.layersWithQueuedFrames.push_back(layerFE);
+    }
+    refreshArgs.repaintEverything = mRepaintEverything.exchange(false);
+    refreshArgs.outputColorSetting = useColorManagement
+            ? mDisplayColorSetting
+            : compositionengine::OutputColorSetting::kUnmanaged;
+    refreshArgs.colorSpaceAgnosticDataspace = mColorSpaceAgnosticDataspace;
+    refreshArgs.forceOutputColorMode = mForceColorMode;
+    refreshArgs.updatingOutputGeometryThisFrame = mVisibleRegionsDirty;
+    refreshArgs.updatingGeometryThisFrame = mGeometryInvalid || mVisibleRegionsDirty;
+    refreshArgs.blursAreExpensive = mBlursAreExpensive;
+    refreshArgs.internalDisplayRotationFlags = DisplayDevice::getPrimaryDisplayRotationFlags();
+    if (CC_UNLIKELY(mDrawingState.colorMatrixChanged)) {
+        refreshArgs.colorTransformMatrix = mDrawingState.colorMatrix;
+        mDrawingState.colorMatrixChanged = false;
+    }
+    refreshArgs.devOptForceClientComposition = mDebugDisableHWC || mDebugRegion;
+    if (mDebugRegion != 0) {
+        refreshArgs.devOptFlashDirtyRegionsDelay =
+                std::chrono::milliseconds(mDebugRegion > 1 ? mDebugRegion : 0);
+    }
+    mGeometryInvalid = false;
+    const auto presentTime = systemTime();
+    mCompositionEngine->present(refreshArgs);
+    mTimeStats->recordFrameDuration(mFrameStartTime, systemTime());
+    mFrameStartTime = 0;
+    mScheduler->onDisplayRefreshed(presentTime);
+    postFrame();
+    postComposition();
+    const bool prevFrameHadDeviceComposition = mHadDeviceComposition;
+    mHadClientComposition = std::any_of(displays.cbegin(), displays.cend(), [](const auto& pair) {
+        const auto& state = pair.second->getCompositionDisplay()->getState();
+        return state.usesClientComposition && !state.reusedClientComposition;
+    });
+    mHadDeviceComposition = std::any_of(displays.cbegin(), displays.cend(), [](const auto& pair) {
+        const auto& state = pair.second->getCompositionDisplay()->getState();
+        return state.usesDeviceComposition;
+    });
+    mReusedClientComposition =
+            std::any_of(displays.cbegin(), displays.cend(), [](const auto& pair) {
+                const auto& state = pair.second->getCompositionDisplay()->getState();
+                return state.reusedClientComposition;
+            });
+    if (prevFrameHadDeviceComposition != mHadDeviceComposition) {
+        mTimeStats->incrementCompositionStrategyChanges();
@@ -1558,3 +1567,6 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
+    mVSyncModulator->onRefreshed(mHadClientComposition);
+    mLayersWithQueuedFrames.clear();
+    if (mVisibleRegionsDirty) {
+        mVisibleRegionsDirty = false;
+        if (mTracingEnabled && mAddCompositionStateToTrace) {
+            mTracing.notify("visibleRegionsDirty");
@@ -1563,4 +1575,2 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
+    if (mCompositionEngine->needsAnotherUpdate()) {
+        signalLayerUpdate();
@@ -1568,7 +1577,0 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
@@ -1576,6 +1579,84 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
+bool SurfaceFlinger::handleMessageInvalidate() {
+    ATRACE_CALL();
+    bool refreshNeeded = handlePageFlip();
+    if (mVisibleRegionsDirty) {
+        computeLayerBounds();
+    }
+    for (auto& layer : mLayersPendingRefresh) {
+        Region visibleReg;
+        visibleReg.set(layer->getScreenBounds());
+        invalidateLayerStack(layer, visibleReg);
+    }
+    mLayersPendingRefresh.clear();
+    return refreshNeeded;
+}
+void SurfaceFlinger::updateCompositorTiming(const DisplayStatInfo& stats, nsecs_t compositeTime,
+                                            std::shared_ptr<FenceTime>& presentFenceTime) {
+    getBE().mCompositePresentTimes.push({compositeTime, presentFenceTime});
+    nsecs_t compositeToPresentLatency = -1;
+    while (!getBE().mCompositePresentTimes.empty()) {
+        SurfaceFlingerBE::CompositePresentTime& cpt = getBE().mCompositePresentTimes.front();
+        nsecs_t displayTime = cpt.display->getCachedSignalTime();
+        if (displayTime == Fence::SIGNAL_TIME_PENDING) {
+            break;
+        }
+        compositeToPresentLatency = displayTime - cpt.composite;
+        getBE().mCompositePresentTimes.pop();
+    }
+    while (getBE().mCompositePresentTimes.size() > 16) {
+        getBE().mCompositePresentTimes.pop();
+    }
+    setCompositorTimingSnapped(stats, compositeToPresentLatency);
+}
+void SurfaceFlinger::setCompositorTimingSnapped(const DisplayStatInfo& stats,
+                                                nsecs_t compositeToPresentLatency) {
+    nsecs_t idealLatency = (mPhaseConfiguration->getCurrentOffsets().late.sf > 0)
+            ? (stats.vsyncPeriod -
+               (mPhaseConfiguration->getCurrentOffsets().late.sf % stats.vsyncPeriod))
+            : ((-mPhaseConfiguration->getCurrentOffsets().late.sf) % stats.vsyncPeriod);
+    if (idealLatency <= 0) {
+        idealLatency = stats.vsyncPeriod;
+    }
+    nsecs_t bias = stats.vsyncPeriod / 2;
+    int64_t extraVsyncs = (compositeToPresentLatency - idealLatency + bias) / stats.vsyncPeriod;
+    nsecs_t snappedCompositeToPresentLatency =
+            (extraVsyncs > 0) ? idealLatency + (extraVsyncs * stats.vsyncPeriod) : idealLatency;
+    std::lock_guard<std::mutex> lock(getBE().mCompositorTimingLock);
+    getBE().mCompositorTiming.deadline = stats.vsyncTime - idealLatency;
+    getBE().mCompositorTiming.interval = stats.vsyncPeriod;
+    getBE().mCompositorTiming.presentLatency = snappedCompositeToPresentLatency;
+}
+void SurfaceFlinger::postComposition()
+{
+    ATRACE_CALL();
+    ALOGV("postComposition");
+    nsecs_t dequeueReadyTime = systemTime();
+    for (auto& layer : mLayersWithQueuedFrames) {
+        layer->releasePendingBuffer(dequeueReadyTime);
+    }
+    const auto* display = ON_MAIN_THREAD(getDefaultDisplayDeviceLocked()).get();
+    getBE().mGlCompositionDoneTimeline.updateSignalTimes();
+    std::shared_ptr<FenceTime> glCompositionDoneFenceTime;
+    if (display && display->getCompositionDisplay()->getState().usesClientComposition) {
+        glCompositionDoneFenceTime =
+                std::make_shared<FenceTime>(display->getCompositionDisplay()
+                                                    ->getRenderSurface()
+                                                    ->getClientTargetAcquireFence());
+        getBE().mGlCompositionDoneTimeline.push(glCompositionDoneFenceTime);
+    } else {
+        glCompositionDoneFenceTime = FenceTime::NO_FENCE;
+    }
+    getBE().mDisplayTimeline.updateSignalTimes();
+    mPreviousPresentFences[1] = mPreviousPresentFences[0];
+    mPreviousPresentFences[0] =
+            display ? getHwComposer().getPresentFence(*display->getId()) : Fence::NO_FENCE;
+    auto presentFenceTime = std::make_shared<FenceTime>(mPreviousPresentFences[0]);
+    getBE().mDisplayTimeline.push(presentFenceTime);
+    DisplayStatInfo stats;
+    mScheduler->getDisplayStatInfo(&stats);
+    updateCompositorTiming(stats, mCompositionEngine->getLastFrameRefreshTimestamp(),
+                           presentFenceTime);
+    CompositorTiming compositorTiming;
+    {
+        std::lock_guard<std::mutex> lock(getBE().mCompositorTimingLock);
+        compositorTiming = getBE().mCompositorTiming;
@@ -1583,3 +1664,5 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
+    mDrawingState.traverse([&](Layer* layer) {
+        const bool frameLatched = layer->onPostComposition(display, glCompositionDoneFenceTime,
+                                                           presentFenceTime, compositorTiming);
+        if (frameLatched) {
+            recordBufferingStats(layer->getName(), layer->getOccupancyHistory(false));
@@ -1586,0 +1670,55 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
+    });
+    mTransactionCompletedThread.addPresentFence(mPreviousPresentFences[0]);
+    mTransactionCompletedThread.sendCallbacks();
+    if (display && display->isPrimary() && display->getPowerMode() == hal::PowerMode::ON &&
+        presentFenceTime->isValid()) {
+        mScheduler->addPresentFence(presentFenceTime);
+    }
+    const bool isDisplayConnected = display && getHwComposer().isConnected(*display->getId());
+    if (!hasSyncFramework) {
+        if (isDisplayConnected && display->isPoweredOn()) {
+            mScheduler->enableHardwareVsync();
+        }
+    }
+    if (mAnimCompositionPending) {
+        mAnimCompositionPending = false;
+        if (presentFenceTime->isValid()) {
+            mAnimFrameTracker.setActualPresentFence(
+                    std::move(presentFenceTime));
+        } else if (isDisplayConnected) {
+            const nsecs_t presentTime = getHwComposer().getRefreshTimestamp(*display->getId());
+            mAnimFrameTracker.setActualPresentTime(presentTime);
+        }
+        mAnimFrameTracker.advanceFrame();
+    }
+    mTimeStats->incrementTotalFrames();
+    if (mHadClientComposition) {
+        mTimeStats->incrementClientCompositionFrames();
+    }
+    if (mReusedClientComposition) {
+        mTimeStats->incrementClientCompositionReusedFrames();
+    }
+    mTimeStats->setPresentFenceGlobal(presentFenceTime);
+    const size_t sfConnections = mScheduler->getEventThreadConnectionCount(mSfConnectionHandle);
+    const size_t appConnections = mScheduler->getEventThreadConnectionCount(mAppConnectionHandle);
+    mTimeStats->recordDisplayEventConnectionCount(sfConnections + appConnections);
+    if (mLastJankDuration > 0) {
+        ATRACE_NAME("Jank detected");
+        const int32_t jankyDurationMillis = mLastJankDuration / (1000 * 1000);
+        android::util::stats_write(android::util::DISPLAY_JANK_REPORTED, jankyDurationMillis,
+                                   mMissedFrameJankCount);
+        mLastJankDuration = -1;
+    }
+    if (isDisplayConnected && !display->isPoweredOn()) {
+        return;
+    }
+    nsecs_t currentTime = systemTime();
+    if (mHasPoweredOff) {
+        mHasPoweredOff = false;
+    } else {
+        nsecs_t elapsedTime = currentTime - getBE().mLastSwapTime;
+        size_t numPeriods = static_cast<size_t>(elapsedTime / stats.vsyncPeriod);
+        if (numPeriods < SurfaceFlingerBE::NUM_BUCKETS - 1) {
+            getBE().mFrameBuckets[numPeriods] += elapsedTime;
+        } else {
+            getBE().mFrameBuckets[SurfaceFlingerBE::NUM_BUCKETS - 1] += elapsedTime;
@@ -1588,4 +1726 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
+        getBE().mTotalTime += elapsedTime;
@@ -1593,7 +1728,16 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
+    getBE().mLastSwapTime = currentTime;
+    getRenderEngine().cleanupPostRender();
+    {
+        std::lock_guard lock(mTexturePoolMutex);
+        if (mTexturePool.size() < mTexturePoolSize) {
+            const size_t refillCount = mTexturePoolSize - mTexturePool.size();
+            const size_t offset = mTexturePool.size();
+            mTexturePool.resize(mTexturePoolSize);
+            getRenderEngine().genTextures(refillCount, mTexturePool.data() + offset);
+            ATRACE_INT("TexturePoolSize", mTexturePool.size());
+        } else if (mTexturePool.size() > mTexturePoolSize) {
+            const size_t deleteCount = mTexturePool.size() - mTexturePoolSize;
+            const size_t offset = mTexturePoolSize;
+            getRenderEngine().deleteTextures(deleteCount, mTexturePool.data() + offset);
+            mTexturePool.resize(mTexturePoolSize);
+            ATRACE_INT("TexturePoolSize", mTexturePool.size());
@@ -1601,6 +1744,0 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
@@ -1608,3 +1746,2 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
+    if (mLumaSampling && mRegionSamplingThread) {
+        mRegionSamplingThread->notifyNewContent();
@@ -1611,0 +1749,2 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
+    if (ATRACE_ENABLED()) {
+        ATRACE_INT64("Total Buffer Size", GraphicBufferAllocator::get().getTotalSize());
@@ -1613,4 +1751,0 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
@@ -1618,7 +1753,2 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
+FloatRect SurfaceFlinger::getLayerClipBoundsForDisplay(const DisplayDevice& displayDevice) const {
+    return displayDevice.getViewport().toFloatRect();
@@ -1626,6 +1756,7 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
+void SurfaceFlinger::computeLayerBounds() {
+    for (const auto& pair : ON_MAIN_THREAD(mDisplays)) {
+        const auto& displayDevice = pair.second;
+        const auto display = displayDevice->getCompositionDisplay();
+        for (const auto& layer : mDrawingState.layersSortedByZ) {
+            if (!display->belongsInOutput(layer->getLayerStack(), layer->getPrimaryDisplayOnly())) {
+                continue;
@@ -1633,3 +1764,2 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
+            layer->computeBounds(getLayerClipBoundsForDisplay(*displayDevice), ui::Transform(),
+                                 0.f );
@@ -1638,4 +1767,0 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
@@ -1643,7 +1769,6 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
+void SurfaceFlinger::postFrame() {
+    const auto display = ON_MAIN_THREAD(getDefaultDisplayDeviceLocked());
+    if (display && getHwComposer().isConnected(*display->getId())) {
+        uint32_t flipCount = display->getPageFlipCount();
+        if (flipCount % LOG_FRAME_STATS_PERIOD == 0) {
+            logFrameStats();
@@ -1651,6 +1775,0 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
@@ -1658,3 +1776,0 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
@@ -1661,0 +1778,18 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
+void SurfaceFlinger::handleTransaction(uint32_t transactionFlags)
+{
+    ATRACE_CALL();
+    State drawingState(mDrawingState);
+    Mutex::Autolock _l(mStateLock);
+    mDebugInTransaction = systemTime();
+    mVSyncModulator->onTransactionHandled();
+    transactionFlags = getTransactionFlags(eTransactionMask);
+    handleTransactionLocked(transactionFlags);
+    mDebugInTransaction = 0;
+    invalidateHwcGeometry();
+}
+void SurfaceFlinger::processDisplayHotplugEventsLocked() {
+    for (const auto& event : mPendingHotplugEvents) {
+        const std::optional<DisplayIdentificationInfo> info =
+                getHwComposer().onHotplug(event.hwcDisplayId, event.connection);
+        if (!info) {
+            continue;
@@ -1663,4 +1797,7 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
+        const DisplayId displayId = info->id;
+        const auto it = mPhysicalDisplayTokens.find(displayId);
+        if (event.connection == hal::Connection::CONNECTED) {
+            if (it == mPhysicalDisplayTokens.end()) {
+                ALOGV("Creating display %s", to_string(displayId).c_str());
+                if (event.hwcDisplayId == getHwComposer().getInternalHwcDisplayId()) {
+                    initScheduler(displayId);
@@ -1668,7 +1805,14 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
+                DisplayDeviceState state;
+                state.physical = {displayId, getHwComposer().getDisplayConnectionType(displayId),
+                                  event.hwcDisplayId};
+                state.isSecure = true;
+                state.displayName = info->name;
+                sp<IBinder> token = new BBinder();
+                mCurrentState.displays.add(token, state);
+                mPhysicalDisplayTokens.emplace(displayId, std::move(token));
+                mInterceptor->saveDisplayCreation(state);
+            } else {
+                ALOGV("Recreating display %s", to_string(displayId).c_str());
+                const auto token = it->second;
+                auto& state = mCurrentState.displays.editValueFor(token);
+                state.sequenceId = DisplayDeviceState{}.sequenceId;
@@ -1676,6 +1820,7 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
+        } else {
+            ALOGV("Removing display %s", to_string(displayId).c_str());
+            const ssize_t index = mCurrentState.displays.indexOfKey(it->second);
+            if (index >= 0) {
+                const DisplayDeviceState& state = mCurrentState.displays.valueAt(index);
+                mInterceptor->saveDisplayDeletion(state.sequenceId);
+                mCurrentState.displays.removeItemsAt(index);
@@ -1683,3 +1828,71 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
+            mPhysicalDisplayTokens.erase(it);
+        }
+        processDisplayChangesLocked();
+    }
+    mPendingHotplugEvents.clear();
+}
+void SurfaceFlinger::dispatchDisplayHotplugEvent(PhysicalDisplayId displayId, bool connected) {
+    mScheduler->onHotplugReceived(mAppConnectionHandle, displayId, connected);
+    mScheduler->onHotplugReceived(mSfConnectionHandle, displayId, connected);
+}
+sp<DisplayDevice> SurfaceFlinger::setupNewDisplayDeviceInternal(
+        const wp<IBinder>& displayToken,
+        std::shared_ptr<compositionengine::Display> compositionDisplay,
+        const DisplayDeviceState& state,
+        const sp<compositionengine::DisplaySurface>& displaySurface,
+        const sp<IGraphicBufferProducer>& producer) {
+    auto displayId = compositionDisplay->getDisplayId();
+    DisplayDeviceCreationArgs creationArgs(this, displayToken, compositionDisplay);
+    creationArgs.sequenceId = state.sequenceId;
+    creationArgs.isSecure = state.isSecure;
+    creationArgs.displaySurface = displaySurface;
+    creationArgs.hasWideColorGamut = false;
+    creationArgs.supportedPerFrameMetadata = 0;
+    if (const auto& physical = state.physical) {
+        creationArgs.connectionType = physical->type;
+    }
+    const bool isInternalDisplay = displayId && displayId == getInternalDisplayIdLocked();
+    creationArgs.isPrimary = isInternalDisplay;
+    if (useColorManagement && displayId) {
+        std::vector<ColorMode> modes = getHwComposer().getColorModes(*displayId);
+        for (ColorMode colorMode : modes) {
+            if (isWideColorMode(colorMode)) {
+                creationArgs.hasWideColorGamut = true;
+            }
+            std::vector<RenderIntent> renderIntents =
+                    getHwComposer().getRenderIntents(*displayId, colorMode);
+            creationArgs.hwcColorModes.emplace(colorMode, renderIntents);
+        }
+    }
+    if (displayId) {
+        getHwComposer().getHdrCapabilities(*displayId, &creationArgs.hdrCapabilities);
+        creationArgs.supportedPerFrameMetadata =
+                getHwComposer().getSupportedPerFrameMetadata(*displayId);
+    }
+    auto nativeWindowSurface = getFactory().createNativeWindowSurface(producer);
+    auto nativeWindow = nativeWindowSurface->getNativeWindow();
+    creationArgs.nativeWindow = nativeWindow;
+    if (state.isVirtual()) {
+        nativeWindow->setSwapInterval(nativeWindow.get(), 0);
+    }
+    creationArgs.physicalOrientation =
+            isInternalDisplay ? internalDisplayOrientation : ui::ROTATION_0;
+    creationArgs.initialPowerMode = state.isVirtual() ? hal::PowerMode::ON : hal::PowerMode::OFF;
+    sp<DisplayDevice> display = getFactory().createDisplayDevice(creationArgs);
+    if (maxFrameBufferAcquiredBuffers >= 3) {
+        nativeWindowSurface->preallocateBuffers();
+    }
+    ColorMode defaultColorMode = ColorMode::NATIVE;
+    Dataspace defaultDataSpace = Dataspace::UNKNOWN;
+    if (display->hasWideColorGamut()) {
+        defaultColorMode = ColorMode::SRGB;
+        defaultDataSpace = Dataspace::V0_SRGB;
+    }
+    display->getCompositionDisplay()->setColorProfile(
+            compositionengine::Output::ColorProfile{defaultColorMode, defaultDataSpace,
+                                                    RenderIntent::COLORIMETRIC,
+                                                    Dataspace::UNKNOWN});
+    if (!state.isVirtual()) {
+        LOG_ALWAYS_FATAL_IF(!displayId);
+        auto activeConfigId = HwcConfigIndexType(getHwComposer().getActiveConfigIndex(*displayId));
+        display->setActiveConfig(activeConfigId);
@@ -1686,0 +1900,4 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
+    display->setLayerStack(state.layerStack);
+    display->setProjection(state.orientation, state.viewport, state.frame);
+    display->setDisplayName(state.displayName);
+    return display;
@@ -1688,3 +1905,21 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
+void SurfaceFlinger::processDisplayAdded(const wp<IBinder>& displayToken,
+                                         const DisplayDeviceState& state) {
+    int width = 0;
+    int height = 0;
+    ui::PixelFormat pixelFormat = static_cast<ui::PixelFormat>(PIXEL_FORMAT_UNKNOWN);
+    if (state.physical) {
+        const auto& activeConfig =
+                getCompositionEngine().getHwComposer().getActiveConfig(state.physical->id);
+        width = activeConfig->getWidth();
+        height = activeConfig->getHeight();
+        pixelFormat = static_cast<ui::PixelFormat>(PIXEL_FORMAT_RGBA_8888);
+    } else if (state.surface != nullptr) {
+        int status = state.surface->query(NATIVE_WINDOW_WIDTH, &width);
+        ALOGE_IF(status != NO_ERROR, "Unable to query width (%d)", status);
+        status = state.surface->query(NATIVE_WINDOW_HEIGHT, &height);
+        ALOGE_IF(status != NO_ERROR, "Unable to query height (%d)", status);
+        int intPixelFormat;
+        status = state.surface->query(NATIVE_WINDOW_FORMAT, &intPixelFormat);
+        ALOGE_IF(status != NO_ERROR, "Unable to query format (%d)", status);
+        pixelFormat = static_cast<ui::PixelFormat>(intPixelFormat);
+    } else {
@@ -1693,7 +1928,41 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
+    compositionengine::DisplayCreationArgsBuilder builder;
+    if (const auto& physical = state.physical) {
+        builder.setPhysical({physical->id, physical->type});
+    }
+    builder.setPixels(ui::Size(width, height));
+    builder.setPixelFormat(pixelFormat);
+    builder.setIsSecure(state.isSecure);
+    builder.setLayerStackId(state.layerStack);
+    builder.setPowerAdvisor(&mPowerAdvisor);
+    builder.setUseHwcVirtualDisplays(mUseHwcVirtualDisplays || getHwComposer().isUsingVrComposer());
+    builder.setName(state.displayName);
+    const auto compositionDisplay = getCompositionEngine().createDisplay(builder.build());
+    sp<compositionengine::DisplaySurface> displaySurface;
+    sp<IGraphicBufferProducer> producer;
+    sp<IGraphicBufferProducer> bqProducer;
+    sp<IGraphicBufferConsumer> bqConsumer;
+    getFactory().createBufferQueue(&bqProducer, &bqConsumer, false);
+    std::optional<DisplayId> displayId = compositionDisplay->getId();
+    if (state.isVirtual()) {
+        sp<VirtualDisplaySurface> vds =
+                new VirtualDisplaySurface(getHwComposer(), displayId, state.surface, bqProducer,
+                                          bqConsumer, state.displayName);
+        displaySurface = vds;
+        producer = vds;
+    } else {
+        ALOGE_IF(state.surface != nullptr,
+                 "adding a supported display, but rendering "
+                 "surface is provided (%p), ignoring it",
+                 state.surface.get());
+        LOG_ALWAYS_FATAL_IF(!displayId);
+        displaySurface = new FramebufferSurface(getHwComposer(), *displayId, bqConsumer,
+                                                maxGraphicsWidth, maxGraphicsHeight);
+        producer = bqProducer;
+    }
+    LOG_FATAL_IF(!displaySurface);
+    const auto display = setupNewDisplayDeviceInternal(displayToken, compositionDisplay, state,
+                                                       displaySurface, producer);
+    mDisplays.emplace(displayToken, display);
+    if (!state.isVirtual()) {
+        LOG_FATAL_IF(!displayId);
+        dispatchDisplayHotplugEvent(displayId->value, true);
@@ -1701,6 +1970,2 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
+    if (display->isPrimary()) {
+        mScheduler->onPrimaryDisplayAreaChanged(display->getWidth() * display->getHeight());
@@ -1708,3 +1972,0 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
@@ -1711,0 +1974,7 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
+void SurfaceFlinger::processDisplayRemoved(const wp<IBinder>& displayToken) {
+    if (const auto display = getDisplayDeviceLocked(displayToken)) {
+        const auto displayId = display->getId();
+        display->disconnect();
+        if (!display->isVirtual()) {
+            LOG_FATAL_IF(!displayId);
+            dispatchDisplayHotplugEvent(displayId->value, false);
@@ -1713,4 +1981,0 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
@@ -1718,7 +1983 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
+    mDisplays.erase(displayToken);
@@ -1726,6 +1985,8 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
+void SurfaceFlinger::processDisplayChanged(const wp<IBinder>& displayToken,
+                                           const DisplayDeviceState& currentState,
+                                           const DisplayDeviceState& drawingState) {
+    const sp<IBinder> currentBinder = IInterface::asBinder(currentState.surface);
+    const sp<IBinder> drawingBinder = IInterface::asBinder(drawingState.surface);
+    if (currentBinder != drawingBinder || currentState.sequenceId != drawingState.sequenceId) {
+        if (const auto display = getDisplayDeviceLocked(displayToken)) {
+            display->disconnect();
@@ -1733,3 +1994,3 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
+        mDisplays.erase(displayToken);
+        if (const auto& physical = currentState.physical) {
+            getHwComposer().allocatePhysicalDisplay(physical->hwcDisplayId, physical->id);
@@ -1736,0 +1998,4 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
+        processDisplayAdded(displayToken, currentState);
+        if (currentState.physical) {
+            const auto display = getDisplayDeviceLocked(displayToken);
+            setPowerModeInternal(display, hal::PowerMode::ON);
@@ -1738,3 +2002,0 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
@@ -1743,7 +2005,15 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
+    if (const auto display = getDisplayDeviceLocked(displayToken)) {
+        if (currentState.layerStack != drawingState.layerStack) {
+            display->setLayerStack(currentState.layerStack);
+        }
+        if ((currentState.orientation != drawingState.orientation) ||
+            (currentState.viewport != drawingState.viewport) ||
+            (currentState.frame != drawingState.frame)) {
+            display->setProjection(currentState.orientation, currentState.viewport,
+                                   currentState.frame);
+        }
+        if (currentState.width != drawingState.width ||
+            currentState.height != drawingState.height) {
+            display->setDisplaySize(currentState.width, currentState.height);
+            if (display->isPrimary()) {
+                mScheduler->onPrimaryDisplayAreaChanged(currentState.width * currentState.height);
@@ -1751,6 +2021,2 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
+            if (mRefreshRateOverlay) {
+                mRefreshRateOverlay->setViewport(display->getSize());
@@ -1758,3 +2023,0 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
@@ -1763,4 +2025,0 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
@@ -1768,7 +2027,14 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
+void SurfaceFlinger::processDisplayChangesLocked() {
+    const KeyedVector<wp<IBinder>, DisplayDeviceState>& curr(mCurrentState.displays);
+    const KeyedVector<wp<IBinder>, DisplayDeviceState>& draw(mDrawingState.displays);
+    if (!curr.isIdenticalTo(draw)) {
+        mVisibleRegionsDirty = true;
+        for (size_t i = 0; i < draw.size(); i++) {
+            const wp<IBinder>& displayToken = draw.keyAt(i);
+            const ssize_t j = curr.indexOfKey(displayToken);
+            if (j < 0) {
+                processDisplayRemoved(displayToken);
+            } else {
+                const DisplayDeviceState& currentState = curr[j];
+                const DisplayDeviceState& drawingState = draw[i];
+                processDisplayChanged(displayToken, currentState, drawingState);
@@ -1776,6 +2041,0 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
@@ -1783,3 +2043,4 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
+        for (size_t i = 0; i < curr.size(); i++) {
+            const wp<IBinder>& displayToken = curr.keyAt(i);
+            if (draw.indexOfKey(displayToken) < 0) {
+                processDisplayAdded(displayToken, curr[i]);
@@ -1788,4 +2048,0 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
@@ -1793,7 +2050 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
+    mDrawingState.displays = mCurrentState.displays;
@@ -1801,6 +2052,16 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
+void SurfaceFlinger::handleTransactionLocked(uint32_t transactionFlags)
+{
+    const nsecs_t expectedPresentTime = mExpectedPresentTime.load();
+    mCurrentState.traverse([expectedPresentTime](Layer* layer) {
+        layer->notifyAvailableFrames(expectedPresentTime);
+    });
+    if ((transactionFlags & eTraversalNeeded) || mForceTraversal) {
+        mForceTraversal = false;
+        mCurrentState.traverse([&](Layer* layer) {
+            uint32_t trFlags = layer->getTransactionFlags(eTransactionNeeded);
+            if (!trFlags) return;
+            const uint32_t flags = layer->doTransaction(0);
+            if (flags & Layer::eVisibleRegion)
+                mVisibleRegionsDirty = true;
+            if (flags & Layer::eInputInfoChanged) {
+                mInputInfoChanged = true;
@@ -1807,0 +2069,21 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
+        });
+    }
+    if (transactionFlags & eDisplayTransactionNeeded) {
+        processDisplayChangesLocked();
+        processDisplayHotplugEventsLocked();
+    }
+    if (transactionFlags & (eTransformHintUpdateNeeded | eDisplayTransactionNeeded)) {
+        sp<const DisplayDevice> hintDisplay;
+        uint32_t currentlayerStack = 0;
+        bool first = true;
+        mCurrentState.traverse([&](Layer* layer) REQUIRES(mStateLock) {
+            uint32_t layerStack = layer->getLayerStack();
+            if (first || currentlayerStack != layerStack) {
+                currentlayerStack = layerStack;
+                hintDisplay = nullptr;
+                for (const auto& [token, display] : mDisplays) {
+                    if (display->getCompositionDisplay()
+                                ->belongsInOutput(layer->getLayerStack(),
+                                                  layer->getPrimaryDisplayOnly())) {
+                        if (hintDisplay) {
+                            hintDisplay = nullptr;
@@ -1809,2 +2091,2 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-        case KernelIdleTimerAction::NoChange:
-            break;
+                        } else {
+                            hintDisplay = display;
@@ -1813,4 +2094,0 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
@@ -1818,7 +2095,0 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
@@ -1826,10 +2097,2 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
-            }
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
+            if (!hintDisplay) {
+                hintDisplay = getDefaultDisplayDeviceLocked();
@@ -1836,0 +2100,2 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
+            if (hintDisplay) {
+                layer->updateTransformHint(hintDisplay->getTransformHint());
@@ -1838,4 +2103,2 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
+            first = false;
+        });
@@ -1843,7 +2106,3 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
+    if (mLayersAdded) {
+        mLayersAdded = false;
+        mVisibleRegionsDirty = true;
@@ -1851,6 +2110,8 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
+    if (mLayersRemoved) {
+        mLayersRemoved = false;
+        mVisibleRegionsDirty = true;
+        mDrawingState.traverseInZOrder([&](Layer* layer) {
+            if (mLayersPendingRemoval.indexOf(layer) >= 0) {
+                Region visibleReg;
+                visibleReg.set(layer->getScreenBounds());
+                invalidateLayerStack(layer, visibleReg);
@@ -1858,3 +2119 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
+        });
@@ -1861,0 +2121,2 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
+    commitInputWindowCommands();
+    commitTransaction();
@@ -1863,3 +2124,3 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
+void SurfaceFlinger::updateInputFlinger() {
+    ATRACE_CALL();
+    if (!mInputFlinger) {
@@ -1868,7 +2129,5 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
+    if (mVisibleRegionsDirty || mInputInfoChanged) {
+        mInputInfoChanged = false;
+        updateInputWindowInfo();
+    } else if (mInputWindowCommands.syncInputWindows) {
+        setInputWindowsFinished();
@@ -1876,6 +2135 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
+    mInputWindowCommands.clear();
@@ -1883,3 +2137,5 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
+void SurfaceFlinger::updateInputWindowInfo() {
+    std::vector<InputWindowInfo> inputHandles;
+    mDrawingState.traverseInReverseZOrder([&](Layer* layer) {
+        if (layer->needsInputInfo()) {
+            inputHandles.push_back(layer->fillInputInfo());
@@ -1886,0 +2143,4 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
+    });
+    mInputFlinger->setInputWindows(inputHandles,
+                                   mInputWindowCommands.syncInputWindows ? mSetInputWindowsListener
+                                                                         : nullptr);
@@ -1888,4 +2148,3 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
+void SurfaceFlinger::commitInputWindowCommands() {
+    mInputWindowCommands.merge(mPendingInputWindowCommands);
+    mPendingInputWindowCommands.clear();
@@ -1893,7 +2152,5 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
+void SurfaceFlinger::updateCursorAsync() {
+    compositionengine::CompositionRefreshArgs refreshArgs;
+    for (const auto& [_, display] : ON_MAIN_THREAD(mDisplays)) {
+        if (display->getId()) {
+            refreshArgs.outputs.push_back(display->getCompositionDisplay());
@@ -1901,6 +2157,0 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
@@ -1908,3 +2159 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
+    mCompositionEngine->updateCursorAsync(refreshArgs);
@@ -1911,0 +2161,41 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
+void SurfaceFlinger::changeRefreshRate(const RefreshRate& refreshRate,
+                                       Scheduler::ConfigEvent event) {
+    ConditionalLock lock(mStateLock, std::this_thread::get_id() != mMainThreadId);
+    changeRefreshRateLocked(refreshRate, event);
+}
+void SurfaceFlinger::initScheduler(DisplayId primaryDisplayId) {
+    if (mScheduler) {
+        ALOGW("Can't re-init scheduler");
+        return;
+    }
+    auto currentConfig = HwcConfigIndexType(getHwComposer().getActiveConfigIndex(primaryDisplayId));
+    mRefreshRateConfigs =
+            std::make_unique<scheduler::RefreshRateConfigs>(getHwComposer().getConfigs(
+                                                                    primaryDisplayId),
+                                                            currentConfig);
+    mRefreshRateStats =
+            std::make_unique<scheduler::RefreshRateStats>(*mRefreshRateConfigs, *mTimeStats,
+                                                          currentConfig, hal::PowerMode::OFF);
+    mRefreshRateStats->setConfigMode(currentConfig);
+    mPhaseConfiguration = getFactory().createPhaseConfiguration(*mRefreshRateConfigs);
+    mScheduler =
+            getFactory().createScheduler([this](bool enabled) { setPrimaryVsyncEnabled(enabled); },
+                                         *mRefreshRateConfigs, *this);
+    mAppConnectionHandle =
+            mScheduler->createConnection("app", mPhaseConfiguration->getCurrentOffsets().late.app,
+                                         impl::EventThread::InterceptVSyncsCallback());
+    mSfConnectionHandle =
+            mScheduler->createConnection("sf", mPhaseConfiguration->getCurrentOffsets().late.sf,
+                                         [this](nsecs_t timestamp) {
+                                             mInterceptor->saveVSyncEvent(timestamp);
+                                         });
+    mEventQueue->setEventConnection(mScheduler->getEventConnection(mSfConnectionHandle));
+    mVSyncModulator.emplace(*mScheduler, mAppConnectionHandle, mSfConnectionHandle,
+                            mPhaseConfiguration->getCurrentOffsets());
+    mRegionSamplingThread =
+            new RegionSamplingThread(*this, *mScheduler,
+                                     RegionSamplingThread::EnvironmentTimingTunables());
+    const nsecs_t vsyncPeriod =
+            mRefreshRateConfigs->getRefreshRateFromConfigId(currentConfig).getVsyncPeriod();
+    mScheduler->onPrimaryDisplayConfigChanged(mAppConnectionHandle, primaryDisplayId.value,
+                                              currentConfig, vsyncPeriod);
@@ -1913,4 +2203,6 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
+void SurfaceFlinger::commitTransaction()
+{
+    commitTransactionLocked();
+    mTransactionPending = false;
+    mAnimTransactionPending = false;
+    mTransactionCV.broadcast();
@@ -1918,7 +2210,6 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
+void SurfaceFlinger::commitTransactionLocked() {
+    if (!mLayersPendingRemoval.isEmpty()) {
+        for (const auto& l : mLayersPendingRemoval) {
+            recordBufferingStats(l->getName(), l->getOccupancyHistory(true));
+            if (l->isRemovedFromCurrentState()) {
+                l->latchAndReleaseBuffer();
@@ -1926,6 +2217,2 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
+            if (!l->getParent()) {
+                mOffscreenLayers.emplace(l.get());
@@ -1933,3 +2219,0 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
@@ -1936,0 +2221 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
+        mLayersPendingRemoval.clear();
@@ -1938,4 +2223,7 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
+    mAnimCompositionPending = mAnimTransactionPending;
+    mDrawingState = mCurrentState;
+    mCurrentState.colorMatrixChanged = false;
+    mDrawingState.traverse([&](Layer* layer) {
+        layer->commitChildList();
+        if (mOffscreenLayers.count(layer)) {
+            mOffscreenLayers.erase(layer);
@@ -1943,7 +2231,12 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
+    });
+    commitOffscreenLayers();
+    mDrawingState.traverse([&](Layer* layer) { layer->updateMirrorInfo(); });
+}
+void SurfaceFlinger::commitOffscreenLayers() {
+    for (Layer* offscreenLayer : mOffscreenLayers) {
+        offscreenLayer->traverse(LayerVector::StateSet::Drawing, [](Layer* layer) {
+            uint32_t trFlags = layer->getTransactionFlags(eTransactionNeeded);
+            if (!trFlags) return;
+            layer->doTransaction(0);
+            layer->commitChildList();
+        });
@@ -1951,6 +2243,0 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
@@ -1958,3 +2245,5 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
+void SurfaceFlinger::invalidateLayerStack(const sp<const Layer>& layer, const Region& dirty) {
+    for (const auto& [token, displayDevice] : ON_MAIN_THREAD(mDisplays)) {
+        auto display = displayDevice->getCompositionDisplay();
+        if (display->belongsInOutput(layer->getLayerStack(), layer->getPrimaryDisplayOnly())) {
+            display->editState().dirtyRegion.orSelf(dirty);
@@ -1963,4 +2251,0 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
@@ -1968,7 +2253,17 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
+bool SurfaceFlinger::handlePageFlip()
+{
+    ATRACE_CALL();
+    ALOGV("handlePageFlip");
+    nsecs_t latchTime = systemTime();
+    bool visibleRegions = false;
+    bool frameQueued = false;
+    bool newDataLatched = false;
+    const nsecs_t expectedPresentTime = mExpectedPresentTime.load();
+    mDrawingState.traverse([&](Layer* layer) {
+        if (layer->hasReadyFrame()) {
+            frameQueued = true;
+            if (layer->shouldPresentNow(expectedPresentTime)) {
+                mLayersWithQueuedFrames.push_back(layer);
+            } else {
+                ATRACE_NAME("!layer->shouldPresentNow()");
+                layer->useEmptyDamage();
@@ -1976,6 +2271,2 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
+        } else {
+            layer->useEmptyDamage();
@@ -1983,3 +2274,4 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
+    });
+    for (Layer* offscreenLayer : mOffscreenLayers) {
+        offscreenLayer->traverse(LayerVector::StateSet::Drawing,
+                                         [&](Layer* l) { l->latchAndReleaseBuffer(); });
@@ -1986,0 +2279,5 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
+    if (!mLayersWithQueuedFrames.empty()) {
+        Mutex::Autolock lock(mStateLock);
+        for (auto& layer : mLayersWithQueuedFrames) {
+            if (layer->latchBuffer(visibleRegions, latchTime, expectedPresentTime)) {
+                mLayersPendingRefresh.push_back(layer);
@@ -1988,4 +2285,3 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
+            layer->useSurfaceDamage();
+            if (layer->isBufferLatched()) {
+                newDataLatched = true;
@@ -1993,7 +2288,0 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
@@ -2001,6 +2289,0 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
@@ -2008,3 +2291,3 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
+    mVisibleRegionsDirty |= visibleRegions;
+    if (frameQueued && (mLayersWithQueuedFrames.empty() || !newDataLatched)) {
+        signalLayerUpdate();
@@ -2011,0 +2295,3 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
+    if (CC_UNLIKELY(mBootStage == BootStage::BOOTLOADER && newDataLatched)) {
+        ALOGI("Enter boot animation");
+        mBootStage = BootStage::BOOTANIMATION;
@@ -2013,4 +2299,2 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
+    mDrawingState.traverse([&](Layer* layer) { layer->updateCloneBufferInfo(); });
+    return !mLayersWithQueuedFrames.empty() && newDataLatched;
@@ -2018,7 +2302,3 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
+void SurfaceFlinger::invalidateHwcGeometry()
+{
+    mGeometryInvalid = true;
@@ -2026,6 +2306,12 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
+status_t SurfaceFlinger::addClientLayer(const sp<Client>& client, const sp<IBinder>& handle,
+                                        const sp<IGraphicBufferProducer>& gbc, const sp<Layer>& lbc,
+                                        const sp<IBinder>& parentHandle,
+                                        const sp<Layer>& parentLayer, bool addToCurrentState,
+                                        uint32_t* outTransformHint) {
+    {
+        Mutex::Autolock _l(mStateLock);
+        sp<Layer> parent;
+        if (parentHandle != nullptr) {
+            parent = fromHandleLocked(parentHandle).promote();
+            if (parent == nullptr) {
+                return NAME_NOT_FOUND;
@@ -2033,3 +2319,18 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
+        } else {
+            parent = parentLayer;
+        }
+        if (mNumLayers >= ISurfaceComposer::MAX_LAYERS) {
+            ALOGE("AddClientLayer failed, mNumLayers (%zu) >= MAX_LAYERS (%zu)", mNumLayers.load(),
+                  ISurfaceComposer::MAX_LAYERS);
+            return NO_MEMORY;
+        }
+        mLayersByLocalBinderToken.emplace(handle->localBinder(), lbc);
+        if (parent == nullptr && addToCurrentState) {
+            mCurrentState.layersSortedByZ.add(lbc);
+        } else if (parent == nullptr) {
+            lbc->onRemovedFromCurrentState();
+        } else if (parent->isRemovedFromCurrentState()) {
+            parent->addChild(lbc);
+            lbc->onRemovedFromCurrentState();
+        } else {
+            parent->addChild(lbc);
@@ -2036,0 +2338,7 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
+        if (gbc != nullptr) {
+            mGraphicBufferProducerList.insert(IInterface::asBinder(gbc).get());
+            LOG_ALWAYS_FATAL_IF(mGraphicBufferProducerList.size() >
+                                        mMaxGraphicBufferProducerListSize,
+                                "Suspected IGBP leak: %zu IGBPs (%zu max), %zu Layers",
+                                mGraphicBufferProducerList.size(),
+                                mMaxGraphicBufferProducerListSize, mNumLayers.load());
@@ -2038,4 +2346,2 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
+        if (const auto display = getDefaultDisplayDeviceLocked()) {
+            lbc->updateTransformHint(display->getTransformHint());
@@ -2043,7 +2349,2 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
+        if (outTransformHint) {
+            *outTransformHint = lbc->getTransformHint();
@@ -2051,6 +2352 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
+        mLayersAdded = true;
@@ -2058,3 +2354,2 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
+    client->attachLayer(handle, lbc);
+    return NO_ERROR;
@@ -2061,0 +2357,5 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
+void SurfaceFlinger::removeGraphicBufferProducerAsync(const wp<IBinder>& binder) {
+    static_cast<void>(schedule([=] {
+        Mutex::Autolock lock(mStateLock);
+        mGraphicBufferProducerList.erase(binder);
+    }));
@@ -2063,4 +2363,2 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
+uint32_t SurfaceFlinger::peekTransactionFlags() {
+    return mTransactionFlags;
@@ -2068,7 +2366,2 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
+uint32_t SurfaceFlinger::getTransactionFlags(uint32_t flags) {
+    return mTransactionFlags.fetch_and(~flags) & flags;
@@ -2076,6 +2369,2 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
+uint32_t SurfaceFlinger::setTransactionFlags(uint32_t flags) {
+    return setTransactionFlags(flags, Scheduler::TransactionStart::Normal);
@@ -2083,3 +2372,6 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
+uint32_t SurfaceFlinger::setTransactionFlags(uint32_t flags,
+                                             Scheduler::TransactionStart transactionStart) {
+    uint32_t old = mTransactionFlags.fetch_or(flags);
+    mVSyncModulator->setTransactionStart(transactionStart);
+    if ((old & flags)==0) {
+        signalTransaction();
@@ -2086,0 +2379 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
+    return old;
@@ -2088,4 +2381,2 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
+void SurfaceFlinger::setTraversalNeeded() {
+    mForceTraversal = true;
@@ -2093,7 +2384,29 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
+bool SurfaceFlinger::flushTransactionQueues() {
+    std::vector<const TransactionState> transactions;
+    bool flushedATransaction = false;
+    {
+        Mutex::Autolock _l(mStateLock);
+        auto it = mTransactionQueues.begin();
+        while (it != mTransactionQueues.end()) {
+            auto& [applyToken, transactionQueue] = *it;
+            while (!transactionQueue.empty()) {
+                const auto& transaction = transactionQueue.front();
+                if (!transactionIsReadyToBeApplied(transaction.desiredPresentTime,
+                                                   transaction.states)) {
+                    setTransactionFlags(eTransactionFlushNeeded);
+                    break;
+                }
+                transactions.push_back(transaction);
+                applyTransactionState(transaction.states, transaction.displays, transaction.flags,
+                                      mPendingInputWindowCommands, transaction.desiredPresentTime,
+                                      transaction.buffer, transaction.postTime,
+                                      transaction.privileged, transaction.hasListenerCallbacks,
+                                      transaction.listenerCallbacks, true);
+                transactionQueue.pop();
+                flushedATransaction = true;
+            }
+            if (transactionQueue.empty()) {
+                it = mTransactionQueues.erase(it);
+                mTransactionCV.broadcast();
+            } else {
+                it = std::next(it, 1);
@@ -2101,10 +2413,0 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
-            }
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
@@ -2113,4 +2416 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
+    return flushedATransaction;
@@ -2118,7 +2418,2 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
+bool SurfaceFlinger::transactionFlushNeeded() {
+    return !mTransactionQueues.empty();
@@ -2126,6 +2421,6 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
+bool SurfaceFlinger::transactionIsReadyToBeApplied(int64_t desiredPresentTime,
+                                                   const Vector<ComposerState>& states) {
+    const nsecs_t expectedPresentTime = mExpectedPresentTime.load();
+    if (desiredPresentTime >= 0 && desiredPresentTime >= expectedPresentTime &&
+        desiredPresentTime < expectedPresentTime + s2ns(1)) {
+        return false;
@@ -2133,3 +2428,4 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
+    for (const ComposerState& state : states) {
+        const layer_state_t& s = state.state;
+        if (!(s.what & layer_state_t::eAcquireFenceChanged)) {
+            continue;
@@ -2136,0 +2433,2 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
+        if (s.acquireFence && s.acquireFence->getStatus() == Fence::Status::Unsignaled) {
+            return false;
@@ -2138,4 +2435,0 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
@@ -2143,7 +2437 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
+    return true;
@@ -2150,0 +2439,17 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
+void SurfaceFlinger::setTransactionState(
+        const Vector<ComposerState>& states, const Vector<DisplayState>& displays, uint32_t flags,
+        const sp<IBinder>& applyToken, const InputWindowCommands& inputWindowCommands,
+        int64_t desiredPresentTime, const client_cache_t& uncacheBuffer, bool hasListenerCallbacks,
+        const std::vector<ListenerCallbacks>& listenerCallbacks) {
+    ATRACE_CALL();
+    const int64_t postTime = systemTime();
+    bool privileged = callingThreadHasUnscopedSurfaceFlingerAccess();
+    Mutex::Autolock _l(mStateLock);
+    auto itr = mTransactionQueues.find(applyToken);
+    if (flags & eAnimation) {
+        while (itr != mTransactionQueues.end()) {
+            status_t err = mTransactionCV.waitRelative(mStateLock, s2ns(5));
+            if (CC_UNLIKELY(err != NO_ERROR)) {
+                ALOGW_IF(err == TIMED_OUT,
+                         "setTransactionState timed out "
+                         "waiting for animation frame to apply");
@@ -2152,5 +2456,0 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
@@ -2158,3 +2458 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
+            itr = mTransactionQueues.find(applyToken);
@@ -2163,3 +2461,9 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
+    const bool pendingTransactions = itr != mTransactionQueues.end();
+    if (!pendingTransactions) {
+        mExpectedPresentTime = calculateExpectedPresentTime(systemTime());
+    }
+    if (pendingTransactions || !transactionIsReadyToBeApplied(desiredPresentTime, states)) {
+        mTransactionQueues[applyToken].emplace(states, displays, flags, desiredPresentTime,
+                                               uncacheBuffer, postTime, privileged,
+                                               hasListenerCallbacks, listenerCallbacks);
+        setTransactionFlags(eTransactionFlushNeeded);
@@ -2168,7 +2472,3 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
+    applyTransactionState(states, displays, flags, inputWindowCommands, desiredPresentTime,
+                          uncacheBuffer, postTime, privileged, hasListenerCallbacks,
+                          listenerCallbacks);
@@ -2175,0 +2476,14 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
+void SurfaceFlinger::applyTransactionState(
+        const Vector<ComposerState>& states, const Vector<DisplayState>& displays, uint32_t flags,
+        const InputWindowCommands& inputWindowCommands, const int64_t desiredPresentTime,
+        const client_cache_t& uncacheBuffer, const int64_t postTime, bool privileged,
+        bool hasListenerCallbacks, const std::vector<ListenerCallbacks>& listenerCallbacks,
+        bool isMainThread) {
+    uint32_t transactionFlags = 0;
+    if (flags & eAnimation) {
+        while (!isMainThread && mAnimTransactionPending) {
+            status_t err = mTransactionCV.waitRelative(mStateLock, s2ns(5));
+            if (CC_UNLIKELY(err != NO_ERROR)) {
+                ALOGW_IF(err == TIMED_OUT, "setTransactionState timed out "
+                        "waiting for previous animation frame");
+                mAnimTransactionPending = false;
@@ -2177,5 +2490,0 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
@@ -2183,3 +2491,0 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
@@ -2188,4 +2494,2 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
+    for (const DisplayState& display : displays) {
+        transactionFlags |= setDisplayStateLocked(display);
@@ -2193,7 +2497,3 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
+    for (const auto& listener : listenerCallbacks) {
+        mTransactionCompletedThread.startRegistration(listener);
+        mTransactionCompletedThread.endRegistration(listener);
@@ -2201,6 +2501,9 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
+    std::unordered_set<ListenerCallbacks, ListenerCallbacksHash> listenerCallbacksWithSurfaces;
+    uint32_t clientStateFlags = 0;
+    for (const ComposerState& state : states) {
+        clientStateFlags |= setClientStateLocked(state, desiredPresentTime, postTime, privileged,
+                                                 listenerCallbacksWithSurfaces);
+        if ((flags & eAnimation) && state.state.surface) {
+            if (const auto layer = fromHandleLocked(state.state.surface).promote(); layer) {
+                mScheduler->recordLayerHistory(layer.get(), desiredPresentTime,
+                                               LayerHistory::LayerUpdateType::AnimationTX);
@@ -2208,3 +2510,0 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
@@ -2213,4 +2513,2 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
+    for (const auto& listenerCallback : listenerCallbacksWithSurfaces) {
+        mTransactionCompletedThread.endRegistration(listenerCallback);
@@ -2218,7 +2516,2 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
+    if (!(clientStateFlags & eTraversalNeeded) && hasListenerCallbacks) {
+        mTransactionCompletedThread.sendCallbacks();
@@ -2226,6 +2519,5 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
+    transactionFlags |= clientStateFlags;
+    transactionFlags |= addInputWindowCommands(inputWindowCommands);
+    if (uncacheBuffer.isValid()) {
+        ClientCache::getInstance().erase(uncacheBuffer);
+        getRenderEngine().unbindExternalTextureBuffer(uncacheBuffer.id);
@@ -2233,3 +2525,3 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
+    if (transactionFlags == 0 &&
+            ((flags & eSynchronous) || (flags & eAnimation))) {
+        transactionFlags = eTransactionNeeded;
@@ -2236,0 +2529,3 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
+    if (isMainThread && (transactionFlags & eTraversalNeeded)) {
+        transactionFlags = transactionFlags & (~eTraversalNeeded);
+        mForceTraversal = true;
@@ -2238,4 +2533,3 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
+    const auto transactionStart = [](uint32_t flags) {
+        if (flags & eEarlyWakeup) {
+            return Scheduler::TransactionStart::Early;
@@ -2243,7 +2537,2 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
+        if (flags & eExplicitEarlyWakeupEnd) {
+            return Scheduler::TransactionStart::EarlyEnd;
@@ -2251,6 +2540,2 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
+        if (flags & eExplicitEarlyWakeupStart) {
+            return Scheduler::TransactionStart::EarlyStart;
@@ -2258,3 +2543,5 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
+        return Scheduler::TransactionStart::Normal;
+    }(flags);
+    if (transactionFlags) {
+        if (mInterceptor->isEnabled()) {
+            mInterceptor->saveTransaction(states, mCurrentState.displays, displays, flags);
@@ -2261,0 +2549,2 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
+        if (flags & eEarlyWakeup) {
+            ALOGW("eEarlyWakeup is deprecated. Use eExplicitEarlyWakeup[Start|End]");
@@ -2263,3 +2552,11 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
+        if (!privileged && (flags & (eExplicitEarlyWakeupStart | eExplicitEarlyWakeupEnd))) {
+            ALOGE("Only WindowManager is allowed to use eExplicitEarlyWakeup[Start|End] flags");
+            flags &= ~(eExplicitEarlyWakeupStart | eExplicitEarlyWakeupEnd);
+        }
+        setTransactionFlags(transactionFlags, transactionStart);
+        if (flags & eAnimation) {
+            mAnimTransactionPending = true;
+        }
+        const bool synchronous = flags & eSynchronous;
+        const bool syncInput = inputWindowCommands.syncInputWindows;
+        if (!synchronous && !syncInput) {
@@ -2268,7 +2565,2 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
+        if (synchronous) {
+            mTransactionPending = true;
@@ -2276,6 +2568,2 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
+        if (syncInput) {
+            mPendingSyncInputWindows = true;
@@ -2283,2 +2571,6 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::NoChange:
+        while (!isMainThread && (mTransactionPending || mPendingSyncInputWindows)) {
+            status_t err = mTransactionCV.waitRelative(mStateLock, s2ns(5));
+            if (CC_UNLIKELY(err != NO_ERROR)) {
+                ALOGW_IF(err == TIMED_OUT, "setTransactionState timed out!");
+                mTransactionPending = false;
+                mPendingSyncInputWindows = false;
@@ -2288,4 +2580,4 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
+    } else {
+        if (transactionStart == Scheduler::TransactionStart::EarlyStart ||
+            transactionStart == Scheduler::TransactionStart::EarlyEnd) {
+            mVSyncModulator->setTransactionStart(transactionStart);
@@ -2293,7 +2584,0 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
@@ -2301,6 +2585,0 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
@@ -2308,3 +2587,10 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
+uint32_t SurfaceFlinger::setDisplayStateLocked(const DisplayState& s) {
+    const ssize_t index = mCurrentState.displays.indexOfKey(s.token);
+    if (index < 0) return 0;
+    uint32_t flags = 0;
+    DisplayDeviceState& state = mCurrentState.displays.editValueAt(index);
+    const uint32_t what = s.what;
+    if (what & DisplayState::eSurfaceChanged) {
+        if (IInterface::asBinder(state.surface) != IInterface::asBinder(s.surface)) {
+            state.surface = s.surface;
+            flags |= eDisplayTransactionNeeded;
@@ -2313,4 +2599,4 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
+    if (what & DisplayState::eLayerStackChanged) {
+        if (state.layerStack != s.layerStack) {
+            state.layerStack = s.layerStack;
+            flags |= eDisplayTransactionNeeded;
@@ -2318,7 +2603,0 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
@@ -2326,6 +2605,4 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
+    if (what & DisplayState::eDisplayProjectionChanged) {
+        if (state.orientation != s.orientation) {
+            state.orientation = s.orientation;
+            flags |= eDisplayTransactionNeeded;
@@ -2333,3 +2610,3 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
+        if (state.frame != s.frame) {
+            state.frame = s.frame;
+            flags |= eDisplayTransactionNeeded;
@@ -2336,0 +2614,3 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
+        if (state.viewport != s.viewport) {
+            state.viewport = s.viewport;
+            flags |= eDisplayTransactionNeeded;
@@ -2338,4 +2617,0 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
@@ -2343,7 +2619,4 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
+    if (what & DisplayState::eDisplaySizeChanged) {
+        if (state.width != s.width) {
+            state.width = s.width;
+            flags |= eDisplayTransactionNeeded;
@@ -2351,6 +2624,3 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
+        if (state.height != s.height) {
+            state.height = s.height;
+            flags |= eDisplayTransactionNeeded;
@@ -2358,3 +2627,0 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
@@ -2361,0 +2629 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
+    return flags;
@@ -2363,4 +2631,8 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
+bool SurfaceFlinger::callingThreadHasUnscopedSurfaceFlingerAccess(bool usePermissionCache) {
+    IPCThreadState* ipc = IPCThreadState::self();
+    const int pid = ipc->getCallingPid();
+    const int uid = ipc->getCallingUid();
+    if ((uid != AID_GRAPHICS && uid != AID_SYSTEM) &&
+        (usePermissionCache ? !PermissionCache::checkPermission(sAccessSurfaceFlinger, pid, uid)
+                            : !checkPermission(sAccessSurfaceFlinger, pid, uid))) {
+        return false;
@@ -2368,7 +2640 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
+    return true;
@@ -2376,6 +2642,14 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
+uint32_t SurfaceFlinger::setClientStateLocked(
+        const ComposerState& composerState, int64_t desiredPresentTime, int64_t postTime,
+        bool privileged,
+        std::unordered_set<ListenerCallbacks, ListenerCallbacksHash>& listenerCallbacks) {
+    const layer_state_t& s = composerState.state;
+    for (auto& listener : s.listeners) {
+        mTransactionCompletedThread.startRegistration(listener);
+        listenerCallbacks.insert(listener);
+    }
+    sp<Layer> layer = nullptr;
+    if (s.surface) {
+        layer = fromHandleLocked(s.surface).promote();
+    } else {
+        ALOGW("Attempt to set client state with a null layer handle");
@@ -2383,3 +2657,4 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
+    if (layer == nullptr) {
+        for (auto& [listener, callbackIds] : s.listeners) {
+            mTransactionCompletedThread.registerUnpresentedCallbackHandle(
+                    new CallbackHandle(listener, callbackIds, s.surface));
@@ -2386,0 +2662 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
+        return 0;
@@ -2388,4 +2664,4 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
+    uint32_t flags = 0;
+    const uint64_t what = s.what;
+    if (what & layer_state_t::eDeferTransaction_legacy) {
+        layer->pushPendingState();
@@ -2393,7 +2669,2 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
+    if (what & layer_state_t::eProducerDisconnect) {
+        layer->onDisconnect();
@@ -2401,6 +2672,3 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
+    if (what & layer_state_t::ePositionChanged) {
+        if (layer->setPosition(s.x, s.y)) {
+            flags |= eTraversalNeeded;
@@ -2408,3 +2675,0 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
@@ -2411,0 +2677,8 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
+    if (what & layer_state_t::eLayerChanged) {
+        const auto& p = layer->getParent();
+        if (p == nullptr) {
+            ssize_t idx = mCurrentState.layersSortedByZ.indexOf(layer);
+            if (layer->setLayer(s.z) && idx >= 0) {
+                mCurrentState.layersSortedByZ.removeAt(idx);
+                mCurrentState.layersSortedByZ.add(layer);
+                flags |= eTransactionNeeded|eTraversalNeeded;
@@ -2413,4 +2686,3 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
+        } else {
+            if (p->setChildLayer(layer, s.z)) {
+                flags |= eTransactionNeeded|eTraversalNeeded;
@@ -2418,7 +2689,0 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
@@ -2426,6 +2690,0 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
@@ -2433,3 +2692,8 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
+    if (what & layer_state_t::eRelativeLayerChanged) {
+        const auto& p = layer->getParent();
+        if (p == nullptr) {
+            ssize_t idx = mCurrentState.layersSortedByZ.indexOf(layer);
+            if (layer->setRelativeLayer(s.relativeLayerHandle, s.z) && idx >= 0) {
+                mCurrentState.layersSortedByZ.removeAt(idx);
+                mCurrentState.layersSortedByZ.add(layer);
+                flags |= eTransactionNeeded|eTraversalNeeded;
@@ -2436,0 +2701,3 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
+        } else {
+            if (p->setChildRelativeLayer(layer, s.relativeLayerHandle, s.z)) {
+                flags |= eTransactionNeeded|eTraversalNeeded;
@@ -2438,4 +2704,0 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
@@ -2443,7 +2705,0 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
@@ -2451,6 +2707,3 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
+    if (what & layer_state_t::eSizeChanged) {
+        if (layer->setSize(s.w, s.h)) {
+            flags |= eTraversalNeeded;
@@ -2458,3 +2710,0 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
@@ -2461,0 +2712,3 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
+    if (what & layer_state_t::eAlphaChanged) {
+        if (layer->setAlpha(s.alpha))
+            flags |= eTraversalNeeded;
@@ -2463,4 +2716,3 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
+    if (what & layer_state_t::eColorChanged) {
+        if (layer->setColor(s.color))
+            flags |= eTraversalNeeded;
@@ -2468,7 +2720,3 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
+    if (what & layer_state_t::eColorTransformChanged) {
+        if (layer->setColorTransform(s.colorTransform)) {
+            flags |= eTraversalNeeded;
@@ -2476,6 +2723,0 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
@@ -2483,3 +2725,3 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
+    if (what & layer_state_t::eBackgroundColorChanged) {
+        if (layer->setBackgroundColor(s.color, s.bgColorAlpha, s.bgColorDataspace)) {
+            flags |= eTraversalNeeded;
@@ -2488,4 +2730,3 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
+    if (what & layer_state_t::eMatrixChanged) {
+        if (layer->setMatrix(s.matrix, privileged))
+            flags |= eTraversalNeeded;
@@ -2493,7 +2734,3 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
+    if (what & layer_state_t::eTransparentRegionChanged) {
+        if (layer->setTransparentRegionHint(s.transparentRegion))
+            flags |= eTraversalNeeded;
@@ -2501,6 +2738,3 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
+    if (what & layer_state_t::eFlagsChanged) {
+        if (layer->setFlags(s.flags, s.mask))
+            flags |= eTraversalNeeded;
@@ -2508,3 +2742,2 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
+    if (what & layer_state_t::eCropChanged_legacy) {
+        if (layer->setCrop_legacy(s.crop_legacy)) flags |= eTraversalNeeded;
@@ -2511,0 +2745,3 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
+    if (what & layer_state_t::eCornerRadiusChanged) {
+        if (layer->setCornerRadius(s.cornerRadius))
+            flags |= eTraversalNeeded;
@@ -2513,4 +2749,2 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
+    if (what & layer_state_t::eBackgroundBlurRadiusChanged && !mDisableBlurs && mSupportsBlur) {
+        if (layer->setBackgroundBlurRadius(s.backgroundBlurRadius)) flags |= eTraversalNeeded;
@@ -2518,7 +2752,14 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
+    if (what & layer_state_t::eLayerStackChanged) {
+        ssize_t idx = mCurrentState.layersSortedByZ.indexOf(layer);
+        if (layer->hasParent()) {
+            ALOGE("Attempt to set layer stack on layer with parent (%s) is invalid",
+                  layer->getDebugName());
+        } else if (idx < 0) {
+            ALOGE("Attempt to set layer stack on layer without parent (%s) that "
+                  "that also does not appear in the top level layer list. Something"
+                  " has gone wrong.",
+                  layer->getDebugName());
+        } else if (layer->setLayerStack(s.layerStack)) {
+            mCurrentState.layersSortedByZ.removeAt(idx);
+            mCurrentState.layersSortedByZ.add(layer);
+            flags |= eTransactionNeeded | eTraversalNeeded | eTransformHintUpdateNeeded;
@@ -2526,6 +2766,0 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
@@ -2533,3 +2768,12 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
+    if (what & layer_state_t::eDeferTransaction_legacy) {
+        if (s.barrierHandle_legacy != nullptr) {
+            layer->deferTransactionUntil_legacy(s.barrierHandle_legacy, s.frameNumber_legacy);
+        } else if (s.barrierGbp_legacy != nullptr) {
+            const sp<IGraphicBufferProducer>& gbp = s.barrierGbp_legacy;
+            if (authenticateSurfaceTextureLocked(gbp)) {
+                const auto& otherLayer =
+                    (static_cast<MonitoredProducer*>(gbp.get()))->getLayer();
+                layer->deferTransactionUntil_legacy(otherLayer, s.frameNumber_legacy);
+            } else {
+                ALOGE("Attempt to defer transaction to to an"
+                        " unrecognized GraphicBufferProducer");
@@ -2538,4 +2781,0 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
@@ -2543,7 +2783,3 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
+    if (what & layer_state_t::eReparentChildren) {
+        if (layer->reparentChildren(s.reparentHandle)) {
+            flags |= eTransactionNeeded|eTraversalNeeded;
@@ -2551,6 +2786,0 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
@@ -2558,3 +2788,2 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
+    if (what & layer_state_t::eDetachChildren) {
+        layer->detachChildren();
@@ -2561,0 +2791,2 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
+    if (what & layer_state_t::eOverrideScalingModeChanged) {
+        layer->setOverrideScalingMode(s.overrideScalingMode);
@@ -2563,4 +2794,2 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
+    if (what & layer_state_t::eTransformChanged) {
+        if (layer->setTransform(s.transform)) flags |= eTraversalNeeded;
@@ -2568,7 +2797,3 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
+    if (what & layer_state_t::eTransformToDisplayInverseChanged) {
+        if (layer->setTransformToDisplayInverse(s.transformToDisplayInverse))
+            flags |= eTraversalNeeded;
@@ -2576,6 +2801,2 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
+    if (what & layer_state_t::eCropChanged) {
+        if (layer->setCrop(s.crop)) flags |= eTraversalNeeded;
@@ -2583,3 +2804,2 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
+    if (what & layer_state_t::eFrameChanged) {
+        if (layer->setFrame(s.frame)) flags |= eTraversalNeeded;
@@ -2586,0 +2807,2 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
+    if (what & layer_state_t::eAcquireFenceChanged) {
+        if (layer->setAcquireFence(s.acquireFence)) flags |= eTraversalNeeded;
@@ -2588,4 +2810,2 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
+    if (what & layer_state_t::eDataspaceChanged) {
+        if (layer->setDataspace(s.dataspace)) flags |= eTraversalNeeded;
@@ -2593,7 +2813,2 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
+    if (what & layer_state_t::eHdrMetadataChanged) {
+        if (layer->setHdrMetadata(s.hdrMetadata)) flags |= eTraversalNeeded;
@@ -2601,6 +2816,2 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
+    if (what & layer_state_t::eSurfaceDamageRegionChanged) {
+        if (layer->setSurfaceDamageRegion(s.surfaceDamageRegion)) flags |= eTraversalNeeded;
@@ -2608,3 +2819,2 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
+    if (what & layer_state_t::eApiChanged) {
+        if (layer->setApi(s.api)) flags |= eTraversalNeeded;
@@ -2611,0 +2822,2 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
+    if (what & layer_state_t::eSidebandStreamChanged) {
+        if (layer->setSidebandStream(s.sidebandStream)) flags |= eTraversalNeeded;
@@ -2613,4 +2825,6 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
+    if (what & layer_state_t::eInputInfoChanged) {
+        if (privileged) {
+            layer->setInputInfo(s.inputInfo);
+            flags |= eTraversalNeeded;
+        } else {
+            ALOGE("Attempt to update InputWindowInfo without permission ACCESS_SURFACE_FLINGER");
@@ -2618,7 +2831,0 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
@@ -2626,6 +2833,2 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
+    if (what & layer_state_t::eMetadataChanged) {
+        if (layer->setMetadata(s.metadata)) flags |= eTraversalNeeded;
@@ -2633,3 +2836,3 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
+    if (what & layer_state_t::eColorSpaceAgnosticChanged) {
+        if (layer->setColorSpaceAgnostic(s.colorSpaceAgnostic)) {
+            flags |= eTraversalNeeded;
@@ -2638,4 +2841,2 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
+    if (what & layer_state_t::eShadowRadiusChanged) {
+        if (layer->setShadowRadius(s.shadowRadius)) flags |= eTraversalNeeded;
@@ -2643,7 +2844,3 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
+    if (what & layer_state_t::eFrameRateSelectionPriority) {
+        if (privileged && layer->setFrameRateSelectionPriority(s.frameRateSelectionPriority)) {
+            flags |= eTraversalNeeded;
@@ -2651,6 +2847,0 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
@@ -2658,3 +2849,7 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
+    if (what & layer_state_t::eFrameRateChanged) {
+        if (ValidateFrameRate(s.frameRate, s.frameRateCompatibility,
+                              "SurfaceFlinger::setClientStateLocked") &&
+            layer->setFrameRate(Layer::FrameRate(s.frameRate,
+                                                 Layer::FrameRate::convertCompatibility(
+                                                         s.frameRateCompatibility)))) {
+            flags |= eTraversalNeeded;
@@ -2663,4 +2858,3 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
+    if (what & layer_state_t::eFixedTransformHintChanged) {
+        if (layer->setFixedTransformHint(s.fixedTransformHint)) {
+            flags |= eTraversalNeeded | eTransformHintUpdateNeeded;
@@ -2668,7 +2861,0 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
@@ -2676,6 +2863,5 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
+    if (what & layer_state_t::eReparent) {
+        bool hadParent = layer->hasParent();
+        if (layer->reparent(s.parentHandleForChild)) {
+            if (!hadParent) {
+                mCurrentState.layersSortedByZ.remove(layer);
@@ -2683,3 +2869 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
+            flags |= eTransactionNeeded | eTraversalNeeded;
@@ -2688,4 +2872,4 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
+    std::vector<sp<CallbackHandle>> callbackHandles;
+    if ((what & layer_state_t::eHasListenerCallbacksChanged) && (!s.listeners.empty())) {
+        for (auto& [listener, callbackIds] : s.listeners) {
+            callbackHandles.emplace_back(new CallbackHandle(listener, callbackIds, s.surface));
@@ -2693,7 +2876,0 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
@@ -2701,6 +2878,13 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
+    bool bufferChanged = what & layer_state_t::eBufferChanged;
+    bool cacheIdChanged = what & layer_state_t::eCachedBufferChanged;
+    sp<GraphicBuffer> buffer;
+    if (bufferChanged && cacheIdChanged && s.buffer != nullptr) {
+        buffer = s.buffer;
+        bool success = ClientCache::getInstance().add(s.cachedBuffer, s.buffer);
+        if (success) {
+            getRenderEngine().cacheExternalTextureBuffer(s.buffer);
+            success = ClientCache::getInstance()
+                              .registerErasedRecipient(s.cachedBuffer,
+                                                       wp<ClientCache::ErasedRecipient>(this));
+            if (!success) {
+                getRenderEngine().unbindExternalTextureBuffer(s.buffer->getId());
@@ -2708,3 +2891,0 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
@@ -2711,0 +2893,4 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
+    } else if (cacheIdChanged) {
+        buffer = ClientCache::getInstance().get(s.cachedBuffer);
+    } else if (bufferChanged) {
+        buffer = s.buffer;
@@ -2713,4 +2898,4 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
+    if (buffer) {
+        if (layer->setBuffer(buffer, s.acquireFence, postTime, desiredPresentTime,
+                             s.cachedBuffer)) {
+            flags |= eTraversalNeeded;
@@ -2718,7 +2902,0 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
@@ -2726,6 +2904,2 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
+    if (layer->setTransactionCompletedListeners(callbackHandles)) flags |= eTraversalNeeded;
+    return flags;
@@ -2733,3 +2907,4 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
+uint32_t SurfaceFlinger::addInputWindowCommands(const InputWindowCommands& inputWindowCommands) {
+    uint32_t flags = 0;
+    if (inputWindowCommands.syncInputWindows) {
+        flags |= eTraversalNeeded;
@@ -2736,0 +2912,2 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
+    mPendingInputWindowCommands.merge(inputWindowCommands);
+    return flags;
@@ -2738,4 +2915,4 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
+status_t SurfaceFlinger::mirrorLayer(const sp<Client>& client, const sp<IBinder>& mirrorFromHandle,
+                                     sp<IBinder>* outHandle) {
+    if (!mirrorFromHandle) {
+        return NAME_NOT_FOUND;
@@ -2743,7 +2920,8 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
+    sp<Layer> mirrorLayer;
+    sp<Layer> mirrorFrom;
+    std::string uniqueName = getUniqueLayerName("MirrorRoot");
+    {
+        Mutex::Autolock _l(mStateLock);
+        mirrorFrom = fromHandleLocked(mirrorFromHandle).promote();
+        if (!mirrorFrom) {
+            return NAME_NOT_FOUND;
@@ -2751,6 +2929,4 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
+        status_t result = createContainerLayer(client, std::move(uniqueName), -1, -1, 0,
+                                               LayerMetadata(), outHandle, &mirrorLayer);
+        if (result != NO_ERROR) {
+            return result;
@@ -2758,3 +2934 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
+        mirrorLayer->mClonedChild = mirrorFrom->createClone();
@@ -2761,0 +2936,2 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
+    return addClientLayer(client, *outHandle, nullptr, mirrorLayer, nullptr, nullptr, false,
+                          nullptr );
@@ -2763,4 +2939,10 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
+status_t SurfaceFlinger::createLayer(const String8& name, const sp<Client>& client, uint32_t w,
+                                     uint32_t h, PixelFormat format, uint32_t flags,
+                                     LayerMetadata metadata, sp<IBinder>* handle,
+                                     sp<IGraphicBufferProducer>* gbp,
+                                     const sp<IBinder>& parentHandle, const sp<Layer>& parentLayer,
+                                     uint32_t* outTransformHint) {
+    if (int32_t(w|h) < 0) {
+        ALOGE("createLayer() failed, w or h is negative (w=%d, h=%d)",
+                int(w), int(h));
+        return BAD_VALUE;
@@ -2768,7 +2950,28 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
+    ALOG_ASSERT(parentLayer == nullptr || parentHandle == nullptr,
+            "Expected only one of parentLayer or parentHandle to be non-null. "
+            "Programmer error?");
+    status_t result = NO_ERROR;
+    sp<Layer> layer;
+    std::string uniqueName = getUniqueLayerName(name.string());
+    bool primaryDisplayOnly = false;
+    if (metadata.has(METADATA_WINDOW_TYPE)) {
+        int32_t windowType = metadata.getInt32(METADATA_WINDOW_TYPE, 0);
+        if (windowType == 441731) {
+            metadata.setInt32(METADATA_WINDOW_TYPE, InputWindowInfo::TYPE_NAVIGATION_BAR_PANEL);
+            primaryDisplayOnly = true;
+        }
+    }
+    switch (flags & ISurfaceComposerClient::eFXSurfaceMask) {
+        case ISurfaceComposerClient::eFXSurfaceBufferQueue:
+            result = createBufferQueueLayer(client, std::move(uniqueName), w, h, flags,
+                                            std::move(metadata), format, handle, gbp, &layer);
+            break;
+        case ISurfaceComposerClient::eFXSurfaceBufferState:
+            result = createBufferStateLayer(client, std::move(uniqueName), w, h, flags,
+                                            std::move(metadata), handle, &layer);
+            break;
+        case ISurfaceComposerClient::eFXSurfaceEffect:
+            if (w > 0 || h > 0) {
+                ALOGE("createLayer() failed, w or h cannot be set for color layer (w=%d, h=%d)",
+                      int(w), int(h));
+                return BAD_VALUE;
@@ -2775,0 +2979,2 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
+            result = createEffectLayer(client, std::move(uniqueName), w, h, flags,
+                                       std::move(metadata), handle, &layer);
@@ -2777,5 +2982,5 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
+        case ISurfaceComposerClient::eFXSurfaceContainer:
+            if (w > 0 || h > 0) {
+                ALOGE("createLayer() failed, w or h cannot be set for container layer (w=%d, h=%d)",
+                      int(w), int(h));
+                return BAD_VALUE;
@@ -2782,0 +2988,2 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
+            result = createContainerLayer(client, std::move(uniqueName), w, h, flags,
+                                          std::move(metadata), handle, &layer);
@@ -2784 +2991,2 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-        case KernelIdleTimerAction::NoChange:
+        default:
+            result = BAD_VALUE;
@@ -2786,0 +2995,2 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
+    if (result != NO_ERROR) {
+        return result;
@@ -2788,4 +2998,2 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
+    if (primaryDisplayOnly) {
+        layer->setPrimaryDisplayOnly();
@@ -2793,7 +3001,5 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
+    bool addToCurrentState = callingThreadHasUnscopedSurfaceFlingerAccess();
+    result = addClientLayer(client, *handle, *gbp, layer, parentHandle, parentLayer,
+                            addToCurrentState, outTransformHint);
+    if (result != NO_ERROR) {
+        return result;
@@ -2801,6 +3007,20 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
+    mInterceptor->saveSurfaceCreation(layer);
+    setTransactionFlags(eTransactionNeeded);
+    return result;
+}
+std::string SurfaceFlinger::getUniqueLayerName(const char* name) {
+    unsigned dupeCounter = 0;
+    std::string uniqueName = base::StringPrintf("%s#%u", name, dupeCounter);
+    Mutex::Autolock lock(mStateLock);
+    bool matchFound = true;
+    while (matchFound) {
+        matchFound = false;
+        mCurrentState.traverse([&](Layer* layer) {
+            if (layer->getName() == uniqueName) {
+                matchFound = true;
+                uniqueName = base::StringPrintf("%s#%u", name, ++dupeCounter);
+            }
+        });
+    }
+    ALOGV_IF(dupeCounter > 0, "duplicate layer name: changing %s to %s", name, uniqueName.c_str());
+    return uniqueName;
@@ -2807,0 +3028,10 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
+status_t SurfaceFlinger::createBufferQueueLayer(const sp<Client>& client, std::string name,
+                                                uint32_t w, uint32_t h, uint32_t flags,
+                                                LayerMetadata metadata, PixelFormat& format,
+                                                sp<IBinder>* handle,
+                                                sp<IGraphicBufferProducer>* gbp,
+                                                sp<Layer>* outLayer) {
+    switch (format) {
+    case PIXEL_FORMAT_TRANSPARENT:
+    case PIXEL_FORMAT_TRANSLUCENT:
+        format = PIXEL_FORMAT_RGBA_8888;
@@ -2809 +3039,2 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-        case KernelIdleTimerAction::NoChange:
+    case PIXEL_FORMAT_OPAQUE:
+        format = PIXEL_FORMAT_RGBX_8888;
@@ -2811,0 +3043,26 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
+    sp<BufferQueueLayer> layer;
+    LayerCreationArgs args(this, client, std::move(name), w, h, flags, std::move(metadata));
+    args.textureName = getNewTexture();
+    {
+        Mutex::Autolock lock(mStateLock);
+        layer = getFactory().createBufferQueueLayer(args);
+    }
+    status_t err = layer->setDefaultBufferProperties(w, h, format);
+    if (err == NO_ERROR) {
+        *handle = layer->getHandle();
+        *gbp = layer->getProducer();
+        *outLayer = layer;
+    }
+    ALOGE_IF(err, "createBufferQueueLayer() failed (%s)", strerror(-err));
+    return err;
+}
+status_t SurfaceFlinger::createBufferStateLayer(const sp<Client>& client, std::string name,
+                                                uint32_t w, uint32_t h, uint32_t flags,
+                                                LayerMetadata metadata, sp<IBinder>* handle,
+                                                sp<Layer>* outLayer) {
+    LayerCreationArgs args(this, client, std::move(name), w, h, flags, std::move(metadata));
+    args.textureName = getNewTexture();
+    sp<BufferStateLayer> layer = getFactory().createBufferStateLayer(args);
+    *handle = layer->getHandle();
+    *outLayer = layer;
+    return NO_ERROR;
@@ -2813,4 +3070,7 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
+status_t SurfaceFlinger::createEffectLayer(const sp<Client>& client, std::string name, uint32_t w,
+                                           uint32_t h, uint32_t flags, LayerMetadata metadata,
+                                           sp<IBinder>* handle, sp<Layer>* outLayer) {
+    *outLayer = getFactory().createEffectLayer(
+            {this, client, std::move(name), w, h, flags, std::move(metadata)});
+    *handle = (*outLayer)->getHandle();
+    return NO_ERROR;
@@ -2818,7 +3078,8 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
+status_t SurfaceFlinger::createContainerLayer(const sp<Client>& client, std::string name,
+                                              uint32_t w, uint32_t h, uint32_t flags,
+                                              LayerMetadata metadata, sp<IBinder>* handle,
+                                              sp<Layer>* outLayer) {
+    *outLayer = getFactory().createContainerLayer(
+            {this, client, std::move(name), w, h, flags, std::move(metadata)});
+    *handle = (*outLayer)->getHandle();
+    return NO_ERROR;
@@ -2826,6 +3087,4 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
+void SurfaceFlinger::markLayerPendingRemovalLocked(const sp<Layer>& layer) {
+    mLayersPendingRemoval.add(layer);
+    mLayersRemoved = true;
+    setTransactionFlags(eTransactionNeeded);
@@ -2833,3 +3092,13 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
+void SurfaceFlinger::onHandleDestroyed(sp<Layer>& layer)
+{
+    Mutex::Autolock lock(mStateLock);
+    if (layer->getParent() == nullptr) {
+        mCurrentState.layersSortedByZ.remove(layer);
+    }
+    markLayerPendingRemovalLocked(layer);
+    auto it = mLayersByLocalBinderToken.begin();
+    while (it != mLayersByLocalBinderToken.end()) {
+        if (it->second == layer) {
+            it = mLayersByLocalBinderToken.erase(it);
+        } else {
+            it++;
@@ -2838,3 +3107,34 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
+    layer.clear();
+}
+void SurfaceFlinger::onInitializeDisplays() {
+    const auto display = getDefaultDisplayDeviceLocked();
+    if (!display) return;
+    const sp<IBinder> token = display->getDisplayToken().promote();
+    LOG_ALWAYS_FATAL_IF(token == nullptr);
+    Vector<ComposerState> state;
+    Vector<DisplayState> displays;
+    DisplayState d;
+    d.what = DisplayState::eDisplayProjectionChanged |
+             DisplayState::eLayerStackChanged;
+    d.token = token;
+    d.layerStack = 0;
+    d.orientation = ui::ROTATION_0;
+    d.frame.makeInvalid();
+    d.viewport.makeInvalid();
+    d.width = 0;
+    d.height = 0;
+    displays.add(d);
+    setTransactionState(state, displays, 0, nullptr, mPendingInputWindowCommands, -1, {}, false,
+                        {});
+    setPowerModeInternal(display, hal::PowerMode::ON);
+    const nsecs_t vsyncPeriod = getVsyncPeriod();
+    mAnimFrameTracker.setDisplayRefreshPeriod(vsyncPeriod);
+    DisplayStatInfo stats{0 , vsyncPeriod};
+    setCompositorTimingSnapped(stats, 0);
+}
+void SurfaceFlinger::initializeDisplays() {
+    static_cast<void>(schedule([this]() MAIN_THREAD { onInitializeDisplays(); }));
+}
+void SurfaceFlinger::setPowerModeInternal(const sp<DisplayDevice>& display, hal::PowerMode mode) {
+    if (display->isVirtual()) {
+        ALOGE("%s: Invalid operation on virtual display", __FUNCTION__);
@@ -2843,7 +3143,45 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
+    const auto displayId = display->getId();
+    LOG_ALWAYS_FATAL_IF(!displayId);
+    ALOGD("Setting power mode %d on display %s", mode, to_string(*displayId).c_str());
+    const hal::PowerMode currentMode = display->getPowerMode();
+    if (mode == currentMode) {
+        return;
+    }
+    display->setPowerMode(mode);
+    if (mInterceptor->isEnabled()) {
+        mInterceptor->savePowerModeUpdate(display->getSequenceId(), static_cast<int32_t>(mode));
+    }
+    if (currentMode == hal::PowerMode::OFF) {
+        if (SurfaceFlinger::setSchedFifo(true) != NO_ERROR) {
+            ALOGW("Couldn't set SCHED_FIFO on display on: %s\n", strerror(errno));
+        }
+        getHwComposer().setPowerMode(*displayId, mode);
+        if (display->isPrimary() && mode != hal::PowerMode::DOZE_SUSPEND) {
+            getHwComposer().setVsyncEnabled(*displayId, mHWCVsyncPendingState);
+            mScheduler->onScreenAcquired(mAppConnectionHandle);
+            mScheduler->resyncToHardwareVsync(true, getVsyncPeriod());
+        }
+        mVisibleRegionsDirty = true;
+        mHasPoweredOff = true;
+        repaintEverything();
+    } else if (mode == hal::PowerMode::OFF) {
+        if (SurfaceFlinger::setSchedFifo(false) != NO_ERROR) {
+            ALOGW("Couldn't set SCHED_OTHER on display off: %s\n", strerror(errno));
+        }
+        if (display->isPrimary() && currentMode != hal::PowerMode::DOZE_SUSPEND) {
+            mScheduler->disableHardwareVsync(true);
+            mScheduler->onScreenReleased(mAppConnectionHandle);
+        }
+        getHwComposer().setVsyncEnabled(*displayId, hal::Vsync::DISABLE);
+        getHwComposer().setPowerMode(*displayId, mode);
+        mVisibleRegionsDirty = true;
+    } else if (mode == hal::PowerMode::DOZE || mode == hal::PowerMode::ON) {
+        getHwComposer().setPowerMode(*displayId, mode);
+        if (display->isPrimary() && currentMode == hal::PowerMode::DOZE_SUSPEND) {
+            mScheduler->onScreenAcquired(mAppConnectionHandle);
+            mScheduler->resyncToHardwareVsync(true, getVsyncPeriod());
+        }
+    } else if (mode == hal::PowerMode::DOZE_SUSPEND) {
+        if (display->isPrimary()) {
+            mScheduler->disableHardwareVsync(true);
+            mScheduler->onScreenReleased(mAppConnectionHandle);
@@ -2851,6 +3189,4 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
+        getHwComposer().setPowerMode(*displayId, mode);
+    } else {
+        ALOGE("Attempting to set unknown power mode: %d\n", mode);
+        getHwComposer().setPowerMode(*displayId, mode);
@@ -2858,3 +3194,4 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
+    if (display->isPrimary()) {
+        mTimeStats->setPowerMode(mode);
+        mRefreshRateStats->setPowerMode(mode);
+        mScheduler->setDisplayPowerState(mode == hal::PowerMode::ON);
@@ -2861,0 +3199 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
+    ALOGD("Finished setting power mode %d on display %s", mode, to_string(*displayId).c_str());
@@ -2863,4 +3201,10 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
+void SurfaceFlinger::setPowerMode(const sp<IBinder>& displayToken, int mode) {
+    schedule([=]() MAIN_THREAD {
+        const auto display = getDisplayDeviceLocked(displayToken);
+        if (!display) {
+            ALOGE("Attempt to set power mode %d for invalid display token %p", mode,
+                  displayToken.get());
+        } else if (display->isVirtual()) {
+            ALOGW("Attempt to set power mode %d for virtual display", mode);
+        } else {
+            setPowerModeInternal(display, static_cast<hal::PowerMode>(mode));
@@ -2868,7 +3212 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
+    }).wait();
@@ -2876,6 +3214,48 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
+status_t SurfaceFlinger::doDump(int fd, const DumpArgs& args, bool asProto) {
+    std::string result;
+    IPCThreadState* ipc = IPCThreadState::self();
+    const int pid = ipc->getCallingPid();
+    const int uid = ipc->getCallingUid();
+    if ((uid != AID_SHELL) &&
+            !PermissionCache::checkPermission(sDump, pid, uid)) {
+        StringAppendF(&result, "Permission Denial: can't dump SurfaceFlinger from pid=%d, uid=%d\n",
+                      pid, uid);
+    } else {
+        static const std::unordered_map<std::string, Dumper> dumpers = {
+                {"--display-id"s, dumper(&SurfaceFlinger::dumpDisplayIdentificationData)},
+                {"--dispsync"s,
+                 dumper([this](std::string& s) { mScheduler->getPrimaryDispSync().dump(s); })},
+                {"--edid"s, argsDumper(&SurfaceFlinger::dumpRawDisplayIdentificationData)},
+                {"--frame-events"s, dumper(&SurfaceFlinger::dumpFrameEventsLocked)},
+                {"--latency"s, argsDumper(&SurfaceFlinger::dumpStatsLocked)},
+                {"--latency-clear"s, argsDumper(&SurfaceFlinger::clearStatsLocked)},
+                {"--list"s, dumper(&SurfaceFlinger::listLayersLocked)},
+                {"--static-screen"s, dumper(&SurfaceFlinger::dumpStaticScreenStats)},
+                {"--timestats"s, protoDumper(&SurfaceFlinger::dumpTimeStats)},
+                {"--vsync"s, dumper(&SurfaceFlinger::dumpVSync)},
+                {"--wide-color"s, dumper(&SurfaceFlinger::dumpWideColorInfo)},
+        };
+        const auto flag = args.empty() ? ""s : std::string(String8(args[0]));
+        bool dumpLayers = true;
+        {
+            TimedLock lock(mStateLock, s2ns(1), __FUNCTION__);
+            if (!lock.locked()) {
+                StringAppendF(&result, "Dumping without lock after timeout: %s (%d)\n",
+                              strerror(-lock.status), lock.status);
+            }
+            if (const auto it = dumpers.find(flag); it != dumpers.end()) {
+                (it->second)(args, asProto, result);
+                dumpLayers = false;
+            } else if (!asProto) {
+                dumpAllLocked(args, result);
+            }
+        }
+        if (dumpLayers) {
+            const LayersProto layersProto = dumpProtoFromMainThread();
+            if (asProto) {
+                result.append(layersProto.SerializeAsString());
+            } else {
+                const auto layerTree = LayerProtoParser::generateLayerTree(layersProto);
+                result.append(LayerProtoParser::layerTreeToString(layerTree));
+                result.append("\n");
+                dumpOffscreenLayers(result);
@@ -2883,3 +3262,0 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
@@ -2888,4 +3265,2 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
+    write(fd, result.c_str(), result.size());
+    return NO_ERROR;
@@ -2893,7 +3268,3 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
+status_t SurfaceFlinger::dumpCritical(int fd, const DumpArgs&, bool asProto) {
+    if (asProto && mTracing.isEnabled()) {
+        mTracing.writeToFileAsync();
@@ -2901,6 +3272 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
+    return doDump(fd, DumpArgs(), asProto);
@@ -2908,3 +3274,3 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
+void SurfaceFlinger::listLayersLocked(std::string& result) const {
+    mCurrentState.traverseInZOrder(
+            [&](Layer* layer) { StringAppendF(&result, "%s\n", layer->getDebugName()); });
@@ -2911,0 +3278,7 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
+void SurfaceFlinger::dumpStatsLocked(const DumpArgs& args, std::string& result) const {
+    StringAppendF(&result, "%" PRId64 "\n", getVsyncPeriod());
+    if (args.size() > 1) {
+        const auto name = String8(args[1]);
+        mCurrentState.traverseInZOrder([&](Layer* layer) {
+            if (layer->getName() == name.string()) {
+                layer->dumpFrameStats(result);
@@ -2913,4 +3286,3 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
+        });
+    } else {
+        mAnimFrameTracker.dumpStats(result);
@@ -2918,7 +3289,0 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
@@ -2926,6 +3291,6 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
+void SurfaceFlinger::clearStatsLocked(const DumpArgs& args, std::string&) {
+    const bool clearAll = args.size() < 2;
+    const auto name = clearAll ? String8() : String8(args[1]);
+    mCurrentState.traverse([&](Layer* layer) {
+        if (clearAll || layer->getName() == name.string()) {
+            layer->clearFrameStats();
@@ -2933,3 +3298,2 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
+    });
+    mAnimFrameTracker.clearStats();
@@ -2936,0 +3301,2 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
+void SurfaceFlinger::dumpTimeStats(const DumpArgs& args, bool asProto, std::string& result) const {
+    mTimeStats->parseArgs(asProto, args, result);
@@ -2938,4 +3304,42 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
+void SurfaceFlinger::logFrameStats() {
+    mDrawingState.traverse([&](Layer* layer) {
+        layer->logFrameStats();
+    });
+    mAnimFrameTracker.logAndResetStats("<win-anim>");
+}
+void SurfaceFlinger::appendSfConfigString(std::string& result) const {
+    result.append(" [sf");
+    if (isLayerTripleBufferingDisabled())
+        result.append(" DISABLE_TRIPLE_BUFFERING");
+    StringAppendF(&result, " PRESENT_TIME_OFFSET=%" PRId64, dispSyncPresentTimeOffset);
+    StringAppendF(&result, " FORCE_HWC_FOR_RBG_TO_YUV=%d", useHwcForRgbToYuv);
+    StringAppendF(&result, " MAX_VIRT_DISPLAY_DIM=%" PRIu64, maxVirtualDisplaySize);
+    StringAppendF(&result, " RUNNING_WITHOUT_SYNC_FRAMEWORK=%d", !hasSyncFramework);
+    StringAppendF(&result, " NUM_FRAMEBUFFER_SURFACE_BUFFERS=%" PRId64,
+                  maxFrameBufferAcquiredBuffers);
+    result.append("]");
+}
+void SurfaceFlinger::dumpVSync(std::string& result) const {
+    mScheduler->dump(result);
+    mRefreshRateStats->dump(result);
+    result.append("\n");
+    mPhaseConfiguration->dump(result);
+    StringAppendF(&result,
+                  "      present offset: %9" PRId64 " ns\t     VSYNC period: %9" PRId64 " ns\n\n",
+                  dispSyncPresentTimeOffset, getVsyncPeriod());
+    scheduler::RefreshRateConfigs::Policy policy = mRefreshRateConfigs->getDisplayManagerPolicy();
+    StringAppendF(&result,
+                  "DesiredDisplayConfigSpecs (DisplayManager): default config ID: %d"
+                  ", primary range: [%.2f %.2f], app request range: [%.2f %.2f]\n\n",
+                  policy.defaultConfig.value(), policy.primaryRange.min, policy.primaryRange.max,
+                  policy.appRequestRange.min, policy.appRequestRange.max);
+    StringAppendF(&result, "(config override by backdoor: %s)\n\n",
+                  mDebugDisplayConfigSetByBackdoor ? "yes" : "no");
+    scheduler::RefreshRateConfigs::Policy currentPolicy = mRefreshRateConfigs->getCurrentPolicy();
+    if (currentPolicy != policy) {
+        StringAppendF(&result,
+                      "DesiredDisplayConfigSpecs (Override): default config ID: %d"
+                      ", primary range: [%.2f %.2f], app request range: [%.2f %.2f]\n\n",
+                      currentPolicy.defaultConfig.value(), currentPolicy.primaryRange.min,
+                      currentPolicy.primaryRange.max, currentPolicy.appRequestRange.min,
+                      currentPolicy.appRequestRange.max);
@@ -2943,7 +3347,54 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
+    mScheduler->dump(mAppConnectionHandle, result);
+    mScheduler->getPrimaryDispSync().dump(result);
+}
+void SurfaceFlinger::dumpStaticScreenStats(std::string& result) const {
+    result.append("Static screen stats:\n");
+    for (size_t b = 0; b < SurfaceFlingerBE::NUM_BUCKETS - 1; ++b) {
+        float bucketTimeSec = getBE().mFrameBuckets[b] / 1e9;
+        float percent = 100.0f *
+                static_cast<float>(getBE().mFrameBuckets[b]) / getBE().mTotalTime;
+        StringAppendF(&result, "  < %zd frames: %.3f s (%.1f%%)\n", b + 1, bucketTimeSec, percent);
+    }
+    float bucketTimeSec = getBE().mFrameBuckets[SurfaceFlingerBE::NUM_BUCKETS - 1] / 1e9;
+    float percent = 100.0f *
+            static_cast<float>(getBE().mFrameBuckets[SurfaceFlingerBE::NUM_BUCKETS - 1]) / getBE().mTotalTime;
+    StringAppendF(&result, "  %zd+ frames: %.3f s (%.1f%%)\n", SurfaceFlingerBE::NUM_BUCKETS - 1,
+                  bucketTimeSec, percent);
+}
+void SurfaceFlinger::recordBufferingStats(const std::string& layerName,
+                                          std::vector<OccupancyTracker::Segment>&& history) {
+    Mutex::Autolock lock(getBE().mBufferingStatsMutex);
+    auto& stats = getBE().mBufferingStats[layerName];
+    for (const auto& segment : history) {
+        if (!segment.usedThirdBuffer) {
+            stats.twoBufferTime += segment.totalTime;
+        }
+        if (segment.occupancyAverage < 1.0f) {
+            stats.doubleBufferedTime += segment.totalTime;
+        } else if (segment.occupancyAverage < 2.0f) {
+            stats.tripleBufferedTime += segment.totalTime;
+        }
+        ++stats.numSegments;
+        stats.totalTime += segment.totalTime;
+    }
+}
+void SurfaceFlinger::dumpFrameEventsLocked(std::string& result) {
+    result.append("Layer frame timestamps:\n");
+    const LayerVector& currentLayers = mCurrentState.layersSortedByZ;
+    const size_t count = currentLayers.size();
+    for (size_t i=0 ; i<count ; i++) {
+        currentLayers[i]->dumpFrameEvents(result);
+    }
+}
+void SurfaceFlinger::dumpBufferingStats(std::string& result) const {
+    result.append("Buffering stats:\n");
+    result.append("  [Layer name] <Active time> <Two buffer> "
+            "<Double buffered> <Triple buffered>\n");
+    Mutex::Autolock lock(getBE().mBufferingStatsMutex);
+    typedef std::tuple<std::string, float, float, float> BufferTuple;
+    std::map<float, BufferTuple, std::greater<float>> sorted;
+    for (const auto& statsPair : getBE().mBufferingStats) {
+        const char* name = statsPair.first.c_str();
+        const SurfaceFlingerBE::BufferingStats& stats = statsPair.second;
+        if (stats.numSegments == 0) {
+            continue;
@@ -2951,6 +3402,23 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
+        float activeTime = ns2ms(stats.totalTime) / 1000.0f;
+        float twoBufferRatio = static_cast<float>(stats.twoBufferTime) /
+                stats.totalTime;
+        float doubleBufferRatio = static_cast<float>(
+                stats.doubleBufferedTime) / stats.totalTime;
+        float tripleBufferRatio = static_cast<float>(
+                stats.tripleBufferedTime) / stats.totalTime;
+        sorted.insert({activeTime, {name, twoBufferRatio,
+                doubleBufferRatio, tripleBufferRatio}});
+    }
+    for (const auto& sortedPair : sorted) {
+        float activeTime = sortedPair.first;
+        const BufferTuple& values = sortedPair.second;
+        StringAppendF(&result, "  [%s] %.2f %.3f %.3f %.3f\n", std::get<0>(values).c_str(),
+                      activeTime, std::get<1>(values), std::get<2>(values), std::get<3>(values));
+    }
+    result.append("\n");
+}
+void SurfaceFlinger::dumpDisplayIdentificationData(std::string& result) const {
+    for (const auto& [token, display] : mDisplays) {
+        const auto displayId = display->getId();
+        if (!displayId) {
+            continue;
@@ -2958,3 +3426,3 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
+        const auto hwcDisplayId = getHwComposer().fromPhysicalDisplayId(*displayId);
+        if (!hwcDisplayId) {
+            continue;
@@ -2961,0 +3430,8 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
+        StringAppendF(&result,
+                      "Display %s (HWC display %" PRIu64 "): ", to_string(*displayId).c_str(),
+                      *hwcDisplayId);
+        uint8_t port;
+        DisplayIdentificationData data;
+        if (!getHwComposer().getDisplayIdentificationData(*hwcDisplayId, &port, &data)) {
+            result.append("no identification data\n");
+            continue;
@@ -2963,4 +3439,3 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
+        if (!isEdid(data)) {
+            result.append("unknown identification data\n");
+            continue;
@@ -2968,874 +3443,4 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
-            }
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
-            }
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
-    }
-}
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
-    }
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
-            }
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
-            }
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
-    }
-}
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
-    }
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
-            }
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
-            }
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
-    }
-}
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
-    }
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
-            }
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
-            }
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
-    }
-}
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
-    }
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
-            }
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
-            }
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
-    }
-}
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
-    }
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
-            }
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
-            }
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
-    }
-}
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
-    }
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
-            }
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
-            }
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
-    }
-}
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
-    }
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
-            }
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
-            }
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
-    }
-}
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
-    }
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
-            }
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
-            }
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
-    }
-}
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
-    }
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
-            }
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
-            }
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
-    }
-}
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
-    }
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
-            }
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
-            }
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
-    }
-}
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
-    }
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
-            }
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
-            }
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
-    }
-}
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
-    }
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
-            }
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
-            }
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
-    }
-}
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
-    }
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
-            }
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
-            }
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
-    }
-}
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
-    }
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
-            }
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
-            }
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
-    }
-}
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
-    }
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
-            }
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
-            }
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
-    }
-}
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
-    }
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
-            }
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
-            }
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
-    }
-}
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
-    }
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
-            }
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
-            }
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
-    }
-}
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
-    }
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
-            }
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
-            }
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
-    }
-}
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
-    }
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
-            }
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
-            }
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
-    }
-}
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
-    }
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
-            }
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
-            }
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
-    }
-}
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
-    }
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
-            }
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
-            }
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
-    }
-}
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
-    }
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
-            }
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
-            }
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
-    }
-}
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
-    }
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
-            }
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
-            }
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
-    }
-}
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
-    }
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
-            }
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
-            }
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
-    }
-}
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
-    }
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
-            }
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
-            }
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
-    }
-}
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
-    }
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
-            }
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
-            }
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
-    }
-}
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
-    }
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
-            }
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
-            }
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
-    }
-}
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
-    }
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
-            }
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
-            }
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
-    }
-}
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
-    }
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
-            }
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
-            }
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
-    }
-}
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
-    }
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
-            }
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
-            }
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
-    }
-}
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
-    }
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
-            }
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
-            }
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
-    }
-}
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
-    }
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
-            }
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
-            }
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
-    }
-}
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
-    }
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
-            }
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
-            }
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
-    }
-}
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
-    }
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
-            }
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
-            }
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
-    }
-}
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
+        const auto edid = parseEdid(data);
+        if (!edid) {
+            result.append("invalid EDID\n");
+            continue;
@@ -3843,7 +3448,3 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
+        StringAppendF(&result, "port=%u pnpId=%s displayName=\"", port, edid->pnpId.data());
+        result.append(edid->displayName.data(), edid->displayName.length());
+        result.append("\"\n");
@@ -3851,6 +3451,0 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
@@ -3858,3 +3453,8 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
+void SurfaceFlinger::dumpRawDisplayIdentificationData(const DumpArgs& args,
+                                                      std::string& result) const {
+    hal::HWDisplayId hwcDisplayId;
+    uint8_t port;
+    DisplayIdentificationData data;
+    if (args.size() > 1 && base::ParseUint(String8(args[1]), &hwcDisplayId) &&
+        getHwComposer().getDisplayIdentificationData(hwcDisplayId, &port, &data)) {
+        result.append(reinterpret_cast<const char*>(data.data()), data.size());
@@ -3863,4 +3463,9 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
+void SurfaceFlinger::dumpWideColorInfo(std::string& result) const {
+    StringAppendF(&result, "Device has wide color built-in display: %d\n", hasWideColorDisplay);
+    StringAppendF(&result, "Device uses color management: %d\n", useColorManagement);
+    StringAppendF(&result, "DisplayColorSetting: %s\n",
+                  decodeDisplayColorSetting(mDisplayColorSetting).c_str());
+    for (const auto& [token, display] : mDisplays) {
+        const auto displayId = display->getId();
+        if (!displayId) {
+            continue;
@@ -3868,7 +3473,4 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
+        StringAppendF(&result, "Display %s color modes:\n", to_string(*displayId).c_str());
+        std::vector<ColorMode> modes = getHwComposer().getColorModes(*displayId);
+        for (auto&& mode : modes) {
+            StringAppendF(&result, "    %s (%d)\n", decodeColorMode(mode).c_str(), mode);
@@ -3876,6 +3478,3 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
+        ColorMode currentMode = display->getCompositionDisplay()->getState().colorMode;
+        StringAppendF(&result, "    Current color mode: %s (%d)\n",
+                      decodeColorMode(currentMode).c_str(), currentMode);
@@ -3883,3 +3482 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
+    result.append("\n");
@@ -3886,0 +3484,36 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
+LayersProto SurfaceFlinger::dumpDrawingStateProto(uint32_t traceFlags) const {
+    const auto display = ON_MAIN_THREAD(getDefaultDisplayDeviceLocked());
+    LayersProto layersProto;
+    for (const sp<Layer>& layer : mDrawingState.layersSortedByZ) {
+        layer->writeToProto(layersProto, traceFlags, display.get());
+    }
+    return layersProto;
+}
+void SurfaceFlinger::dumpHwc(std::string& result) const {
+    getHwComposer().dump(result);
+}
+void SurfaceFlinger::dumpOffscreenLayersProto(LayersProto& layersProto, uint32_t traceFlags) const {
+    LayerProto* rootProto = layersProto.add_layers();
+    const int32_t offscreenRootLayerId = INT32_MAX - 2;
+    rootProto->set_id(offscreenRootLayerId);
+    rootProto->set_name("Offscreen Root");
+    rootProto->set_parent(-1);
+    for (Layer* offscreenLayer : mOffscreenLayers) {
+        rootProto->add_children(offscreenLayer->sequence);
+        LayerProto* layerProto =
+                offscreenLayer->writeToProto(layersProto, traceFlags, nullptr );
+        layerProto->set_parent(offscreenRootLayerId);
+    }
+}
+LayersProto SurfaceFlinger::dumpProtoFromMainThread(uint32_t traceFlags) {
+    return schedule([=] { return dumpDrawingStateProto(traceFlags); }).get();
+}
+void SurfaceFlinger::dumpOffscreenLayers(std::string& result) {
+    result.append("Offscreen Layers:\n");
+    result.append(schedule([this] {
+                      std::string result;
+                      for (Layer* offscreenLayer : mOffscreenLayers) {
+                          offscreenLayer->traverse(LayerVector::StateSet::Drawing,
+                                                   [&](Layer* layer) {
+                                                       layer->dumpCallingUidPid(result);
+                                                   });
@@ -3888,4 +3521,2 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
+                      return result;
+                  }).get());
@@ -3893,7 +3524,48 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
+void SurfaceFlinger::dumpAllLocked(const DumpArgs& args, std::string& result) const {
+    const bool colorize = !args.empty() && args[0] == String16("--color");
+    Colorizer colorizer(colorize);
+    const nsecs_t now = systemTime();
+    const nsecs_t inTransaction(mDebugInTransaction);
+    nsecs_t inTransactionDuration = (inTransaction) ? now-inTransaction : 0;
+    colorizer.bold(result);
+    result.append("Build configuration:");
+    colorizer.reset(result);
+    appendSfConfigString(result);
+    appendUiConfigString(result);
+    appendGuiConfigString(result);
+    result.append("\n");
+    result.append("\nDisplay identification data:\n");
+    dumpDisplayIdentificationData(result);
+    result.append("\nWide-Color information:\n");
+    dumpWideColorInfo(result);
+    colorizer.bold(result);
+    result.append("Sync configuration: ");
+    colorizer.reset(result);
+    result.append(SyncFeatures::getInstance().toString());
+    result.append("\n\n");
+    colorizer.bold(result);
+    result.append("Scheduler:\n");
+    colorizer.reset(result);
+    dumpVSync(result);
+    result.append("\n");
+    dumpStaticScreenStats(result);
+    result.append("\n");
+    StringAppendF(&result, "Total missed frame count: %u\n", mFrameMissedCount.load());
+    StringAppendF(&result, "HWC missed frame count: %u\n", mHwcFrameMissedCount.load());
+    StringAppendF(&result, "GPU missed frame count: %u\n\n", mGpuFrameMissedCount.load());
+    dumpBufferingStats(result);
+    colorizer.bold(result);
+    StringAppendF(&result, "Visible layers (count = %zu)\n", mNumLayers.load());
+    StringAppendF(&result, "GraphicBufferProducers: %zu, max %zu\n",
+                  mGraphicBufferProducerList.size(), mMaxGraphicBufferProducerListSize);
+    colorizer.reset(result);
+    {
+        StringAppendF(&result, "Composition layers\n");
+        mDrawingState.traverseInZOrder([&](Layer* layer) {
+            auto* compositionState = layer->getCompositionState();
+            if (!compositionState) return;
+            android::base::StringAppendF(&result, "* Layer %p (%s)\n", layer,
+                                         layer->getDebugName() ? layer->getDebugName()
+                                                               : "<unknown>");
+            compositionState->dump(result);
+        });
@@ -3901,6 +3573,40 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
+    colorizer.bold(result);
+    StringAppendF(&result, "Displays (%zu entries)\n", mDisplays.size());
+    colorizer.reset(result);
+    for (const auto& [token, display] : mDisplays) {
+        display->dump(result);
+    }
+    result.append("\n");
+    mCompositionEngine->dump(result);
+    colorizer.bold(result);
+    result.append("SurfaceFlinger global state:\n");
+    colorizer.reset(result);
+    getRenderEngine().dump(result);
+    DebugEGLImageTracker::getInstance()->dump(result);
+    if (const auto display = getDefaultDisplayDeviceLocked()) {
+        display->getCompositionDisplay()->getState().undefinedRegion.dump(result,
+                                                                          "undefinedRegion");
+        StringAppendF(&result, "  orientation=%s, isPoweredOn=%d\n",
+                      toCString(display->getOrientation()), display->isPoweredOn());
+    }
+    StringAppendF(&result,
+                  "  transaction-flags         : %08x\n"
+                  "  gpu_to_cpu_unsupported    : %d\n",
+                  mTransactionFlags.load(), !mGpuToCpuSupported);
+    if (const auto displayId = getInternalDisplayIdLocked();
+        displayId && getHwComposer().isConnected(*displayId)) {
+        const auto activeConfig = getHwComposer().getActiveConfig(*displayId);
+        StringAppendF(&result,
+                      "  refresh-rate              : %f fps\n"
+                      "  x-dpi                     : %f\n"
+                      "  y-dpi                     : %f\n",
+                      1e9 / getHwComposer().getDisplayVsyncPeriod(*displayId),
+                      activeConfig->getDpiX(), activeConfig->getDpiY());
+    }
+    StringAppendF(&result, "  transaction time: %f us\n", inTransactionDuration / 1000.0);
+    mTracing.dump(result);
+    result.append("\n");
+    for (const auto& [token, display] : mDisplays) {
+        const auto displayId = display->getId();
+        if (!displayId) {
+            continue;
@@ -3908,3 +3614,36 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
+        StringAppendF(&result, "Display %s HWC layers:\n", to_string(*displayId).c_str());
+        Layer::miniDumpHeader(result);
+        const DisplayDevice& ref = *display;
+        mCurrentState.traverseInZOrder([&](Layer* layer) { layer->miniDump(result, ref); });
+        result.append("\n");
+    }
+    colorizer.bold(result);
+    result.append("h/w composer state:\n");
+    colorizer.reset(result);
+    bool hwcDisabled = mDebugDisableHWC || mDebugRegion;
+    StringAppendF(&result, "  h/w composer %s\n", hwcDisabled ? "disabled" : "enabled");
+    getHwComposer().dump(result);
+    const GraphicBufferAllocator& alloc(GraphicBufferAllocator::get());
+    alloc.dump(result);
+    if (mVrFlingerRequestsDisplay && mVrFlinger) {
+        result.append("VrFlinger state:\n");
+        result.append(mVrFlinger->Dump());
+        result.append("\n");
+    }
+    result.append(mTimeStats->miniDump());
+    result.append("\n");
+}
+void SurfaceFlinger::updateColorMatrixLocked() {
+    mat4 colorMatrix;
+    if (mGlobalSaturationFactor != 1.0f) {
+        float3 luminance{0.213f, 0.715f, 0.072f};
+        luminance *= 1.0f - mGlobalSaturationFactor;
+        mat4 saturationMatrix = mat4(
+            vec4{luminance.r + mGlobalSaturationFactor, luminance.r, luminance.r, 0.0f},
+            vec4{luminance.g, luminance.g + mGlobalSaturationFactor, luminance.g, 0.0f},
+            vec4{luminance.b, luminance.b, luminance.b + mGlobalSaturationFactor, 0.0f},
+            vec4{0.0f, 0.0f, 0.0f, 1.0f}
+        );
+        colorMatrix = mClientColorMatrix * saturationMatrix * mDaltonizer();
+    } else {
+        colorMatrix = mClientColorMatrix * mDaltonizer();
@@ -3911,0 +3651,4 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
+    if (mCurrentState.colorMatrix != colorMatrix) {
+        mCurrentState.colorMatrix = colorMatrix;
+        mCurrentState.colorMatrixChanged = true;
+        setTransactionFlags(eTransactionNeeded);
@@ -3913,4 +3655,0 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
@@ -3918,7 +3657,32 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
+status_t SurfaceFlinger::CheckTransactCodeCredentials(uint32_t code) {
+#pragma clang diagnostic push
+#pragma clang diagnostic error "-Wswitch-enum"
+    switch (static_cast<ISurfaceComposerTag>(code)) {
+        case BOOT_FINISHED:
+        case CLEAR_ANIMATION_FRAME_STATS:
+        case CREATE_DISPLAY:
+        case DESTROY_DISPLAY:
+        case ENABLE_VSYNC_INJECTIONS:
+        case GET_ANIMATION_FRAME_STATS:
+        case GET_HDR_CAPABILITIES:
+        case SET_DESIRED_DISPLAY_CONFIG_SPECS:
+        case GET_DESIRED_DISPLAY_CONFIG_SPECS:
+        case SET_ACTIVE_COLOR_MODE:
+        case GET_AUTO_LOW_LATENCY_MODE_SUPPORT:
+        case SET_AUTO_LOW_LATENCY_MODE:
+        case GET_GAME_CONTENT_TYPE_SUPPORT:
+        case SET_GAME_CONTENT_TYPE:
+        case INJECT_VSYNC:
+        case SET_POWER_MODE:
+        case GET_DISPLAYED_CONTENT_SAMPLING_ATTRIBUTES:
+        case SET_DISPLAY_CONTENT_SAMPLING_ENABLED:
+        case GET_DISPLAYED_CONTENT_SAMPLE:
+        case NOTIFY_POWER_HINT:
+        case SET_GLOBAL_SHADOW_SETTINGS:
+        case ACQUIRE_FRAME_RATE_FLEXIBILITY_TOKEN: {
+            bool usePermissionCache = code != ACQUIRE_FRAME_RATE_FLEXIBILITY_TOKEN;
+            if (!callingThreadHasUnscopedSurfaceFlingerAccess(usePermissionCache)) {
+                IPCThreadState* ipc = IPCThreadState::self();
+                ALOGE("Permission Denial: can't access SurfaceFlinger pid=%d, uid=%d",
+                        ipc->getCallingPid(), ipc->getCallingUid());
+                return PERMISSION_DENIED;
@@ -3926,6 +3690 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
+            return OK;
@@ -3933,3 +3692,7 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
+        case GET_LAYER_DEBUG_INFO: {
+            IPCThreadState* ipc = IPCThreadState::self();
+            const int pid = ipc->getCallingPid();
+            const int uid = ipc->getCallingUid();
+            if ((uid != AID_SHELL) && !PermissionCache::checkPermission(sDump, pid, uid)) {
+                ALOGE("Layer debug info permission denied for pid=%d, uid=%d", pid, uid);
+                return PERMISSION_DENIED;
@@ -3936,0 +3700,37 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
+            return OK;
+        }
+        case CREATE_DISPLAY_EVENT_CONNECTION:
+        case AUTHENTICATE_SURFACE:
+        case GET_ACTIVE_COLOR_MODE:
+        case GET_ACTIVE_CONFIG:
+        case GET_PHYSICAL_DISPLAY_IDS:
+        case GET_PHYSICAL_DISPLAY_TOKEN:
+        case GET_DISPLAY_COLOR_MODES:
+        case GET_DISPLAY_NATIVE_PRIMARIES:
+        case GET_DISPLAY_INFO:
+        case GET_DISPLAY_CONFIGS:
+        case GET_DISPLAY_STATE:
+        case GET_DISPLAY_STATS:
+        case GET_SUPPORTED_FRAME_TIMESTAMPS:
+        case SET_TRANSACTION_STATE:
+        case CREATE_CONNECTION:
+        case GET_COLOR_MANAGEMENT:
+        case GET_COMPOSITION_PREFERENCE:
+        case GET_PROTECTED_CONTENT_SUPPORT:
+        case IS_WIDE_COLOR_DISPLAY:
+        case SET_FRAME_RATE:
+        case GET_DISPLAY_BRIGHTNESS_SUPPORT:
+        case SET_DISPLAY_BRIGHTNESS: {
+            return OK;
+        }
+        case CAPTURE_LAYERS:
+        case CAPTURE_SCREEN:
+        case ADD_REGION_SAMPLING_LISTENER:
+        case REMOVE_REGION_SAMPLING_LISTENER: {
+            IPCThreadState* ipc = IPCThreadState::self();
+            const int pid = ipc->getCallingPid();
+            const int uid = ipc->getCallingUid();
+            if ((uid != AID_GRAPHICS) &&
+                !PermissionCache::checkPermission(sReadFramebuffer, pid, uid)) {
+                ALOGE("Permission Denial: can't read framebuffer pid=%d, uid=%d", pid, uid);
+                return PERMISSION_DENIED;
@@ -3938,4 +3738 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
+            return OK;
@@ -3943,7 +3740,5 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
+        case CAPTURE_SCREEN_BY_ID: {
+            IPCThreadState* ipc = IPCThreadState::self();
+            const int uid = ipc->getCallingUid();
+            if (uid == AID_ROOT || uid == AID_GRAPHICS || uid == AID_SYSTEM || uid == AID_SHELL) {
+                return OK;
@@ -3951,6 +3746 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
+            return PERMISSION_DENIED;
@@ -3958,3 +3747,0 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
@@ -3961,0 +3749,4 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
+    if (code == IBinder::INTERFACE_TRANSACTION || code == IBinder::DUMP_TRANSACTION ||
+        code == IBinder::PING_TRANSACTION || code == IBinder::SHELL_COMMAND_TRANSACTION ||
+        code == IBinder::SYSPROPS_TRANSACTION) {
+        return OK;
@@ -3963,4 +3754,3 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
+    if (code >= 1000 && code <= 1036) {
+        ALOGV("Accessing SurfaceFlinger through backdoor code: %u", code);
+        return OK;
@@ -3968,7 +3758,21 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
+    ALOGE("Permission Denial: SurfaceFlinger did not recognize request code: %u", code);
+    return PERMISSION_DENIED;
+#pragma clang diagnostic pop
+}
+status_t SurfaceFlinger::onTransact(uint32_t code, const Parcel& data, Parcel* reply,
+                                    uint32_t flags) {
+    status_t credentialCheck = CheckTransactCodeCredentials(code);
+    if (credentialCheck != OK) {
+        return credentialCheck;
+    }
+    status_t err = BnSurfaceComposer::onTransact(code, data, reply, flags);
+    if (err == UNKNOWN_TRANSACTION || err == PERMISSION_DENIED) {
+        CHECK_INTERFACE(ISurfaceComposer, data, reply);
+        IPCThreadState* ipc = IPCThreadState::self();
+        const int uid = ipc->getCallingUid();
+        if (CC_UNLIKELY(uid != AID_SYSTEM
+                && !PermissionCache::checkCallingPermission(sHardwareTest))) {
+            const int pid = ipc->getCallingPid();
+            ALOGE("Permission Denial: "
+                    "can't access SurfaceFlinger pid=%d, uid=%d", pid, uid);
+            return PERMISSION_DENIED;
@@ -3976,6 +3780,14 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
+        int n;
+        switch (code) {
+            case 1000:
+            case 1001:
+                return NO_ERROR;
+            case 1002:
+                n = data.readInt32();
+                mDebugRegion = n ? n : (mDebugRegion ? 0 : 1);
+                invalidateHwcGeometry();
+                repaintEverything();
+                return NO_ERROR;
+            case 1004:{
+                repaintEverything();
+                return NO_ERROR;
@@ -3983,3 +3795,7 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
+            case 1005:{
+                Mutex::Autolock _l(mStateLock);
+                setTransactionFlags(
+                        eTransactionNeeded|
+                        eDisplayTransactionNeeded|
+                        eTraversalNeeded);
+                return NO_ERROR;
@@ -3986,0 +3803,3 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
+            case 1006:{
+                signalRefresh();
+                return NO_ERROR;
@@ -3988,4 +3807,23 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
+            case 1008:
+                n = data.readInt32();
+                mDebugDisableHWC = n != 0;
+                invalidateHwcGeometry();
+                repaintEverything();
+                return NO_ERROR;
+            case 1009:
+                n = data.readInt32();
+                mDebugDisableTransformHint = n != 0;
+                invalidateHwcGeometry();
+                repaintEverything();
+                return NO_ERROR;
+            case 1010:
+                reply->writeInt32(0);
+                reply->writeInt32(0);
+                reply->writeInt32(mDebugRegion);
+                reply->writeInt32(0);
+                reply->writeInt32(mDebugDisableHWC);
+                return NO_ERROR;
+            case 1013: {
+                const auto display = getDefaultDisplayDevice();
+                if (!display) {
+                    return NAME_NOT_FOUND;
@@ -3993,7 +3831,2 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
+                reply->writeInt32(display->getPageFlipCount());
+                return NO_ERROR;
@@ -4000,0 +3834,6 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
+            case 1014: {
+                Mutex::Autolock _l(mStateLock);
+                n = data.readInt32();
+                switch (n % 10) {
+                    case 1:
+                        mDaltonizer.setType(ColorBlindnessType::Protanomaly);
@@ -4002,6 +3841,2 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
-            }
+                    case 2:
+                        mDaltonizer.setType(ColorBlindnessType::Deuteranomaly);
@@ -4009 +3844,5 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-        case KernelIdleTimerAction::NoChange:
+                    case 3:
+                        mDaltonizer.setType(ColorBlindnessType::Tritanomaly);
+                        break;
+                    default:
+                        mDaltonizer.setType(ColorBlindnessType::None);
@@ -4011,0 +3851,4 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
+                if (n >= 10) {
+                    mDaltonizer.setMode(ColorBlindnessMode::Correction);
+                } else {
+                    mDaltonizer.setMode(ColorBlindnessMode::Simulation);
@@ -4013,4 +3856,2 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
+                updateColorMatrixLocked();
+                return NO_ERROR;
@@ -4018,7 +3859,7 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
+            case 1015: {
+                Mutex::Autolock _l(mStateLock);
+                n = data.readInt32();
+                if (n) {
+                    for (size_t i = 0 ; i < 4; i++) {
+                        for (size_t j = 0; j < 4; j++) {
+                            mClientColorMatrix[i][j] = data.readFloat();
@@ -4026,6 +3866,0 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
@@ -4033,3 +3868,2 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
+                } else {
+                    mClientColorMatrix = mat4();
@@ -4036,0 +3871,3 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
+                float4 lastRow(transpose(mClientColorMatrix)[3]);
+                if (any(greaterThan(abs(lastRow - float4{0, 0, 0, 1}), float4{1e-4f}))) {
+                    ALOGE("The color transform's last row must be (0, 0, 0, 1)");
@@ -4038,4 +3875,2 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
+                updateColorMatrixLocked();
+                return NO_ERROR;
@@ -4043,7 +3878,2 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
+            case 1016: {
+                return NAME_NOT_FOUND;
@@ -4051,6 +3881,4 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
+            case 1017: {
+                n = data.readInt32();
+                mForceFullDamage = n != 0;
+                return NO_ERROR;
@@ -4058,3 +3886,4 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
+            case 1018: {
+                n = data.readInt32();
+                mScheduler->setPhaseOffset(mAppConnectionHandle, static_cast<nsecs_t>(n));
+                return NO_ERROR;
@@ -4061,0 +3891,4 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
+            case 1019: {
+                n = data.readInt32();
+                mScheduler->setPhaseOffset(mSfConnectionHandle, static_cast<nsecs_t>(n));
+                return NO_ERROR;
@@ -4063,4 +3896,5 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
+            case 1020: {
+                n = data.readInt32();
+                if (n) {
+                    ALOGV("Interceptor enabled");
+                    mInterceptor->enable(mDrawingState.layersSortedByZ, mDrawingState.displays);
@@ -4068,7 +3902,3 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
+                else{
+                    ALOGV("Interceptor disabled");
+                    mInterceptor->disable();
@@ -4076,6 +3906 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
+                return NO_ERROR;
@@ -4083,3 +3908,4 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
+            case 1021: {
+                n = data.readInt32();
+                mUseHwcVirtualDisplays = !n;
+                return NO_ERROR;
@@ -4086,0 +3913,5 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
+            case 1022: {
+                Mutex::Autolock _l(mStateLock);
+                mGlobalSaturationFactor = std::max(0.0f, std::min(data.readFloat(), 2.0f));
+                updateColorMatrixLocked();
+                return NO_ERROR;
@@ -4088,4 +3919,5 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
+            case 1023: {
+                int32_t colorMode;
+                mDisplayColorSetting = static_cast<DisplayColorSetting>(data.readInt32());
+                if (data.readInt32(&colorMode) == NO_ERROR) {
+                    mForceColorMode = static_cast<ColorMode>(colorMode);
@@ -4093,7 +3925,3 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
+                invalidateHwcGeometry();
+                repaintEverything();
+                return NO_ERROR;
@@ -4101,6 +3929,2 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
+            case 1024: {
+                return NAME_NOT_FOUND;
@@ -4108,3 +3932,13 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
+            case 1025: {
+                n = data.readInt32();
+                if (n) {
+                    ALOGD("LayerTracing enabled");
+                    mTracingEnabledChanged = mTracing.enable();
+                    reply->writeInt32(NO_ERROR);
+                } else {
+                    ALOGD("LayerTracing disabled");
+                    mTracingEnabledChanged = mTracing.disable();
+                    if (mTracingEnabledChanged) {
+                        reply->writeInt32(mTracing.writeToFile());
+                    } else {
+                        reply->writeInt32(NO_ERROR);
@@ -4113,4 +3947 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
+                return NO_ERROR;
@@ -4118,7 +3949,3 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
+            case 1026: {
+                reply->writeBool(mTracing.isEnabled());
+                return NO_ERROR;
@@ -4126,6 +3953,4 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
+            case 1027: {
+                const auto display = getDefaultDisplayDevice();
+                if (!display) {
+                    return NAME_NOT_FOUND;
@@ -4132,0 +3958,4 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
+                DisplayColorSetting setting = static_cast<DisplayColorSetting>(data.readInt32());
+                switch (setting) {
+                    case DisplayColorSetting::kManaged:
+                        reply->writeBool(useColorManagement);
@@ -4134 +3963,9 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-        case KernelIdleTimerAction::NoChange:
+                    case DisplayColorSetting::kUnmanaged:
+                        reply->writeBool(true);
+                        break;
+                    case DisplayColorSetting::kEnhanced:
+                        reply->writeBool(display->hasRenderIntent(RenderIntent::ENHANCE));
+                        break;
+                    default:
+                        reply->writeBool(
+                                display->hasRenderIntent(static_cast<RenderIntent>(setting)));
@@ -4136,0 +3974 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
+                return NO_ERROR;
@@ -4138,4 +3976,4 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
+            case 1028: {
+                Mutex::Autolock _l(mStateLock);
+                reply->writeBool(getHwComposer().isUsingVrComposer());
+                return NO_ERROR;
@@ -4143,7 +3981,6 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
+            case 1029: {
+                n = data.readInt32();
+                if (n <= 0 || n > MAX_TRACING_MEMORY) {
+                    ALOGW("Invalid buffer size: %d KB", n);
+                    reply->writeInt32(BAD_VALUE);
+                    return BAD_VALUE;
@@ -4151,6 +3988,4 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
+                ALOGD("Updating trace buffer to %d KB", n);
+                mTracing.setBufferSize(n * 1024);
+                reply->writeInt32(NO_ERROR);
+                return NO_ERROR;
@@ -4158,3 +3993,3 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
+            case 1030: {
+                reply->writeBool(useColorManagement);
+                return NO_ERROR;
@@ -4161,0 +3997,9 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
+            case 1031: {
+                Mutex::Autolock _l(mStateLock);
+                n = data.readInt32();
+                if (n) {
+                    n = data.readInt32();
+                    if (n) {
+                        Dataspace dataspace = static_cast<Dataspace>(n);
+                        if (!validateCompositionDataspace(dataspace)) {
+                            return BAD_VALUE;
@@ -4163,4 +4007 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
+                        mDefaultCompositionDataspace = dataspace;
@@ -4168,7 +4009,5 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
+                    n = data.readInt32();
+                    if (n) {
+                        Dataspace dataspace = static_cast<Dataspace>(n);
+                        if (!validateCompositionDataspace(dataspace)) {
+                            return BAD_VALUE;
@@ -4176,6 +4015 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
+                        mWideColorGamutCompositionDataspace = dataspace;
@@ -4182,0 +4017,18 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
+                } else {
+                    mDefaultCompositionDataspace = defaultCompositionDataspace;
+                    mWideColorGamutCompositionDataspace = wideColorGamutCompositionDataspace;
+                }
+                return NO_ERROR;
+            }
+            case 1033: {
+                n = data.readUint32();
+                ALOGD("Updating trace flags to 0x%x", n);
+                mTracing.setTraceFlags(n);
+                reply->writeInt32(NO_ERROR);
+                return NO_ERROR;
+            }
+            case 1034: {
+                switch (n = data.readInt32()) {
+                    case 0:
+                    case 1:
+                        enableRefreshRateOverlay(static_cast<bool>(n));
@@ -4184,2 +4036,3 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-        case KernelIdleTimerAction::NoChange:
-            break;
+                    default: {
+                        Mutex::Autolock lock(mStateLock);
+                        reply->writeBool(mRefreshRateOverlay != nullptr);
@@ -4188,4 +4041 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
+                return NO_ERROR;
@@ -4193,7 +4043,8 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
+            case 1035: {
+                n = data.readInt32();
+                mDebugDisplayConfigSetByBackdoor = false;
+                if (n >= 0) {
+                    const auto displayToken = getInternalDisplayToken();
+                    status_t result = setActiveConfig(displayToken, n);
+                    if (result != NO_ERROR) {
+                        return result;
@@ -4201,6 +4052 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
+                    mDebugDisplayConfigSetByBackdoor = true;
@@ -4208,3 +4054 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
+                return NO_ERROR;
@@ -4211,0 +4056,6 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
+            case 1036: {
+                if (data.readInt32() > 0) {
+                    status_t result =
+                            acquireFrameRateFlexibilityToken(&mDebugFrameRateFlexibilityToken);
+                    if (result != NO_ERROR) {
+                        return result;
@@ -4213,4 +4063,2 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-void SurfaceFlinger::toggleKernelIdleTimer() {
-    using KernelIdleTimerAction = scheduler::RefreshRateConfigs::KernelIdleTimerAction;
-    if (!mSupportKernelIdleTimer) {
-        return;
+                } else {
+                    mDebugFrameRateFlexibilityToken = nullptr;
@@ -4218,7 +4066 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-    const KernelIdleTimerAction action = mRefreshRateConfigs->getIdleTimerAction();
-    switch (action) {
-        case KernelIdleTimerAction::TurnOff:
-            if (mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 0);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "false");
-                mKernelIdleTimerEnabled = false;
+                return NO_ERROR;
@@ -4226,6 +4067,0 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::TurnOn:
-            if (!mKernelIdleTimerEnabled) {
-                ATRACE_INT("KernelIdleTimer", 1);
-                base::SetProperty(KERNEL_IDLE_TIMER_PROP, "true");
-                mKernelIdleTimerEnabled = true;
@@ -4233,3 +4068,0 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
-            break;
-        case KernelIdleTimerAction::NoChange:
-            break;
@@ -4236,0 +4070,30 @@ void SurfaceFlinger::toggleKernelIdleTimer() {
+    return err;
+}
+void SurfaceFlinger::repaintEverything() {
+    mRepaintEverything = true;
+    signalTransaction();
+}
+void SurfaceFlinger::repaintEverythingForHWC() {
+    mRepaintEverything = true;
+    mPowerAdvisor.notifyDisplayUpdateImminent();
+    mEventQueue->invalidate();
+}
+void SurfaceFlinger::kernelTimerChanged(bool expired) {
+    static bool updateOverlay =
+            property_get_bool("debug.sf.kernel_idle_timer_update_overlay", true);
+    if (!updateOverlay) return;
+    if (Mutex::Autolock lock(mStateLock); !mRefreshRateOverlay) return;
+    static_cast<void>(schedule([=] {
+        const auto desiredActiveConfig = getDesiredActiveConfig();
+        const auto& current = desiredActiveConfig
+                ? mRefreshRateConfigs->getRefreshRateFromConfigId(desiredActiveConfig->configId)
+                : mRefreshRateConfigs->getCurrentRefreshRate();
+        const auto& min = mRefreshRateConfigs->getMinRefreshRate();
+        if (current != min) {
+            const bool timerExpired = mKernelIdleTimerEnabled && expired;
+            if (Mutex::Autolock lock(mStateLock); mRefreshRateOverlay) {
+                mRefreshRateOverlay->changeRefreshRate(timerExpired ? min : current);
+            }
+            mEventQueue->invalidate();
+        }
+    }));
@@ -4265,3 +4128 @@ public:
-    ~WindowDisconnector() {
-        native_window_api_disconnect(mWindow, mApi);
-    }
+    WindowDisconnector(ANativeWindow* window, int api) : mWindow(window), mApi(api) {}
@@ -4272 +4133 @@ private:
-    const int mApi;
+    ANativeWindow* mWindow;
@@ -4982,0 +4864,8 @@ void SurfaceFlinger::enableRefreshRateOverlay(bool enable) {
+}
+#if defined(__gl_h_)
+#error "don't include gl/gl.h in this file"
+#endif
+#if defined(__gl2_h_)
+#error "don't include gl2/gl2.h in this file"
+#endif
+#pragma clang diagnostic pop
