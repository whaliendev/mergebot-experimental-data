--- a/output/frameworks_native/f3d9a43a-eaf88010-f7bda296/services@inputflinger@dispatcher@InputDispatcher.no_comments_mergebot.cpp
+++ b/output/frameworks_native/f3d9a43a-eaf88010-f7bda296/services@inputflinger@dispatcher@InputDispatcher.no_comments_truth.cpp
@@ -11,0 +12,20 @@ static constexpr bool DEBUG_FOCUS = false;
+#include "InputDispatcher.h"
+#include "Connection.h"
+#include <errno.h>
+#include <inttypes.h>
+#include <limits.h>
+#include <statslog.h>
+#include <stddef.h>
+#include <time.h>
+#include <unistd.h>
+#include <queue>
+#include <sstream>
+#include <android-base/chrono_utils.h>
+#include <android-base/stringprintf.h>
+#include <binder/Binder.h>
+#include <input/InputDevice.h>
+#include <log/log.h>
+#include <openssl/hmac.h>
+#include <openssl/rand.h>
+#include <powermanager/PowerManager.h>
+#include <utils/Trace.h>
@@ -646,3 +666,1713 @@ void InputDispatcher::postCommandLocked(std::unique_ptr<CommandEntry> commandEnt
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
+void InputDispatcher::drainInboundQueueLocked() {
+    while (!mInboundQueue.empty()) {
+        EventEntry* entry = mInboundQueue.front();
+        mInboundQueue.pop_front();
+        releaseInboundEventLocked(entry);
+    }
+    traceInboundQueueLengthLocked();
+}
+void InputDispatcher::releasePendingEventLocked() {
+    if (mPendingEvent) {
+        resetANRTimeoutsLocked();
+        releaseInboundEventLocked(mPendingEvent);
+        mPendingEvent = nullptr;
+    }
+}
+void InputDispatcher::releaseInboundEventLocked(EventEntry* entry) {
+    InjectionState* injectionState = entry->injectionState;
+    if (injectionState && injectionState->injectionResult == INPUT_EVENT_INJECTION_PENDING) {
+#if DEBUG_DISPATCH_CYCLE
+        ALOGD("Injected inbound event was dropped.");
+#endif
+        setInjectionResult(entry, INPUT_EVENT_INJECTION_FAILED);
+    }
+    if (entry == mNextUnblockedEvent) {
+        mNextUnblockedEvent = nullptr;
+    }
+    addRecentEventLocked(entry);
+    entry->release();
+}
+void InputDispatcher::resetKeyRepeatLocked() {
+    if (mKeyRepeatState.lastKeyEntry) {
+        mKeyRepeatState.lastKeyEntry->release();
+        mKeyRepeatState.lastKeyEntry = nullptr;
+    }
+}
+KeyEntry* InputDispatcher::synthesizeKeyRepeatLocked(nsecs_t currentTime) {
+    KeyEntry* entry = mKeyRepeatState.lastKeyEntry;
+    uint32_t policyFlags = entry->policyFlags &
+            (POLICY_FLAG_RAW_MASK | POLICY_FLAG_PASS_TO_USER | POLICY_FLAG_TRUSTED);
+    if (entry->refCount == 1) {
+        entry->recycle();
+        entry->id = mIdGenerator.nextId();
+        entry->eventTime = currentTime;
+        entry->policyFlags = policyFlags;
+        entry->repeatCount += 1;
+    } else {
+        KeyEntry* newEntry =
+                new KeyEntry(mIdGenerator.nextId(), currentTime, entry->deviceId, entry->source,
+                             entry->displayId, policyFlags, entry->action, entry->flags,
+                             entry->keyCode, entry->scanCode, entry->metaState,
+                             entry->repeatCount + 1, entry->downTime);
+        mKeyRepeatState.lastKeyEntry = newEntry;
+        entry->release();
+        entry = newEntry;
+    }
+    entry->syntheticRepeat = true;
+    entry->refCount += 1;
+    mKeyRepeatState.nextRepeatTime = currentTime + mConfig.keyRepeatDelay;
+    return entry;
+}
+bool InputDispatcher::dispatchConfigurationChangedLocked(nsecs_t currentTime,
+                                                         ConfigurationChangedEntry* entry) {
+#if DEBUG_OUTBOUND_EVENT_DETAILS
+    ALOGD("dispatchConfigurationChanged - eventTime=%" PRId64, entry->eventTime);
+#endif
+    resetKeyRepeatLocked();
+    std::unique_ptr<CommandEntry> commandEntry = std::make_unique<CommandEntry>(
+            &InputDispatcher::doNotifyConfigurationChangedLockedInterruptible);
+    commandEntry->eventTime = entry->eventTime;
+    postCommandLocked(std::move(commandEntry));
+    return true;
+}
+bool InputDispatcher::dispatchDeviceResetLocked(nsecs_t currentTime, DeviceResetEntry* entry) {
+#if DEBUG_OUTBOUND_EVENT_DETAILS
+    ALOGD("dispatchDeviceReset - eventTime=%" PRId64 ", deviceId=%d", entry->eventTime,
+          entry->deviceId);
+#endif
+    CancelationOptions options(CancelationOptions::CANCEL_ALL_EVENTS, "device was reset");
+    options.deviceId = entry->deviceId;
+    synthesizeCancelationEventsForAllConnectionsLocked(options);
+    return true;
+}
+void InputDispatcher::enqueueFocusEventLocked(const InputWindowHandle& window, bool hasFocus) {
+    FocusEntry* focusEntry =
+            new FocusEntry(mIdGenerator.nextId(), now(), window.getToken(), hasFocus);
+    enqueueInboundEventLocked(focusEntry);
+}
+void InputDispatcher::dispatchFocusLocked(nsecs_t currentTime, FocusEntry* entry) {
+    sp<InputChannel> channel = getInputChannelLocked(entry->connectionToken);
+    if (channel == nullptr) {
+        return;
+    }
+    InputTarget target;
+    target.inputChannel = channel;
+    target.flags = InputTarget::FLAG_DISPATCH_AS_IS;
+    entry->dispatchInProgress = true;
+    dispatchEventLocked(currentTime, entry, {target});
+}
+bool InputDispatcher::dispatchKeyLocked(nsecs_t currentTime, KeyEntry* entry,
+                                        DropReason* dropReason, nsecs_t* nextWakeupTime) {
+    if (!entry->dispatchInProgress) {
+        if (entry->repeatCount == 0 && entry->action == AKEY_EVENT_ACTION_DOWN &&
+            (entry->policyFlags & POLICY_FLAG_TRUSTED) &&
+            (!(entry->policyFlags & POLICY_FLAG_DISABLE_KEY_REPEAT))) {
+            if (mKeyRepeatState.lastKeyEntry &&
+                mKeyRepeatState.lastKeyEntry->keyCode == entry->keyCode) {
+                entry->repeatCount = mKeyRepeatState.lastKeyEntry->repeatCount + 1;
+                resetKeyRepeatLocked();
+                mKeyRepeatState.nextRepeatTime = LONG_LONG_MAX;
+            } else {
+                resetKeyRepeatLocked();
+                mKeyRepeatState.nextRepeatTime = entry->eventTime + mConfig.keyRepeatTimeout;
+            }
+            mKeyRepeatState.lastKeyEntry = entry;
+            entry->refCount += 1;
+        } else if (!entry->syntheticRepeat) {
+            resetKeyRepeatLocked();
+        }
+        if (entry->repeatCount == 1) {
+            entry->flags |= AKEY_EVENT_FLAG_LONG_PRESS;
+        } else {
+            entry->flags &= ~AKEY_EVENT_FLAG_LONG_PRESS;
+        }
+        entry->dispatchInProgress = true;
+        logOutboundKeyDetails("dispatchKey - ", *entry);
+    }
+    if (entry->interceptKeyResult == KeyEntry::INTERCEPT_KEY_RESULT_TRY_AGAIN_LATER) {
+        if (currentTime < entry->interceptKeyWakeupTime) {
+            if (entry->interceptKeyWakeupTime < *nextWakeupTime) {
+                *nextWakeupTime = entry->interceptKeyWakeupTime;
+            }
+            return false;
+        }
+        entry->interceptKeyResult = KeyEntry::INTERCEPT_KEY_RESULT_UNKNOWN;
+        entry->interceptKeyWakeupTime = 0;
+    }
+    if (entry->interceptKeyResult == KeyEntry::INTERCEPT_KEY_RESULT_UNKNOWN) {
+        if (entry->policyFlags & POLICY_FLAG_PASS_TO_USER) {
+            std::unique_ptr<CommandEntry> commandEntry = std::make_unique<CommandEntry>(
+                    &InputDispatcher::doInterceptKeyBeforeDispatchingLockedInterruptible);
+            sp<InputWindowHandle> focusedWindowHandle =
+                    getValueByKey(mFocusedWindowHandlesByDisplay, getTargetDisplayId(*entry));
+            if (focusedWindowHandle != nullptr) {
+                commandEntry->inputChannel = getInputChannelLocked(focusedWindowHandle->getToken());
+            }
+            commandEntry->keyEntry = entry;
+            postCommandLocked(std::move(commandEntry));
+            entry->refCount += 1;
+            return false;
+        } else {
+            entry->interceptKeyResult = KeyEntry::INTERCEPT_KEY_RESULT_CONTINUE;
+        }
+    } else if (entry->interceptKeyResult == KeyEntry::INTERCEPT_KEY_RESULT_SKIP) {
+        if (*dropReason == DropReason::NOT_DROPPED) {
+            *dropReason = DropReason::POLICY;
+        }
+    }
+    if (*dropReason != DropReason::NOT_DROPPED) {
+        setInjectionResult(entry,
+                           *dropReason == DropReason::POLICY ? INPUT_EVENT_INJECTION_SUCCEEDED
+                                                             : INPUT_EVENT_INJECTION_FAILED);
+        mReporter->reportDroppedKey(entry->id);
+        return true;
+    }
+    std::vector<InputTarget> inputTargets;
+    int32_t injectionResult =
+            findFocusedWindowTargetsLocked(currentTime, *entry, inputTargets, nextWakeupTime);
+    if (injectionResult == INPUT_EVENT_INJECTION_PENDING) {
+        return false;
+    }
+    setInjectionResult(entry, injectionResult);
+    if (injectionResult != INPUT_EVENT_INJECTION_SUCCEEDED) {
+        return true;
+    }
+    addGlobalMonitoringTargetsLocked(inputTargets, getTargetDisplayId(*entry));
+    dispatchEventLocked(currentTime, entry, inputTargets);
+    return true;
+}
+void InputDispatcher::logOutboundKeyDetails(const char* prefix, const KeyEntry& entry) {
+#if DEBUG_OUTBOUND_EVENT_DETAILS
+    ALOGD("%seventTime=%" PRId64 ", deviceId=%d, source=0x%x, displayId=%" PRId32 ", "
+          "policyFlags=0x%x, action=0x%x, flags=0x%x, keyCode=0x%x, scanCode=0x%x, "
+          "metaState=0x%x, repeatCount=%d, downTime=%" PRId64,
+          prefix, entry.eventTime, entry.deviceId, entry.source, entry.displayId, entry.policyFlags,
+          entry.action, entry.flags, entry.keyCode, entry.scanCode, entry.metaState,
+          entry.repeatCount, entry.downTime);
+#endif
+}
+bool InputDispatcher::dispatchMotionLocked(nsecs_t currentTime, MotionEntry* entry,
+                                           DropReason* dropReason, nsecs_t* nextWakeupTime) {
+    ATRACE_CALL();
+    if (!entry->dispatchInProgress) {
+        entry->dispatchInProgress = true;
+        logOutboundMotionDetails("dispatchMotion - ", *entry);
+    }
+    if (*dropReason != DropReason::NOT_DROPPED) {
+        setInjectionResult(entry,
+                           *dropReason == DropReason::POLICY ? INPUT_EVENT_INJECTION_SUCCEEDED
+                                                             : INPUT_EVENT_INJECTION_FAILED);
+        return true;
+    }
+    bool isPointerEvent = entry->source & AINPUT_SOURCE_CLASS_POINTER;
+    std::vector<InputTarget> inputTargets;
+    bool conflictingPointerActions = false;
+    int32_t injectionResult;
+    if (isPointerEvent) {
+        injectionResult =
+                findTouchedWindowTargetsLocked(currentTime, *entry, inputTargets, nextWakeupTime,
+                                               &conflictingPointerActions);
+    } else {
+        injectionResult =
+                findFocusedWindowTargetsLocked(currentTime, *entry, inputTargets, nextWakeupTime);
+    }
+    if (injectionResult == INPUT_EVENT_INJECTION_PENDING) {
+        return false;
+    }
+    setInjectionResult(entry, injectionResult);
+    if (injectionResult != INPUT_EVENT_INJECTION_SUCCEEDED) {
+        if (injectionResult != INPUT_EVENT_INJECTION_PERMISSION_DENIED) {
+            CancelationOptions::Mode mode(isPointerEvent
+                                                  ? CancelationOptions::CANCEL_POINTER_EVENTS
+                                                  : CancelationOptions::CANCEL_NON_POINTER_EVENTS);
+            CancelationOptions options(mode, "input event injection failed");
+            synthesizeCancelationEventsForMonitorsLocked(options);
+        }
+        return true;
+    }
+    addGlobalMonitoringTargetsLocked(inputTargets, getTargetDisplayId(*entry));
+    if (isPointerEvent) {
+        ssize_t stateIndex = mTouchStatesByDisplay.indexOfKey(entry->displayId);
+        if (stateIndex >= 0) {
+            const TouchState& state = mTouchStatesByDisplay.valueAt(stateIndex);
+            if (!state.portalWindows.empty()) {
+                for (size_t i = 0; i < state.portalWindows.size(); i++) {
+                    const InputWindowInfo* windowInfo = state.portalWindows[i]->getInfo();
+                    addGlobalMonitoringTargetsLocked(inputTargets, windowInfo->portalToDisplayId,
+                                                     -windowInfo->frameLeft, -windowInfo->frameTop);
+                }
+            }
+        }
+    }
+    if (conflictingPointerActions) {
+        CancelationOptions options(CancelationOptions::CANCEL_POINTER_EVENTS,
+                                   "conflicting pointer actions");
+        synthesizeCancelationEventsForAllConnectionsLocked(options);
+    }
+    dispatchEventLocked(currentTime, entry, inputTargets);
+    return true;
+}
+void InputDispatcher::logOutboundMotionDetails(const char* prefix, const MotionEntry& entry) {
+#if DEBUG_OUTBOUND_EVENT_DETAILS
+    ALOGD("%seventTime=%" PRId64 ", deviceId=%d, source=0x%x, displayId=%" PRId32
+          ", policyFlags=0x%x, "
+          "action=0x%x, actionButton=0x%x, flags=0x%x, "
+          "metaState=0x%x, buttonState=0x%x,"
+          "edgeFlags=0x%x, xPrecision=%f, yPrecision=%f, downTime=%" PRId64,
+          prefix, entry.eventTime, entry.deviceId, entry.source, entry.displayId, entry.policyFlags,
+          entry.action, entry.actionButton, entry.flags, entry.metaState, entry.buttonState,
+          entry.edgeFlags, entry.xPrecision, entry.yPrecision, entry.downTime);
+    for (uint32_t i = 0; i < entry.pointerCount; i++) {
+        ALOGD("  Pointer %d: id=%d, toolType=%d, "
+              "x=%f, y=%f, pressure=%f, size=%f, "
+              "touchMajor=%f, touchMinor=%f, toolMajor=%f, toolMinor=%f, "
+              "orientation=%f",
+              i, entry.pointerProperties[i].id, entry.pointerProperties[i].toolType,
+              entry.pointerCoords[i].getAxisValue(AMOTION_EVENT_AXIS_X),
+              entry.pointerCoords[i].getAxisValue(AMOTION_EVENT_AXIS_Y),
+              entry.pointerCoords[i].getAxisValue(AMOTION_EVENT_AXIS_PRESSURE),
+              entry.pointerCoords[i].getAxisValue(AMOTION_EVENT_AXIS_SIZE),
+              entry.pointerCoords[i].getAxisValue(AMOTION_EVENT_AXIS_TOUCH_MAJOR),
+              entry.pointerCoords[i].getAxisValue(AMOTION_EVENT_AXIS_TOUCH_MINOR),
+              entry.pointerCoords[i].getAxisValue(AMOTION_EVENT_AXIS_TOOL_MAJOR),
+              entry.pointerCoords[i].getAxisValue(AMOTION_EVENT_AXIS_TOOL_MINOR),
+              entry.pointerCoords[i].getAxisValue(AMOTION_EVENT_AXIS_ORIENTATION));
+    }
+#endif
+}
+void InputDispatcher::dispatchEventLocked(nsecs_t currentTime, EventEntry* eventEntry,
+                                          const std::vector<InputTarget>& inputTargets) {
+    ATRACE_CALL();
+#if DEBUG_DISPATCH_CYCLE
+    ALOGD("dispatchEventToCurrentInputTargets");
+#endif
+    ALOG_ASSERT(eventEntry->dispatchInProgress);
+    pokeUserActivityLocked(*eventEntry);
+    for (const InputTarget& inputTarget : inputTargets) {
+        sp<Connection> connection =
+                getConnectionLocked(inputTarget.inputChannel->getConnectionToken());
+        if (connection != nullptr) {
+            prepareDispatchCycleLocked(currentTime, connection, eventEntry, inputTarget);
+        } else {
+            if (DEBUG_FOCUS) {
+                ALOGD("Dropping event delivery to target with channel '%s' because it "
+                      "is no longer registered with the input dispatcher.",
+                      inputTarget.inputChannel->getName().c_str());
+            }
+        }
+    }
+}
+int32_t InputDispatcher::handleTargetsNotReadyLocked(
+        nsecs_t currentTime, const EventEntry& entry,
+        const sp<InputApplicationHandle>& applicationHandle,
+        const sp<InputWindowHandle>& windowHandle, nsecs_t* nextWakeupTime, const char* reason) {
+    if (applicationHandle == nullptr && windowHandle == nullptr) {
+        if (mInputTargetWaitCause != INPUT_TARGET_WAIT_CAUSE_SYSTEM_NOT_READY) {
+            if (DEBUG_FOCUS) {
+                ALOGD("Waiting for system to become ready for input.  Reason: %s", reason);
+            }
+            mInputTargetWaitCause = INPUT_TARGET_WAIT_CAUSE_SYSTEM_NOT_READY;
+            mInputTargetWaitStartTime = currentTime;
+            mInputTargetWaitTimeoutTime = LONG_LONG_MAX;
+            mInputTargetWaitTimeoutExpired = false;
+            mInputTargetWaitApplicationToken.clear();
+        }
+    } else {
+        if (mInputTargetWaitCause != INPUT_TARGET_WAIT_CAUSE_APPLICATION_NOT_READY) {
+            if (DEBUG_FOCUS) {
+                ALOGD("Waiting for application to become ready for input: %s.  Reason: %s",
+                      getApplicationWindowLabel(applicationHandle, windowHandle).c_str(), reason);
+            }
+            nsecs_t timeout;
+            if (windowHandle != nullptr) {
+                timeout = windowHandle->getDispatchingTimeout(DEFAULT_INPUT_DISPATCHING_TIMEOUT);
+            } else if (applicationHandle != nullptr) {
+                timeout =
+                        applicationHandle->getDispatchingTimeout(DEFAULT_INPUT_DISPATCHING_TIMEOUT);
+            } else {
+                timeout = DEFAULT_INPUT_DISPATCHING_TIMEOUT;
+            }
+            mInputTargetWaitCause = INPUT_TARGET_WAIT_CAUSE_APPLICATION_NOT_READY;
+            mInputTargetWaitStartTime = currentTime;
+            mInputTargetWaitTimeoutTime = currentTime + timeout;
+            mInputTargetWaitTimeoutExpired = false;
+            mInputTargetWaitApplicationToken.clear();
+            if (windowHandle != nullptr) {
+                mInputTargetWaitApplicationToken = windowHandle->getApplicationToken();
+            }
+            if (mInputTargetWaitApplicationToken == nullptr && applicationHandle != nullptr) {
+                mInputTargetWaitApplicationToken = applicationHandle->getApplicationToken();
+            }
+        }
+    }
+    if (mInputTargetWaitTimeoutExpired) {
+        return INPUT_EVENT_INJECTION_TIMED_OUT;
+    }
+    if (currentTime >= mInputTargetWaitTimeoutTime) {
+        onANRLocked(currentTime, applicationHandle, windowHandle, entry.eventTime,
+                    mInputTargetWaitStartTime, reason);
+        *nextWakeupTime = LONG_LONG_MIN;
+        return INPUT_EVENT_INJECTION_PENDING;
+    } else {
+        if (mInputTargetWaitTimeoutTime < *nextWakeupTime) {
+            *nextWakeupTime = mInputTargetWaitTimeoutTime;
+        }
+        return INPUT_EVENT_INJECTION_PENDING;
+    }
+}
+void InputDispatcher::removeWindowByTokenLocked(const sp<IBinder>& token) {
+    for (size_t d = 0; d < mTouchStatesByDisplay.size(); d++) {
+        TouchState& state = mTouchStatesByDisplay.editValueAt(d);
+        state.removeWindowByToken(token);
+    }
+}
+void InputDispatcher::resumeAfterTargetsNotReadyTimeoutLocked(
+        nsecs_t newTimeout, const sp<IBinder>& inputConnectionToken) {
+    if (newTimeout > 0) {
+        mInputTargetWaitTimeoutTime = now() + newTimeout;
+    } else {
+        mInputTargetWaitTimeoutExpired = true;
+        sp<Connection> connection = getConnectionLocked(inputConnectionToken);
+        if (connection != nullptr) {
+            removeWindowByTokenLocked(inputConnectionToken);
+            if (connection->status == Connection::STATUS_NORMAL) {
+                CancelationOptions options(CancelationOptions::CANCEL_ALL_EVENTS,
+                                           "application not responding");
+                synthesizeCancelationEventsForConnectionLocked(connection, options);
+            }
+        }
+    }
+}
+nsecs_t InputDispatcher::getTimeSpentWaitingForApplicationLocked(nsecs_t currentTime) {
+    if (mInputTargetWaitCause == INPUT_TARGET_WAIT_CAUSE_APPLICATION_NOT_READY) {
+        return currentTime - mInputTargetWaitStartTime;
+    }
+    return 0;
+}
+void InputDispatcher::resetANRTimeoutsLocked() {
+    if (DEBUG_FOCUS) {
+        ALOGD("Resetting ANR timeouts.");
+    }
+    mInputTargetWaitCause = INPUT_TARGET_WAIT_CAUSE_NONE;
+    mInputTargetWaitApplicationToken.clear();
+}
+int32_t InputDispatcher::getTargetDisplayId(const EventEntry& entry) {
+    int32_t displayId;
+    switch (entry.type) {
+        case EventEntry::Type::KEY: {
+            const KeyEntry& keyEntry = static_cast<const KeyEntry&>(entry);
+            displayId = keyEntry.displayId;
+            break;
+        }
+        case EventEntry::Type::MOTION: {
+            const MotionEntry& motionEntry = static_cast<const MotionEntry&>(entry);
+            displayId = motionEntry.displayId;
+            break;
+        }
+        case EventEntry::Type::FOCUS:
+        case EventEntry::Type::CONFIGURATION_CHANGED:
+        case EventEntry::Type::DEVICE_RESET: {
+            ALOGE("%s events do not have a target display", EventEntry::typeToString(entry.type));
+            return ADISPLAY_ID_NONE;
+        }
+    }
+    return displayId == ADISPLAY_ID_NONE ? mFocusedDisplayId : displayId;
+}
+int32_t InputDispatcher::findFocusedWindowTargetsLocked(nsecs_t currentTime,
+                                                        const EventEntry& entry,
+                                                        std::vector<InputTarget>& inputTargets,
+                                                        nsecs_t* nextWakeupTime) {
+    int32_t injectionResult;
+    std::string reason;
+    int32_t displayId = getTargetDisplayId(entry);
+    sp<InputWindowHandle> focusedWindowHandle =
+            getValueByKey(mFocusedWindowHandlesByDisplay, displayId);
+    sp<InputApplicationHandle> focusedApplicationHandle =
+            getValueByKey(mFocusedApplicationHandlesByDisplay, displayId);
+    if (focusedWindowHandle == nullptr) {
+        if (focusedApplicationHandle != nullptr) {
+            injectionResult =
+                    handleTargetsNotReadyLocked(currentTime, entry, focusedApplicationHandle,
+                                                nullptr, nextWakeupTime,
+                                                "Waiting because no window has focus but there is "
+                                                "a focused application that may eventually add a "
+                                                "window when it finishes starting up.");
+            goto Unresponsive;
+        }
+        ALOGI("Dropping event because there is no focused window or focused application in display "
+              "%" PRId32 ".",
+              displayId);
+        injectionResult = INPUT_EVENT_INJECTION_FAILED;
+        goto Failed;
+    }
+    if (!checkInjectionPermission(focusedWindowHandle, entry.injectionState)) {
+        injectionResult = INPUT_EVENT_INJECTION_PERMISSION_DENIED;
+        goto Failed;
+    }
+    reason = checkWindowReadyForMoreInputLocked(currentTime, focusedWindowHandle, entry, "focused");
+    if (!reason.empty()) {
+        injectionResult =
+                handleTargetsNotReadyLocked(currentTime, entry, focusedApplicationHandle,
+                                            focusedWindowHandle, nextWakeupTime, reason.c_str());
+        goto Unresponsive;
+    }
+    injectionResult = INPUT_EVENT_INJECTION_SUCCEEDED;
+    addWindowTargetLocked(focusedWindowHandle,
+                          InputTarget::FLAG_FOREGROUND | InputTarget::FLAG_DISPATCH_AS_IS,
+                          BitSet32(0), inputTargets);
+Failed:
+Unresponsive:
+    nsecs_t timeSpentWaitingForApplication = getTimeSpentWaitingForApplicationLocked(currentTime);
+    updateDispatchStatistics(currentTime, entry, injectionResult, timeSpentWaitingForApplication);
+    if (DEBUG_FOCUS) {
+        ALOGD("findFocusedWindow finished: injectionResult=%d, "
+              "timeSpentWaitingForApplication=%0.1fms",
+              injectionResult, timeSpentWaitingForApplication / 1000000.0);
+    }
+    return injectionResult;
+}
+int32_t InputDispatcher::findTouchedWindowTargetsLocked(nsecs_t currentTime,
+                                                        const MotionEntry& entry,
+                                                        std::vector<InputTarget>& inputTargets,
+                                                        nsecs_t* nextWakeupTime,
+                                                        bool* outConflictingPointerActions) {
+    ATRACE_CALL();
+    enum InjectionPermission {
+        INJECTION_PERMISSION_UNKNOWN,
+        INJECTION_PERMISSION_GRANTED,
+        INJECTION_PERMISSION_DENIED
+    };
+    int32_t displayId = entry.displayId;
+    int32_t action = entry.action;
+    int32_t maskedAction = action & AMOTION_EVENT_ACTION_MASK;
+    int32_t injectionResult = INPUT_EVENT_INJECTION_PENDING;
+    InjectionPermission injectionPermission = INJECTION_PERMISSION_UNKNOWN;
+    sp<InputWindowHandle> newHoverWindowHandle;
+    const TouchState* oldState = nullptr;
+    ssize_t oldStateIndex = mTouchStatesByDisplay.indexOfKey(displayId);
+    if (oldStateIndex >= 0) {
+        oldState = &mTouchStatesByDisplay.valueAt(oldStateIndex);
+        mTempTouchState.copyFrom(*oldState);
+    }
+    bool isSplit = mTempTouchState.split;
+    bool switchedDevice = mTempTouchState.deviceId >= 0 && mTempTouchState.displayId >= 0 &&
+            (mTempTouchState.deviceId != entry.deviceId || mTempTouchState.source != entry.source ||
+             mTempTouchState.displayId != displayId);
+    bool isHoverAction = (maskedAction == AMOTION_EVENT_ACTION_HOVER_MOVE ||
+                          maskedAction == AMOTION_EVENT_ACTION_HOVER_ENTER ||
+                          maskedAction == AMOTION_EVENT_ACTION_HOVER_EXIT);
+    bool newGesture = (maskedAction == AMOTION_EVENT_ACTION_DOWN ||
+                       maskedAction == AMOTION_EVENT_ACTION_SCROLL || isHoverAction);
+    const bool isFromMouse = entry.source == AINPUT_SOURCE_MOUSE;
+    bool wrongDevice = false;
+    if (newGesture) {
+        bool down = maskedAction == AMOTION_EVENT_ACTION_DOWN;
+        if (switchedDevice && mTempTouchState.down && !down && !isHoverAction) {
+            if (DEBUG_FOCUS) {
+                ALOGD("Dropping event because a pointer for a different device is already down "
+                      "in display %" PRId32,
+                      displayId);
+            }
+            injectionResult = INPUT_EVENT_INJECTION_FAILED;
+            switchedDevice = false;
+            wrongDevice = true;
+            goto Failed;
+        }
+        mTempTouchState.reset();
+        mTempTouchState.down = down;
+        mTempTouchState.deviceId = entry.deviceId;
+        mTempTouchState.source = entry.source;
+        mTempTouchState.displayId = displayId;
+        isSplit = false;
+    } else if (switchedDevice && maskedAction == AMOTION_EVENT_ACTION_MOVE) {
+        if (DEBUG_FOCUS) {
+            ALOGI("Dropping move event because a pointer for a different device is already active "
+                  "in display %" PRId32,
+                  displayId);
+        }
+        injectionResult = INPUT_EVENT_INJECTION_PERMISSION_DENIED;
+        switchedDevice = false;
+        wrongDevice = true;
+        goto Failed;
+    }
+    if (newGesture || (isSplit && maskedAction == AMOTION_EVENT_ACTION_POINTER_DOWN)) {
+        int32_t x;
+        int32_t y;
+        int32_t pointerIndex = getMotionEventActionPointerIndex(action);
+        if (isFromMouse) {
+            x = int32_t(entry.xCursorPosition);
+            y = int32_t(entry.yCursorPosition);
+        } else {
+            x = int32_t(entry.pointerCoords[pointerIndex].getAxisValue(AMOTION_EVENT_AXIS_X));
+            y = int32_t(entry.pointerCoords[pointerIndex].getAxisValue(AMOTION_EVENT_AXIS_Y));
+        }
+        bool isDown = maskedAction == AMOTION_EVENT_ACTION_DOWN;
+        sp<InputWindowHandle> newTouchedWindowHandle =
+                findTouchedWindowAtLocked(displayId, x, y, isDown ,
+                                          true );
+        std::vector<TouchedMonitor> newGestureMonitors = isDown
+                ? findTouchedGestureMonitorsLocked(displayId, mTempTouchState.portalWindows)
+                : std::vector<TouchedMonitor>{};
+        if (newTouchedWindowHandle != nullptr &&
+            newTouchedWindowHandle->getInfo()->supportsSplitTouch()) {
+            isSplit = !isFromMouse;
+        } else if (isSplit) {
+            newTouchedWindowHandle = nullptr;
+        }
+        if (newTouchedWindowHandle == nullptr) {
+            newTouchedWindowHandle = mTempTouchState.getFirstForegroundWindowHandle();
+        }
+        if (newTouchedWindowHandle == nullptr && newGestureMonitors.empty()) {
+            ALOGI("Dropping event because there is no touchable window or gesture monitor at "
+                  "(%d, %d) in display %" PRId32 ".",
+                  x, y, displayId);
+            injectionResult = INPUT_EVENT_INJECTION_FAILED;
+            goto Failed;
+        }
+        if (newTouchedWindowHandle != nullptr) {
+            int32_t targetFlags = InputTarget::FLAG_FOREGROUND | InputTarget::FLAG_DISPATCH_AS_IS;
+            if (isSplit) {
+                targetFlags |= InputTarget::FLAG_SPLIT;
+            }
+            if (isWindowObscuredAtPointLocked(newTouchedWindowHandle, x, y)) {
+                targetFlags |= InputTarget::FLAG_WINDOW_IS_OBSCURED;
+            } else if (isWindowObscuredLocked(newTouchedWindowHandle)) {
+                targetFlags |= InputTarget::FLAG_WINDOW_IS_PARTIALLY_OBSCURED;
+            }
+            if (isHoverAction) {
+                newHoverWindowHandle = newTouchedWindowHandle;
+            } else if (maskedAction == AMOTION_EVENT_ACTION_SCROLL) {
+                newHoverWindowHandle = mLastHoverWindowHandle;
+            }
+            BitSet32 pointerIds;
+            if (isSplit) {
+                uint32_t pointerId = entry.pointerProperties[pointerIndex].id;
+                pointerIds.markBit(pointerId);
+            }
+            mTempTouchState.addOrUpdateWindow(newTouchedWindowHandle, targetFlags, pointerIds);
+        }
+        mTempTouchState.addGestureMonitors(newGestureMonitors);
+    } else {
+        if (!mTempTouchState.down) {
+            if (DEBUG_FOCUS) {
+                ALOGD("Dropping event because the pointer is not down or we previously "
+                      "dropped the pointer down event in display %" PRId32,
+                      displayId);
+            }
+            injectionResult = INPUT_EVENT_INJECTION_FAILED;
+            goto Failed;
+        }
+        if (maskedAction == AMOTION_EVENT_ACTION_MOVE && entry.pointerCount == 1 &&
+            mTempTouchState.isSlippery()) {
+            int32_t x = int32_t(entry.pointerCoords[0].getAxisValue(AMOTION_EVENT_AXIS_X));
+            int32_t y = int32_t(entry.pointerCoords[0].getAxisValue(AMOTION_EVENT_AXIS_Y));
+            sp<InputWindowHandle> oldTouchedWindowHandle =
+                    mTempTouchState.getFirstForegroundWindowHandle();
+            sp<InputWindowHandle> newTouchedWindowHandle =
+                    findTouchedWindowAtLocked(displayId, x, y);
+            if (oldTouchedWindowHandle != newTouchedWindowHandle &&
+                oldTouchedWindowHandle != nullptr && newTouchedWindowHandle != nullptr) {
+                if (DEBUG_FOCUS) {
+                    ALOGD("Touch is slipping out of window %s into window %s in display %" PRId32,
+                          oldTouchedWindowHandle->getName().c_str(),
+                          newTouchedWindowHandle->getName().c_str(), displayId);
+                }
+                mTempTouchState.addOrUpdateWindow(oldTouchedWindowHandle,
+                                                  InputTarget::FLAG_DISPATCH_AS_SLIPPERY_EXIT,
+                                                  BitSet32(0));
+                if (newTouchedWindowHandle->getInfo()->supportsSplitTouch()) {
+                    isSplit = true;
+                }
+                int32_t targetFlags =
+                        InputTarget::FLAG_FOREGROUND | InputTarget::FLAG_DISPATCH_AS_SLIPPERY_ENTER;
+                if (isSplit) {
+                    targetFlags |= InputTarget::FLAG_SPLIT;
+                }
+                if (isWindowObscuredAtPointLocked(newTouchedWindowHandle, x, y)) {
+                    targetFlags |= InputTarget::FLAG_WINDOW_IS_OBSCURED;
+                }
+                BitSet32 pointerIds;
+                if (isSplit) {
+                    pointerIds.markBit(entry.pointerProperties[0].id);
+                }
+                mTempTouchState.addOrUpdateWindow(newTouchedWindowHandle, targetFlags, pointerIds);
+            }
+        }
+    }
+    if (newHoverWindowHandle != mLastHoverWindowHandle) {
+        if (mLastHoverWindowHandle != nullptr) {
+#if DEBUG_HOVER
+            ALOGD("Sending hover exit event to window %s.",
+                  mLastHoverWindowHandle->getName().c_str());
+#endif
+            mTempTouchState.addOrUpdateWindow(mLastHoverWindowHandle,
+                                              InputTarget::FLAG_DISPATCH_AS_HOVER_EXIT,
+                                              BitSet32(0));
+        }
+        if (newHoverWindowHandle != nullptr) {
+#if DEBUG_HOVER
+            ALOGD("Sending hover enter event to window %s.",
+                  newHoverWindowHandle->getName().c_str());
+#endif
+            mTempTouchState.addOrUpdateWindow(newHoverWindowHandle,
+                                              InputTarget::FLAG_DISPATCH_AS_HOVER_ENTER,
+                                              BitSet32(0));
+        }
+    }
+    {
+        bool haveForegroundWindow = false;
+        for (const TouchedWindow& touchedWindow : mTempTouchState.windows) {
+            if (touchedWindow.targetFlags & InputTarget::FLAG_FOREGROUND) {
+                haveForegroundWindow = true;
+                if (!checkInjectionPermission(touchedWindow.windowHandle, entry.injectionState)) {
+                    injectionResult = INPUT_EVENT_INJECTION_PERMISSION_DENIED;
+                    injectionPermission = INJECTION_PERMISSION_DENIED;
+                    goto Failed;
+                }
+            }
+        }
+        bool hasGestureMonitor = !mTempTouchState.gestureMonitors.empty();
+        if (!haveForegroundWindow && !hasGestureMonitor) {
+            if (DEBUG_FOCUS) {
+                ALOGD("Dropping event because there is no touched foreground window in display "
+                      "%" PRId32 " or gesture monitor to receive it.",
+                      displayId);
+            }
+            injectionResult = INPUT_EVENT_INJECTION_FAILED;
+            goto Failed;
+        }
+        injectionPermission = INJECTION_PERMISSION_GRANTED;
+    }
+    if (maskedAction == AMOTION_EVENT_ACTION_DOWN) {
+        sp<InputWindowHandle> foregroundWindowHandle =
+                mTempTouchState.getFirstForegroundWindowHandle();
+        if (foregroundWindowHandle) {
+            const int32_t foregroundWindowUid = foregroundWindowHandle->getInfo()->ownerUid;
+            for (const TouchedWindow& touchedWindow : mTempTouchState.windows) {
+                if (touchedWindow.targetFlags & InputTarget::FLAG_DISPATCH_AS_OUTSIDE) {
+                    sp<InputWindowHandle> inputWindowHandle = touchedWindow.windowHandle;
+                    if (inputWindowHandle->getInfo()->ownerUid != foregroundWindowUid) {
+                        mTempTouchState.addOrUpdateWindow(inputWindowHandle,
+                                                          InputTarget::FLAG_ZERO_COORDS,
+                                                          BitSet32(0));
+                    }
+                }
+            }
+        }
+    }
+    for (const TouchedWindow& touchedWindow : mTempTouchState.windows) {
+        if (touchedWindow.targetFlags & InputTarget::FLAG_FOREGROUND) {
+            std::string reason =
+                    checkWindowReadyForMoreInputLocked(currentTime, touchedWindow.windowHandle,
+                                                       entry, "touched");
+            if (!reason.empty()) {
+                injectionResult = handleTargetsNotReadyLocked(currentTime, entry, nullptr,
+                                                              touchedWindow.windowHandle,
+                                                              nextWakeupTime, reason.c_str());
+                goto Unresponsive;
+            }
+        }
+    }
+    if (maskedAction == AMOTION_EVENT_ACTION_DOWN) {
+        sp<InputWindowHandle> foregroundWindowHandle =
+                mTempTouchState.getFirstForegroundWindowHandle();
+        if (foregroundWindowHandle && foregroundWindowHandle->getInfo()->hasWallpaper) {
+            const std::vector<sp<InputWindowHandle>> windowHandles =
+                    getWindowHandlesLocked(displayId);
+            for (const sp<InputWindowHandle>& windowHandle : windowHandles) {
+                const InputWindowInfo* info = windowHandle->getInfo();
+                if (info->displayId == displayId &&
+                    windowHandle->getInfo()->layoutParamsType == InputWindowInfo::TYPE_WALLPAPER) {
+                    mTempTouchState
+                            .addOrUpdateWindow(windowHandle,
+                                               InputTarget::FLAG_WINDOW_IS_OBSCURED |
+                                                       InputTarget::
+                                                               FLAG_WINDOW_IS_PARTIALLY_OBSCURED |
+                                                       InputTarget::FLAG_DISPATCH_AS_IS,
+                                               BitSet32(0));
+                }
+            }
+        }
+    }
+    injectionResult = INPUT_EVENT_INJECTION_SUCCEEDED;
+    for (const TouchedWindow& touchedWindow : mTempTouchState.windows) {
+        addWindowTargetLocked(touchedWindow.windowHandle, touchedWindow.targetFlags,
+                              touchedWindow.pointerIds, inputTargets);
+    }
+    for (const TouchedMonitor& touchedMonitor : mTempTouchState.gestureMonitors) {
+        addMonitoringTargetLocked(touchedMonitor.monitor, touchedMonitor.xOffset,
+                                  touchedMonitor.yOffset, inputTargets);
+    }
+    mTempTouchState.filterNonAsIsTouchWindows();
+Failed:
+    if (injectionPermission == INJECTION_PERMISSION_UNKNOWN) {
+        if (checkInjectionPermission(nullptr, entry.injectionState)) {
+            injectionPermission = INJECTION_PERMISSION_GRANTED;
+        } else {
+            injectionPermission = INJECTION_PERMISSION_DENIED;
+        }
+    }
+    if (injectionPermission == INJECTION_PERMISSION_GRANTED) {
+        if (!wrongDevice) {
+            if (switchedDevice) {
+                if (DEBUG_FOCUS) {
+                    ALOGD("Conflicting pointer actions: Switched to a different device.");
+                }
+                *outConflictingPointerActions = true;
+            }
+            if (isHoverAction) {
+                if (oldState && oldState->down) {
+                    if (DEBUG_FOCUS) {
+                        ALOGD("Conflicting pointer actions: Hover received while pointer was "
+                              "down.");
+                    }
+                    *outConflictingPointerActions = true;
+                }
+                mTempTouchState.reset();
+                if (maskedAction == AMOTION_EVENT_ACTION_HOVER_ENTER ||
+                    maskedAction == AMOTION_EVENT_ACTION_HOVER_MOVE) {
+                    mTempTouchState.deviceId = entry.deviceId;
+                    mTempTouchState.source = entry.source;
+                    mTempTouchState.displayId = displayId;
+                }
+            } else if (maskedAction == AMOTION_EVENT_ACTION_UP ||
+                       maskedAction == AMOTION_EVENT_ACTION_CANCEL) {
+                mTempTouchState.reset();
+            } else if (maskedAction == AMOTION_EVENT_ACTION_DOWN) {
+                if (oldState && oldState->down) {
+                    if (DEBUG_FOCUS) {
+                        ALOGD("Conflicting pointer actions: Down received while already down.");
+                    }
+                    *outConflictingPointerActions = true;
+                }
+            } else if (maskedAction == AMOTION_EVENT_ACTION_POINTER_UP) {
+                if (isSplit) {
+                    int32_t pointerIndex = getMotionEventActionPointerIndex(action);
+                    uint32_t pointerId = entry.pointerProperties[pointerIndex].id;
+                    for (size_t i = 0; i < mTempTouchState.windows.size();) {
+                        TouchedWindow& touchedWindow = mTempTouchState.windows[i];
+                        if (touchedWindow.targetFlags & InputTarget::FLAG_SPLIT) {
+                            touchedWindow.pointerIds.clearBit(pointerId);
+                            if (touchedWindow.pointerIds.isEmpty()) {
+                                mTempTouchState.windows.erase(mTempTouchState.windows.begin() + i);
+                                continue;
+                            }
+                        }
+                        i += 1;
+                    }
+                }
+            }
+            if (maskedAction != AMOTION_EVENT_ACTION_SCROLL) {
+                if (mTempTouchState.displayId >= 0) {
+                    if (oldStateIndex >= 0) {
+                        mTouchStatesByDisplay.editValueAt(oldStateIndex).copyFrom(mTempTouchState);
+                    } else {
+                        mTouchStatesByDisplay.add(displayId, mTempTouchState);
+                    }
+                } else if (oldStateIndex >= 0) {
+                    mTouchStatesByDisplay.removeItemsAt(oldStateIndex);
+                }
+            }
+            mLastHoverWindowHandle = newHoverWindowHandle;
+        }
+    } else {
+        if (DEBUG_FOCUS) {
+            ALOGD("Not updating touch focus because injection was denied.");
+        }
+    }
+Unresponsive:
+    mTempTouchState.reset();
+    nsecs_t timeSpentWaitingForApplication = getTimeSpentWaitingForApplicationLocked(currentTime);
+    updateDispatchStatistics(currentTime, entry, injectionResult, timeSpentWaitingForApplication);
+    if (DEBUG_FOCUS) {
+        ALOGD("findTouchedWindow finished: injectionResult=%d, injectionPermission=%d, "
+              "timeSpentWaitingForApplication=%0.1fms",
+              injectionResult, injectionPermission, timeSpentWaitingForApplication / 1000000.0);
+    }
+    return injectionResult;
+}
+void InputDispatcher::addWindowTargetLocked(const sp<InputWindowHandle>& windowHandle,
+                                            int32_t targetFlags, BitSet32 pointerIds,
+                                            std::vector<InputTarget>& inputTargets) {
+    std::vector<InputTarget>::iterator it =
+            std::find_if(inputTargets.begin(), inputTargets.end(),
+                         [&windowHandle](const InputTarget& inputTarget) {
+                             return inputTarget.inputChannel->getConnectionToken() ==
+                                     windowHandle->getToken();
+                         });
+    const InputWindowInfo* windowInfo = windowHandle->getInfo();
+    if (it == inputTargets.end()) {
+        InputTarget inputTarget;
+        sp<InputChannel> inputChannel = getInputChannelLocked(windowHandle->getToken());
+        if (inputChannel == nullptr) {
+            ALOGW("Window %s already unregistered input channel", windowHandle->getName().c_str());
+            return;
+        }
+        inputTarget.inputChannel = inputChannel;
+        inputTarget.flags = targetFlags;
+        inputTarget.globalScaleFactor = windowInfo->globalScaleFactor;
+        inputTargets.push_back(inputTarget);
+        it = inputTargets.end() - 1;
+    }
+    ALOG_ASSERT(it->flags == targetFlags);
+    ALOG_ASSERT(it->globalScaleFactor == windowInfo->globalScaleFactor);
+    it->addPointers(pointerIds, -windowInfo->frameLeft, -windowInfo->frameTop,
+                    windowInfo->windowXScale, windowInfo->windowYScale);
+}
+void InputDispatcher::addGlobalMonitoringTargetsLocked(std::vector<InputTarget>& inputTargets,
+                                                       int32_t displayId, float xOffset,
+                                                       float yOffset) {
+    std::unordered_map<int32_t, std::vector<Monitor>>::const_iterator it =
+            mGlobalMonitorsByDisplay.find(displayId);
+    if (it != mGlobalMonitorsByDisplay.end()) {
+        const std::vector<Monitor>& monitors = it->second;
+        for (const Monitor& monitor : monitors) {
+            addMonitoringTargetLocked(monitor, xOffset, yOffset, inputTargets);
+        }
+    }
+}
+void InputDispatcher::addMonitoringTargetLocked(const Monitor& monitor, float xOffset,
+                                                float yOffset,
+                                                std::vector<InputTarget>& inputTargets) {
+    InputTarget target;
+    target.inputChannel = monitor.inputChannel;
+    target.flags = InputTarget::FLAG_DISPATCH_AS_IS;
+    target.setDefaultPointerInfo(xOffset, yOffset, 1 , 1 );
+    inputTargets.push_back(target);
+}
+bool InputDispatcher::checkInjectionPermission(const sp<InputWindowHandle>& windowHandle,
+                                               const InjectionState* injectionState) {
+    if (injectionState &&
+        (windowHandle == nullptr ||
+         windowHandle->getInfo()->ownerUid != injectionState->injectorUid) &&
+        !hasInjectionPermission(injectionState->injectorPid, injectionState->injectorUid)) {
+        if (windowHandle != nullptr) {
+            ALOGW("Permission denied: injecting event from pid %d uid %d to window %s "
+                  "owned by uid %d",
+                  injectionState->injectorPid, injectionState->injectorUid,
+                  windowHandle->getName().c_str(), windowHandle->getInfo()->ownerUid);
+        } else {
+            ALOGW("Permission denied: injecting event from pid %d uid %d",
+                  injectionState->injectorPid, injectionState->injectorUid);
+        }
+        return false;
+    }
+    return true;
+}
+bool InputDispatcher::isWindowObscuredAtPointLocked(const sp<InputWindowHandle>& windowHandle,
+                                                    int32_t x, int32_t y) const {
+    int32_t displayId = windowHandle->getInfo()->displayId;
+    const std::vector<sp<InputWindowHandle>> windowHandles = getWindowHandlesLocked(displayId);
+    for (const sp<InputWindowHandle>& otherHandle : windowHandles) {
+        if (otherHandle == windowHandle) {
+            break;
+        }
+        const InputWindowInfo* otherInfo = otherHandle->getInfo();
+        if (otherInfo->displayId == displayId && otherInfo->visible &&
+            !otherInfo->isTrustedOverlay() && otherInfo->frameContainsPoint(x, y)) {
+            return true;
+        }
+    }
+    return false;
+}
+bool InputDispatcher::isWindowObscuredLocked(const sp<InputWindowHandle>& windowHandle) const {
+    int32_t displayId = windowHandle->getInfo()->displayId;
+    const std::vector<sp<InputWindowHandle>> windowHandles = getWindowHandlesLocked(displayId);
+    const InputWindowInfo* windowInfo = windowHandle->getInfo();
+    for (const sp<InputWindowHandle>& otherHandle : windowHandles) {
+        if (otherHandle == windowHandle) {
+            break;
+        }
+        const InputWindowInfo* otherInfo = otherHandle->getInfo();
+        if (otherInfo->displayId == displayId && otherInfo->visible &&
+            !otherInfo->isTrustedOverlay() && otherInfo->overlaps(windowInfo)) {
+            return true;
+        }
+    }
+    return false;
+}
+std::string InputDispatcher::checkWindowReadyForMoreInputLocked(
+        nsecs_t currentTime, const sp<InputWindowHandle>& windowHandle,
+        const EventEntry& eventEntry, const char* targetType) {
+    if (windowHandle->getInfo()->paused) {
+        return StringPrintf("Waiting because the %s window is paused.", targetType);
+    }
+    sp<Connection> connection = getConnectionLocked(windowHandle->getToken());
+    if (connection == nullptr) {
+        return StringPrintf("Waiting because the %s window's input channel is not "
+                            "registered with the input dispatcher.  The window may be in the "
+                            "process of being removed.",
+                            targetType);
+    }
+    if (connection->status != Connection::STATUS_NORMAL) {
+        return StringPrintf("Waiting because the %s window's input connection is %s."
+                            "The window may be in the process of being removed.",
+                            targetType, connection->getStatusLabel());
+    }
+    if (connection->inputPublisherBlocked) {
+        return StringPrintf("Waiting because the %s window's input channel is full.  "
+                            "Outbound queue length: %zu.  Wait queue length: %zu.",
+                            targetType, connection->outboundQueue.size(),
+                            connection->waitQueue.size());
+    }
+    if (eventEntry.type == EventEntry::Type::KEY) {
+        if (!connection->outboundQueue.empty() || !connection->waitQueue.empty()) {
+            return StringPrintf("Waiting to send key event because the %s window has not "
+                                "finished processing all of the input events that were previously "
+                                "delivered to it.  Outbound queue length: %zu.  Wait queue length: "
+                                "%zu.",
+                                targetType, connection->outboundQueue.size(),
+                                connection->waitQueue.size());
+        }
+    } else {
+        if (!connection->waitQueue.empty() &&
+            currentTime >=
+                    connection->waitQueue.front()->deliveryTime + STREAM_AHEAD_EVENT_TIMEOUT) {
+            return StringPrintf("Waiting to send non-key event because the %s window has not "
+                                "finished processing certain input events that were delivered to "
+                                "it over "
+                                "%0.1fms ago.  Wait queue length: %zu.  Wait queue head age: "
+                                "%0.1fms.",
+                                targetType, STREAM_AHEAD_EVENT_TIMEOUT * 0.000001f,
+                                connection->waitQueue.size(),
+                                (currentTime - connection->waitQueue.front()->deliveryTime) *
+                                        0.000001f);
+        }
+    }
+    return "";
+}
+std::string InputDispatcher::getApplicationWindowLabel(
+        const sp<InputApplicationHandle>& applicationHandle,
+        const sp<InputWindowHandle>& windowHandle) {
+    if (applicationHandle != nullptr) {
+        if (windowHandle != nullptr) {
+            std::string label(applicationHandle->getName());
+            label += " - ";
+            label += windowHandle->getName();
+            return label;
+        } else {
+            return applicationHandle->getName();
+        }
+    } else if (windowHandle != nullptr) {
+        return windowHandle->getName();
+    } else {
+        return "<unknown application or window>";
+    }
+}
+void InputDispatcher::pokeUserActivityLocked(const EventEntry& eventEntry) {
+    if (eventEntry.type == EventEntry::Type::FOCUS) {
+        return;
+    }
+    int32_t displayId = getTargetDisplayId(eventEntry);
+    sp<InputWindowHandle> focusedWindowHandle =
+            getValueByKey(mFocusedWindowHandlesByDisplay, displayId);
+    if (focusedWindowHandle != nullptr) {
+        const InputWindowInfo* info = focusedWindowHandle->getInfo();
+        if (info->inputFeatures & InputWindowInfo::INPUT_FEATURE_DISABLE_USER_ACTIVITY) {
+#if DEBUG_DISPATCH_CYCLE
+            ALOGD("Not poking user activity: disabled by window '%s'.", info->name.c_str());
+#endif
+            return;
+        }
+    }
+    int32_t eventType = USER_ACTIVITY_EVENT_OTHER;
+    switch (eventEntry.type) {
+        case EventEntry::Type::MOTION: {
+            const MotionEntry& motionEntry = static_cast<const MotionEntry&>(eventEntry);
+            if (motionEntry.action == AMOTION_EVENT_ACTION_CANCEL) {
+                return;
+            }
+            if (MotionEvent::isTouchEvent(motionEntry.source, motionEntry.action)) {
+                eventType = USER_ACTIVITY_EVENT_TOUCH;
+            }
+            break;
+        }
+        case EventEntry::Type::KEY: {
+            const KeyEntry& keyEntry = static_cast<const KeyEntry&>(eventEntry);
+            if (keyEntry.flags & AKEY_EVENT_FLAG_CANCELED) {
+                return;
+            }
+            eventType = USER_ACTIVITY_EVENT_BUTTON;
+            break;
+        }
+        case EventEntry::Type::FOCUS:
+        case EventEntry::Type::CONFIGURATION_CHANGED:
+        case EventEntry::Type::DEVICE_RESET: {
+            LOG_ALWAYS_FATAL("%s events are not user activity",
+                             EventEntry::typeToString(eventEntry.type));
+            break;
+        }
+    }
+    std::unique_ptr<CommandEntry> commandEntry =
+            std::make_unique<CommandEntry>(&InputDispatcher::doPokeUserActivityLockedInterruptible);
+    commandEntry->eventTime = eventEntry.eventTime;
+    commandEntry->userActivityEventType = eventType;
+    postCommandLocked(std::move(commandEntry));
+}
+void InputDispatcher::prepareDispatchCycleLocked(nsecs_t currentTime,
+                                                 const sp<Connection>& connection,
+                                                 EventEntry* eventEntry,
+                                                 const InputTarget& inputTarget) {
+    if (ATRACE_ENABLED()) {
+        std::string message =
+                StringPrintf("prepareDispatchCycleLocked(inputChannel=%s, id=0x%" PRIx32 ")",
+                             connection->getInputChannelName().c_str(), eventEntry->id);
+        ATRACE_NAME(message.c_str());
+    }
+#if DEBUG_DISPATCH_CYCLE
+    ALOGD("channel '%s' ~ prepareDispatchCycle - flags=0x%08x, "
+          "globalScaleFactor=%f, pointerIds=0x%x %s",
+          connection->getInputChannelName().c_str(), inputTarget.flags,
+          inputTarget.globalScaleFactor, inputTarget.pointerIds.value,
+          inputTarget.getPointerInfoString().c_str());
+#endif
+    if (connection->status != Connection::STATUS_NORMAL) {
+#if DEBUG_DISPATCH_CYCLE
+        ALOGD("channel '%s' ~ Dropping event because the channel status is %s",
+              connection->getInputChannelName().c_str(), connection->getStatusLabel());
+#endif
+        return;
+    }
+    if (inputTarget.flags & InputTarget::FLAG_SPLIT) {
+        LOG_ALWAYS_FATAL_IF(eventEntry->type != EventEntry::Type::MOTION,
+                            "Entry type %s should not have FLAG_SPLIT",
+                            EventEntry::typeToString(eventEntry->type));
+        const MotionEntry& originalMotionEntry = static_cast<const MotionEntry&>(*eventEntry);
+        if (inputTarget.pointerIds.count() != originalMotionEntry.pointerCount) {
+            MotionEntry* splitMotionEntry =
+                    splitMotionEvent(originalMotionEntry, inputTarget.pointerIds);
+            if (!splitMotionEntry) {
+                return;
+            }
+            if (DEBUG_FOCUS) {
+                ALOGD("channel '%s' ~ Split motion event.",
+                      connection->getInputChannelName().c_str());
+                logOutboundMotionDetails("  ", *splitMotionEntry);
+            }
+            enqueueDispatchEntriesLocked(currentTime, connection, splitMotionEntry, inputTarget);
+            splitMotionEntry->release();
+            return;
+        }
+    }
+    enqueueDispatchEntriesLocked(currentTime, connection, eventEntry, inputTarget);
+}
+void InputDispatcher::enqueueDispatchEntriesLocked(nsecs_t currentTime,
+                                                   const sp<Connection>& connection,
+                                                   EventEntry* eventEntry,
+                                                   const InputTarget& inputTarget) {
+    if (ATRACE_ENABLED()) {
+        std::string message =
+                StringPrintf("enqueueDispatchEntriesLocked(inputChannel=%s, id=0x%" PRIx32 ")",
+                             connection->getInputChannelName().c_str(), eventEntry->id);
+        ATRACE_NAME(message.c_str());
+    }
+    bool wasEmpty = connection->outboundQueue.empty();
+    enqueueDispatchEntryLocked(connection, eventEntry, inputTarget,
+                               InputTarget::FLAG_DISPATCH_AS_HOVER_EXIT);
+    enqueueDispatchEntryLocked(connection, eventEntry, inputTarget,
+                               InputTarget::FLAG_DISPATCH_AS_OUTSIDE);
+    enqueueDispatchEntryLocked(connection, eventEntry, inputTarget,
+                               InputTarget::FLAG_DISPATCH_AS_HOVER_ENTER);
+    enqueueDispatchEntryLocked(connection, eventEntry, inputTarget,
+                               InputTarget::FLAG_DISPATCH_AS_IS);
+    enqueueDispatchEntryLocked(connection, eventEntry, inputTarget,
+                               InputTarget::FLAG_DISPATCH_AS_SLIPPERY_EXIT);
+    enqueueDispatchEntryLocked(connection, eventEntry, inputTarget,
+                               InputTarget::FLAG_DISPATCH_AS_SLIPPERY_ENTER);
+    if (wasEmpty && !connection->outboundQueue.empty()) {
+        startDispatchCycleLocked(currentTime, connection);
+    }
+}
+void InputDispatcher::enqueueDispatchEntryLocked(const sp<Connection>& connection,
+                                                 EventEntry* eventEntry,
+                                                 const InputTarget& inputTarget,
+                                                 int32_t dispatchMode) {
+    if (ATRACE_ENABLED()) {
+        std::string message = StringPrintf("enqueueDispatchEntry(inputChannel=%s, dispatchMode=%s)",
+                                           connection->getInputChannelName().c_str(),
+                                           dispatchModeToString(dispatchMode).c_str());
+        ATRACE_NAME(message.c_str());
+    }
+    int32_t inputTargetFlags = inputTarget.flags;
+    if (!(inputTargetFlags & dispatchMode)) {
+        return;
+    }
+    inputTargetFlags = (inputTargetFlags & ~InputTarget::FLAG_DISPATCH_MASK) | dispatchMode;
+    std::unique_ptr<DispatchEntry> dispatchEntry =
+            createDispatchEntry(inputTarget, eventEntry, inputTargetFlags);
+    EventEntry* newEntry = dispatchEntry->eventEntry;
+    switch (newEntry->type) {
+        case EventEntry::Type::KEY: {
+            const KeyEntry& keyEntry = static_cast<const KeyEntry&>(*newEntry);
+            dispatchEntry->resolvedEventId = keyEntry.id;
+            dispatchEntry->resolvedAction = keyEntry.action;
+            dispatchEntry->resolvedFlags = keyEntry.flags;
+            if (!connection->inputState.trackKey(keyEntry, dispatchEntry->resolvedAction,
+                                                 dispatchEntry->resolvedFlags)) {
+#if DEBUG_DISPATCH_CYCLE
+                ALOGD("channel '%s' ~ enqueueDispatchEntryLocked: skipping inconsistent key event",
+                      connection->getInputChannelName().c_str());
+#endif
+                return;
+            }
+            break;
+        }
+        case EventEntry::Type::MOTION: {
+            const MotionEntry& motionEntry = static_cast<const MotionEntry&>(*newEntry);
+            constexpr int32_t DEFAULT_RESOLVED_EVENT_ID =
+                    static_cast<int32_t>(IdGenerator::Source::OTHER);
+            dispatchEntry->resolvedEventId = DEFAULT_RESOLVED_EVENT_ID;
+            if (dispatchMode & InputTarget::FLAG_DISPATCH_AS_OUTSIDE) {
+                dispatchEntry->resolvedAction = AMOTION_EVENT_ACTION_OUTSIDE;
+            } else if (dispatchMode & InputTarget::FLAG_DISPATCH_AS_HOVER_EXIT) {
+                dispatchEntry->resolvedAction = AMOTION_EVENT_ACTION_HOVER_EXIT;
+            } else if (dispatchMode & InputTarget::FLAG_DISPATCH_AS_HOVER_ENTER) {
+                dispatchEntry->resolvedAction = AMOTION_EVENT_ACTION_HOVER_ENTER;
+            } else if (dispatchMode & InputTarget::FLAG_DISPATCH_AS_SLIPPERY_EXIT) {
+                dispatchEntry->resolvedAction = AMOTION_EVENT_ACTION_CANCEL;
+            } else if (dispatchMode & InputTarget::FLAG_DISPATCH_AS_SLIPPERY_ENTER) {
+                dispatchEntry->resolvedAction = AMOTION_EVENT_ACTION_DOWN;
+            } else {
+                dispatchEntry->resolvedAction = motionEntry.action;
+                dispatchEntry->resolvedEventId = motionEntry.id;
+            }
+            if (dispatchEntry->resolvedAction == AMOTION_EVENT_ACTION_HOVER_MOVE &&
+                !connection->inputState.isHovering(motionEntry.deviceId, motionEntry.source,
+                                                   motionEntry.displayId)) {
+#if DEBUG_DISPATCH_CYCLE
+                ALOGD("channel '%s' ~ enqueueDispatchEntryLocked: filling in missing hover enter "
+                      "event",
+                      connection->getInputChannelName().c_str());
+#endif
+                dispatchEntry->resolvedAction = AMOTION_EVENT_ACTION_HOVER_ENTER;
+            }
+            dispatchEntry->resolvedFlags = motionEntry.flags;
+            if (dispatchEntry->targetFlags & InputTarget::FLAG_WINDOW_IS_OBSCURED) {
+                dispatchEntry->resolvedFlags |= AMOTION_EVENT_FLAG_WINDOW_IS_OBSCURED;
+            }
+            if (dispatchEntry->targetFlags & InputTarget::FLAG_WINDOW_IS_PARTIALLY_OBSCURED) {
+                dispatchEntry->resolvedFlags |= AMOTION_EVENT_FLAG_WINDOW_IS_PARTIALLY_OBSCURED;
+            }
+            if (!connection->inputState.trackMotion(motionEntry, dispatchEntry->resolvedAction,
+                                                    dispatchEntry->resolvedFlags)) {
+#if DEBUG_DISPATCH_CYCLE
+                ALOGD("channel '%s' ~ enqueueDispatchEntryLocked: skipping inconsistent motion "
+                      "event",
+                      connection->getInputChannelName().c_str());
+#endif
+                return;
+            }
+            dispatchEntry->resolvedEventId =
+                    dispatchEntry->resolvedEventId == DEFAULT_RESOLVED_EVENT_ID
+                    ? mIdGenerator.nextId()
+                    : motionEntry.id;
+            if (ATRACE_ENABLED() && dispatchEntry->resolvedEventId != motionEntry.id) {
+                std::string message = StringPrintf("Transmute MotionEvent(id=0x%" PRIx32
+                                                   ") to MotionEvent(id=0x%" PRIx32 ").",
+                                                   motionEntry.id, dispatchEntry->resolvedEventId);
+                ATRACE_NAME(message.c_str());
+            }
+            dispatchPointerDownOutsideFocus(motionEntry.source, dispatchEntry->resolvedAction,
+                                            inputTarget.inputChannel->getConnectionToken());
+            break;
+        }
+        case EventEntry::Type::FOCUS: {
+            break;
+        }
+        case EventEntry::Type::CONFIGURATION_CHANGED:
+        case EventEntry::Type::DEVICE_RESET: {
+            LOG_ALWAYS_FATAL("%s events should not go to apps",
+                             EventEntry::typeToString(newEntry->type));
+            break;
+        }
+    }
+    if (dispatchEntry->hasForegroundTarget()) {
+        incrementPendingForegroundDispatches(newEntry);
+    }
+    connection->outboundQueue.push_back(dispatchEntry.release());
+    traceOutboundQueueLength(connection);
+}
+void InputDispatcher::dispatchPointerDownOutsideFocus(uint32_t source, int32_t action,
+                                                      const sp<IBinder>& newToken) {
+    int32_t maskedAction = action & AMOTION_EVENT_ACTION_MASK;
+    uint32_t maskedSource = source & AINPUT_SOURCE_CLASS_MASK;
+    if (maskedSource != AINPUT_SOURCE_CLASS_POINTER || maskedAction != AMOTION_EVENT_ACTION_DOWN) {
+        return;
+    }
+    sp<InputWindowHandle> inputWindowHandle = getWindowHandleLocked(newToken);
+    if (inputWindowHandle == nullptr) {
+        return;
+    }
+    sp<InputWindowHandle> focusedWindowHandle =
+            getValueByKey(mFocusedWindowHandlesByDisplay, mFocusedDisplayId);
+    bool hasFocusChanged = !focusedWindowHandle || focusedWindowHandle->getToken() != newToken;
+    if (!hasFocusChanged) {
+        return;
+    }
+    std::unique_ptr<CommandEntry> commandEntry = std::make_unique<CommandEntry>(
+            &InputDispatcher::doOnPointerDownOutsideFocusLockedInterruptible);
+    commandEntry->newToken = newToken;
+    postCommandLocked(std::move(commandEntry));
+}
+void InputDispatcher::startDispatchCycleLocked(nsecs_t currentTime,
+                                               const sp<Connection>& connection) {
+    if (ATRACE_ENABLED()) {
+        std::string message = StringPrintf("startDispatchCycleLocked(inputChannel=%s)",
+                                           connection->getInputChannelName().c_str());
+        ATRACE_NAME(message.c_str());
+    }
+#if DEBUG_DISPATCH_CYCLE
+    ALOGD("channel '%s' ~ startDispatchCycle", connection->getInputChannelName().c_str());
+#endif
+    while (connection->status == Connection::STATUS_NORMAL && !connection->outboundQueue.empty()) {
+        DispatchEntry* dispatchEntry = connection->outboundQueue.front();
+        dispatchEntry->deliveryTime = currentTime;
+        status_t status;
+        EventEntry* eventEntry = dispatchEntry->eventEntry;
+        switch (eventEntry->type) {
+            case EventEntry::Type::KEY: {
+                KeyEntry* keyEntry = static_cast<KeyEntry*>(eventEntry);
+                VerifiedKeyEvent verifiedEvent = verifiedKeyEventFromKeyEntry(*keyEntry);
+                verifiedEvent.flags = dispatchEntry->resolvedFlags & VERIFIED_KEY_EVENT_FLAGS;
+                verifiedEvent.action = dispatchEntry->resolvedAction;
+                std::array<uint8_t, 32> hmac = mHmacKeyManager.sign(verifiedEvent);
+                status =
+                        connection->inputPublisher
+                                .publishKeyEvent(dispatchEntry->seq, dispatchEntry->resolvedEventId,
+                                                 keyEntry->deviceId, keyEntry->source,
+                                                 keyEntry->displayId, std::move(hmac),
+                                                 dispatchEntry->resolvedAction,
+                                                 dispatchEntry->resolvedFlags, keyEntry->keyCode,
+                                                 keyEntry->scanCode, keyEntry->metaState,
+                                                 keyEntry->repeatCount, keyEntry->downTime,
+                                                 keyEntry->eventTime);
+                break;
+            }
+            case EventEntry::Type::MOTION: {
+                MotionEntry* motionEntry = static_cast<MotionEntry*>(eventEntry);
+                PointerCoords scaledCoords[MAX_POINTERS];
+                const PointerCoords* usingCoords = motionEntry->pointerCoords;
+                float xOffset = 0.0f, yOffset = 0.0f;
+                float xScale = 1.0f, yScale = 1.0f;
+                if ((motionEntry->source & AINPUT_SOURCE_CLASS_POINTER) &&
+                    !(dispatchEntry->targetFlags & InputTarget::FLAG_ZERO_COORDS)) {
+                    float globalScaleFactor = dispatchEntry->globalScaleFactor;
+                    xScale = dispatchEntry->windowXScale;
+                    yScale = dispatchEntry->windowYScale;
+                    xOffset = dispatchEntry->xOffset * xScale;
+                    yOffset = dispatchEntry->yOffset * yScale;
+                    if (globalScaleFactor != 1.0f) {
+                        for (uint32_t i = 0; i < motionEntry->pointerCount; i++) {
+                            scaledCoords[i] = motionEntry->pointerCoords[i];
+                            scaledCoords[i].scale(globalScaleFactor, 1 ,
+                                                  1 );
+                        }
+                        usingCoords = scaledCoords;
+                    }
+                } else {
+                    if (dispatchEntry->targetFlags & InputTarget::FLAG_ZERO_COORDS) {
+                        for (uint32_t i = 0; i < motionEntry->pointerCount; i++) {
+                            scaledCoords[i].clear();
+                        }
+                        usingCoords = scaledCoords;
+                    }
+                }
+                VerifiedMotionEvent verifiedEvent =
+                        verifiedMotionEventFromMotionEntry(*motionEntry);
+                verifiedEvent.actionMasked =
+                        dispatchEntry->resolvedAction & AMOTION_EVENT_ACTION_MASK;
+                verifiedEvent.flags = dispatchEntry->resolvedFlags & VERIFIED_MOTION_EVENT_FLAGS;
+                std::array<uint8_t, 32> hmac = mHmacKeyManager.sign(verifiedEvent);
+                status = connection->inputPublisher
+                                 .publishMotionEvent(dispatchEntry->seq,
+                                                     dispatchEntry->resolvedEventId,
+                                                     motionEntry->deviceId, motionEntry->source,
+                                                     motionEntry->displayId, std::move(hmac),
+                                                     dispatchEntry->resolvedAction,
+                                                     motionEntry->actionButton,
+                                                     dispatchEntry->resolvedFlags,
+                                                     motionEntry->edgeFlags, motionEntry->metaState,
+                                                     motionEntry->buttonState,
+                                                     motionEntry->classification, xScale, yScale,
+                                                     xOffset, yOffset, motionEntry->xPrecision,
+                                                     motionEntry->yPrecision,
+                                                     motionEntry->xCursorPosition,
+                                                     motionEntry->yCursorPosition,
+                                                     motionEntry->downTime, motionEntry->eventTime,
+                                                     motionEntry->pointerCount,
+                                                     motionEntry->pointerProperties, usingCoords);
+                reportTouchEventForStatistics(*motionEntry);
+                break;
+            }
+            case EventEntry::Type::FOCUS: {
+                FocusEntry* focusEntry = static_cast<FocusEntry*>(eventEntry);
+                status = connection->inputPublisher.publishFocusEvent(dispatchEntry->seq,
+                                                                      focusEntry->id,
+                                                                      focusEntry->hasFocus,
+                                                                      mInTouchMode);
+                break;
+            }
+            case EventEntry::Type::CONFIGURATION_CHANGED:
+            case EventEntry::Type::DEVICE_RESET: {
+                LOG_ALWAYS_FATAL("Should never start dispatch cycles for %s events",
+                                 EventEntry::typeToString(eventEntry->type));
+                return;
+            }
+        }
+        if (status) {
+            if (status == WOULD_BLOCK) {
+                if (connection->waitQueue.empty()) {
+                    ALOGE("channel '%s' ~ Could not publish event because the pipe is full. "
+                          "This is unexpected because the wait queue is empty, so the pipe "
+                          "should be empty and we shouldn't have any problems writing an "
+                          "event to it, status=%d",
+                          connection->getInputChannelName().c_str(), status);
+                    abortBrokenDispatchCycleLocked(currentTime, connection, true );
+                } else {
+#if DEBUG_DISPATCH_CYCLE
+                    ALOGD("channel '%s' ~ Could not publish event because the pipe is full, "
+                          "waiting for the application to catch up",
+                          connection->getInputChannelName().c_str());
+#endif
+                    connection->inputPublisherBlocked = true;
+                }
+            } else {
+                ALOGE("channel '%s' ~ Could not publish event due to an unexpected error, "
+                      "status=%d",
+                      connection->getInputChannelName().c_str(), status);
+                abortBrokenDispatchCycleLocked(currentTime, connection, true );
+            }
+            return;
+        }
+        connection->outboundQueue.erase(std::remove(connection->outboundQueue.begin(),
+                                                    connection->outboundQueue.end(),
+                                                    dispatchEntry));
+        traceOutboundQueueLength(connection);
+        connection->waitQueue.push_back(dispatchEntry);
+        traceWaitQueueLength(connection);
+    }
+}
+void InputDispatcher::finishDispatchCycleLocked(nsecs_t currentTime,
+                                                const sp<Connection>& connection, uint32_t seq,
+                                                bool handled) {
+#if DEBUG_DISPATCH_CYCLE
+    ALOGD("channel '%s' ~ finishDispatchCycle - seq=%u, handled=%s",
+          connection->getInputChannelName().c_str(), seq, toString(handled));
+#endif
+    connection->inputPublisherBlocked = false;
+    if (connection->status == Connection::STATUS_BROKEN ||
+        connection->status == Connection::STATUS_ZOMBIE) {
+        return;
+    }
+    onDispatchCycleFinishedLocked(currentTime, connection, seq, handled);
+}
+void InputDispatcher::abortBrokenDispatchCycleLocked(nsecs_t currentTime,
+                                                     const sp<Connection>& connection,
+                                                     bool notify) {
+#if DEBUG_DISPATCH_CYCLE
+    ALOGD("channel '%s' ~ abortBrokenDispatchCycle - notify=%s",
+          connection->getInputChannelName().c_str(), toString(notify));
+#endif
+    drainDispatchQueue(connection->outboundQueue);
+    traceOutboundQueueLength(connection);
+    drainDispatchQueue(connection->waitQueue);
+    traceWaitQueueLength(connection);
+    if (connection->status == Connection::STATUS_NORMAL) {
+        connection->status = Connection::STATUS_BROKEN;
+        if (notify) {
+            onDispatchCycleBrokenLocked(currentTime, connection);
+        }
+    }
+}
+void InputDispatcher::drainDispatchQueue(std::deque<DispatchEntry*>& queue) {
+    while (!queue.empty()) {
+        DispatchEntry* dispatchEntry = queue.front();
+        queue.pop_front();
+        releaseDispatchEntry(dispatchEntry);
+    }
+}
+void InputDispatcher::releaseDispatchEntry(DispatchEntry* dispatchEntry) {
+    if (dispatchEntry->hasForegroundTarget()) {
+        decrementPendingForegroundDispatches(dispatchEntry->eventEntry);
+    }
+    delete dispatchEntry;
+}
+int InputDispatcher::handleReceiveCallback(int fd, int events, void* data) {
+    InputDispatcher* d = static_cast<InputDispatcher*>(data);
+    {
+        std::scoped_lock _l(d->mLock);
+        if (d->mConnectionsByFd.find(fd) == d->mConnectionsByFd.end()) {
+            ALOGE("Received spurious receive callback for unknown input channel.  "
+                  "fd=%d, events=0x%x",
+                  fd, events);
+            return 0;
+        }
+        bool notify;
+        sp<Connection> connection = d->mConnectionsByFd[fd];
+        if (!(events & (ALOOPER_EVENT_ERROR | ALOOPER_EVENT_HANGUP))) {
+            if (!(events & ALOOPER_EVENT_INPUT)) {
+                ALOGW("channel '%s' ~ Received spurious callback for unhandled poll event.  "
+                      "events=0x%x",
+                      connection->getInputChannelName().c_str(), events);
+                return 1;
+            }
+            nsecs_t currentTime = now();
+            bool gotOne = false;
+            status_t status;
+            for (;;) {
+                uint32_t seq;
+                bool handled;
+                status = connection->inputPublisher.receiveFinishedSignal(&seq, &handled);
+                if (status) {
+                    break;
+                }
+                d->finishDispatchCycleLocked(currentTime, connection, seq, handled);
+                gotOne = true;
+            }
+            if (gotOne) {
+                d->runCommandsLockedInterruptible();
+                if (status == WOULD_BLOCK) {
+                    return 1;
+                }
+            }
+            notify = status != DEAD_OBJECT || !connection->monitor;
+            if (notify) {
+                ALOGE("channel '%s' ~ Failed to receive finished signal.  status=%d",
+                      connection->getInputChannelName().c_str(), status);
+            }
+        } else {
+            notify = !connection->monitor;
+            if (notify) {
+                ALOGW("channel '%s' ~ Consumer closed input channel or an error occurred.  "
+                      "events=0x%x",
+                      connection->getInputChannelName().c_str(), events);
+            }
+        }
+        d->unregisterInputChannelLocked(connection->inputChannel, notify);
+        return 0;
+    }
+}
+void InputDispatcher::synthesizeCancelationEventsForAllConnectionsLocked(
+        const CancelationOptions& options) {
+    for (const auto& pair : mConnectionsByFd) {
+        synthesizeCancelationEventsForConnectionLocked(pair.second, options);
+    }
+}
+void InputDispatcher::synthesizeCancelationEventsForMonitorsLocked(
+        const CancelationOptions& options) {
+    synthesizeCancelationEventsForMonitorsLocked(options, mGlobalMonitorsByDisplay);
+    synthesizeCancelationEventsForMonitorsLocked(options, mGestureMonitorsByDisplay);
+}
+void InputDispatcher::synthesizeCancelationEventsForMonitorsLocked(
+        const CancelationOptions& options,
+        std::unordered_map<int32_t, std::vector<Monitor>>& monitorsByDisplay) {
+    for (const auto& it : monitorsByDisplay) {
+        const std::vector<Monitor>& monitors = it.second;
+        for (const Monitor& monitor : monitors) {
+            synthesizeCancelationEventsForInputChannelLocked(monitor.inputChannel, options);
+        }
+    }
+}
+void InputDispatcher::synthesizeCancelationEventsForInputChannelLocked(
+        const sp<InputChannel>& channel, const CancelationOptions& options) {
+    sp<Connection> connection = getConnectionLocked(channel->getConnectionToken());
+    if (connection == nullptr) {
+        return;
+    }
+    synthesizeCancelationEventsForConnectionLocked(connection, options);
+}
+void InputDispatcher::synthesizeCancelationEventsForConnectionLocked(
+        const sp<Connection>& connection, const CancelationOptions& options) {
+    if (connection->status == Connection::STATUS_BROKEN) {
+        return;
+    }
+    nsecs_t currentTime = now();
+    std::vector<EventEntry*> cancelationEvents =
+            connection->inputState.synthesizeCancelationEvents(currentTime, options);
+    if (cancelationEvents.empty()) {
+        return;
+    }
+#if DEBUG_OUTBOUND_EVENT_DETAILS
+    ALOGD("channel '%s' ~ Synthesized %zu cancelation events to bring channel back in sync "
+          "with reality: %s, mode=%d.",
+          connection->getInputChannelName().c_str(), cancelationEvents.size(), options.reason,
+          options.mode);
+#endif
+    InputTarget target;
+    sp<InputWindowHandle> windowHandle =
+            getWindowHandleLocked(connection->inputChannel->getConnectionToken());
+    if (windowHandle != nullptr) {
+        const InputWindowInfo* windowInfo = windowHandle->getInfo();
+        target.setDefaultPointerInfo(-windowInfo->frameLeft, -windowInfo->frameTop,
+                                     windowInfo->windowXScale, windowInfo->windowYScale);
+        target.globalScaleFactor = windowInfo->globalScaleFactor;
+    }
+    target.inputChannel = connection->inputChannel;
+    target.flags = InputTarget::FLAG_DISPATCH_AS_IS;
+    for (size_t i = 0; i < cancelationEvents.size(); i++) {
+        EventEntry* cancelationEventEntry = cancelationEvents[i];
+        switch (cancelationEventEntry->type) {
+            case EventEntry::Type::KEY: {
+                logOutboundKeyDetails("cancel - ",
+                                      static_cast<const KeyEntry&>(*cancelationEventEntry));
+                break;
+            }
+            case EventEntry::Type::MOTION: {
+                logOutboundMotionDetails("cancel - ",
+                                         static_cast<const MotionEntry&>(*cancelationEventEntry));
+                break;
+            }
+            case EventEntry::Type::FOCUS: {
+                LOG_ALWAYS_FATAL("Canceling focus events is not supported");
+                break;
+            }
+            case EventEntry::Type::CONFIGURATION_CHANGED:
+            case EventEntry::Type::DEVICE_RESET: {
+                LOG_ALWAYS_FATAL("%s event should not be found inside Connections's queue",
+                                 EventEntry::typeToString(cancelationEventEntry->type));
+                break;
+            }
+        }
+        enqueueDispatchEntryLocked(connection, cancelationEventEntry,
+                                   target, InputTarget::FLAG_DISPATCH_AS_IS);
+        cancelationEventEntry->release();
+    }
+    startDispatchCycleLocked(currentTime, connection);
+}
+void InputDispatcher::synthesizePointerDownEventsForConnectionLocked(
+        const sp<Connection>& connection) {
+    if (connection->status == Connection::STATUS_BROKEN) {
+        return;
+    }
+    nsecs_t currentTime = now();
+    std::vector<EventEntry*> downEvents =
+            connection->inputState.synthesizePointerDownEvents(currentTime);
+    if (downEvents.empty()) {
+        return;
+    }
+#if DEBUG_OUTBOUND_EVENT_DETAILS
+        ALOGD("channel '%s' ~ Synthesized %zu down events to ensure consistent event stream.",
+              connection->getInputChannelName().c_str(), downEvents.size());
+#endif
+    InputTarget target;
+    sp<InputWindowHandle> windowHandle =
+            getWindowHandleLocked(connection->inputChannel->getConnectionToken());
+    if (windowHandle != nullptr) {
+        const InputWindowInfo* windowInfo = windowHandle->getInfo();
+        target.setDefaultPointerInfo(-windowInfo->frameLeft, -windowInfo->frameTop,
+                                     windowInfo->windowXScale, windowInfo->windowYScale);
+        target.globalScaleFactor = windowInfo->globalScaleFactor;
+    }
+    target.inputChannel = connection->inputChannel;
+    target.flags = InputTarget::FLAG_DISPATCH_AS_IS;
+    for (EventEntry* downEventEntry : downEvents) {
+        switch (downEventEntry->type) {
+            case EventEntry::Type::MOTION: {
+                logOutboundMotionDetails("down - ",
+                        static_cast<const MotionEntry&>(*downEventEntry));
+                break;
+            }
+            case EventEntry::Type::KEY:
+            case EventEntry::Type::FOCUS:
+            case EventEntry::Type::CONFIGURATION_CHANGED:
+            case EventEntry::Type::DEVICE_RESET: {
+                LOG_ALWAYS_FATAL("%s event should not be found inside Connections's queue",
+                                     EventEntry::typeToString(downEventEntry->type));
+                break;
+            }
+        }
+        enqueueDispatchEntryLocked(connection, downEventEntry,
+                                   target, InputTarget::FLAG_DISPATCH_AS_IS);
+        downEventEntry->release();
+    }
+    startDispatchCycleLocked(currentTime, connection);
+}
+MotionEntry* InputDispatcher::splitMotionEvent(const MotionEntry& originalMotionEntry,
+                                               BitSet32 pointerIds) {
+    ALOG_ASSERT(pointerIds.value != 0);
+    uint32_t splitPointerIndexMap[MAX_POINTERS];
+    PointerProperties splitPointerProperties[MAX_POINTERS];
+    PointerCoords splitPointerCoords[MAX_POINTERS];
+    uint32_t originalPointerCount = originalMotionEntry.pointerCount;
+    uint32_t splitPointerCount = 0;
+    for (uint32_t originalPointerIndex = 0; originalPointerIndex < originalPointerCount;
+         originalPointerIndex++) {
+        const PointerProperties& pointerProperties =
+                originalMotionEntry.pointerProperties[originalPointerIndex];
+        uint32_t pointerId = uint32_t(pointerProperties.id);
+        if (pointerIds.hasBit(pointerId)) {
+            splitPointerIndexMap[splitPointerCount] = originalPointerIndex;
+            splitPointerProperties[splitPointerCount].copyFrom(pointerProperties);
+            splitPointerCoords[splitPointerCount].copyFrom(
+                    originalMotionEntry.pointerCoords[originalPointerIndex]);
+            splitPointerCount += 1;
+        }
+    }
+    if (splitPointerCount != pointerIds.count()) {
+        ALOGW("Dropping split motion event because the pointer count is %d but "
+              "we expected there to be %d pointers.  This probably means we received "
+              "a broken sequence of pointer ids from the input device.",
+              splitPointerCount, pointerIds.count());
+        return nullptr;
+    }
+    int32_t action = originalMotionEntry.action;
+    int32_t maskedAction = action & AMOTION_EVENT_ACTION_MASK;
+    if (maskedAction == AMOTION_EVENT_ACTION_POINTER_DOWN ||
+        maskedAction == AMOTION_EVENT_ACTION_POINTER_UP) {
+        int32_t originalPointerIndex = getMotionEventActionPointerIndex(action);
+        const PointerProperties& pointerProperties =
+                originalMotionEntry.pointerProperties[originalPointerIndex];
+        uint32_t pointerId = uint32_t(pointerProperties.id);
+        if (pointerIds.hasBit(pointerId)) {
+            if (pointerIds.count() == 1) {
+                action = maskedAction == AMOTION_EVENT_ACTION_POINTER_DOWN
+                        ? AMOTION_EVENT_ACTION_DOWN
+                        : AMOTION_EVENT_ACTION_UP;
+            } else {
+                uint32_t splitPointerIndex = 0;
+                while (pointerId != uint32_t(splitPointerProperties[splitPointerIndex].id)) {
+                    splitPointerIndex += 1;
+                }
+                action = maskedAction |
+                        (splitPointerIndex << AMOTION_EVENT_ACTION_POINTER_INDEX_SHIFT);
+            }
+        } else {
+            action = AMOTION_EVENT_ACTION_MOVE;
+        }
+    }
+    int32_t newId = mIdGenerator.nextId();
+    if (ATRACE_ENABLED()) {
+        std::string message = StringPrintf("Split MotionEvent(id=0x%" PRIx32
+                                           ") to MotionEvent(id=0x%" PRIx32 ").",
+                                           originalMotionEntry.id, newId);
+        ATRACE_NAME(message.c_str());
+    }
+    MotionEntry* splitMotionEntry =
+            new MotionEntry(newId, originalMotionEntry.eventTime, originalMotionEntry.deviceId,
+                            originalMotionEntry.source, originalMotionEntry.displayId,
+                            originalMotionEntry.policyFlags, action,
+                            originalMotionEntry.actionButton, originalMotionEntry.flags,
+                            originalMotionEntry.metaState, originalMotionEntry.buttonState,
+                            originalMotionEntry.classification, originalMotionEntry.edgeFlags,
+                            originalMotionEntry.xPrecision, originalMotionEntry.yPrecision,
+                            originalMotionEntry.xCursorPosition,
+                            originalMotionEntry.yCursorPosition, originalMotionEntry.downTime,
+                            splitPointerCount, splitPointerProperties, splitPointerCoords, 0, 0);
+    if (originalMotionEntry.injectionState) {
+        splitMotionEntry->injectionState = originalMotionEntry.injectionState;
+        splitMotionEntry->injectionState->refCount += 1;
+    }
+    return splitMotionEntry;
+}
+void InputDispatcher::notifyConfigurationChanged(const NotifyConfigurationChangedArgs* args) {
+#if DEBUG_INBOUND_EVENT_DETAILS
+    ALOGD("notifyConfigurationChanged - eventTime=%" PRId64, args->eventTime);
+#endif
+    bool needWake;
+    {
+        std::scoped_lock _l(mLock);
+        ConfigurationChangedEntry* newEntry =
+                new ConfigurationChangedEntry(args->id, args->eventTime);
+        needWake = enqueueInboundEventLocked(newEntry);
+    }
+    if (needWake) {
@@ -650,2 +2379,0 @@ bool InputDispatcher::waitForIdle() {
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
@@ -653,6 +2380,0 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
-    mLooper->wake();
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
@@ -660,6 +2382,580 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
-    mLooper->wake();
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
+void InputDispatcher::accelerateMetaShortcuts(const int32_t deviceId, const int32_t action,
+                                              int32_t& keyCode, int32_t& metaState) {
+    if (metaState & AMETA_META_ON && action == AKEY_EVENT_ACTION_DOWN) {
+        int32_t newKeyCode = AKEYCODE_UNKNOWN;
+        if (keyCode == AKEYCODE_DEL) {
+            newKeyCode = AKEYCODE_BACK;
+        } else if (keyCode == AKEYCODE_ENTER) {
+            newKeyCode = AKEYCODE_HOME;
+        }
+        if (newKeyCode != AKEYCODE_UNKNOWN) {
+            std::scoped_lock _l(mLock);
+            struct KeyReplacement replacement = {keyCode, deviceId};
+            mReplacedKeys.add(replacement, newKeyCode);
+            keyCode = newKeyCode;
+            metaState &= ~(AMETA_META_ON | AMETA_META_LEFT_ON | AMETA_META_RIGHT_ON);
+        }
+    } else if (action == AKEY_EVENT_ACTION_UP) {
+        std::scoped_lock _l(mLock);
+        struct KeyReplacement replacement = {keyCode, deviceId};
+        ssize_t index = mReplacedKeys.indexOfKey(replacement);
+        if (index >= 0) {
+            keyCode = mReplacedKeys.valueAt(index);
+            mReplacedKeys.removeItemsAt(index);
+            metaState &= ~(AMETA_META_ON | AMETA_META_LEFT_ON | AMETA_META_RIGHT_ON);
+        }
+    }
+}
+void InputDispatcher::notifyKey(const NotifyKeyArgs* args) {
+#if DEBUG_INBOUND_EVENT_DETAILS
+    ALOGD("notifyKey - eventTime=%" PRId64 ", deviceId=%d, source=0x%x, displayId=%" PRId32
+          "policyFlags=0x%x, action=0x%x, "
+          "flags=0x%x, keyCode=0x%x, scanCode=0x%x, metaState=0x%x, downTime=%" PRId64,
+          args->eventTime, args->deviceId, args->source, args->displayId, args->policyFlags,
+          args->action, args->flags, args->keyCode, args->scanCode, args->metaState,
+          args->downTime);
+#endif
+    if (!validateKeyEvent(args->action)) {
+        return;
+    }
+    uint32_t policyFlags = args->policyFlags;
+    int32_t flags = args->flags;
+    int32_t metaState = args->metaState;
+    constexpr int32_t repeatCount = 0;
+    if ((policyFlags & POLICY_FLAG_VIRTUAL) || (flags & AKEY_EVENT_FLAG_VIRTUAL_HARD_KEY)) {
+        policyFlags |= POLICY_FLAG_VIRTUAL;
+        flags |= AKEY_EVENT_FLAG_VIRTUAL_HARD_KEY;
+    }
+    if (policyFlags & POLICY_FLAG_FUNCTION) {
+        metaState |= AMETA_FUNCTION_ON;
+    }
+    policyFlags |= POLICY_FLAG_TRUSTED;
+    int32_t keyCode = args->keyCode;
+    accelerateMetaShortcuts(args->deviceId, args->action, keyCode, metaState);
+    KeyEvent event;
+    event.initialize(args->id, args->deviceId, args->source, args->displayId, INVALID_HMAC,
+                     args->action, flags, keyCode, args->scanCode, metaState, repeatCount,
+                     args->downTime, args->eventTime);
+    android::base::Timer t;
+    mPolicy->interceptKeyBeforeQueueing(&event, policyFlags);
+    if (t.duration() > SLOW_INTERCEPTION_THRESHOLD) {
+        ALOGW("Excessive delay in interceptKeyBeforeQueueing; took %s ms",
+              std::to_string(t.duration().count()).c_str());
+    }
+    bool needWake;
+    {
+        mLock.lock();
+        if (shouldSendKeyToInputFilterLocked(args)) {
+            mLock.unlock();
+            policyFlags |= POLICY_FLAG_FILTERED;
+            if (!mPolicy->filterInputEvent(&event, policyFlags)) {
+                return;
+            }
+            mLock.lock();
+        }
+        KeyEntry* newEntry =
+                new KeyEntry(args->id, args->eventTime, args->deviceId, args->source,
+                             args->displayId, policyFlags, args->action, flags, keyCode,
+                             args->scanCode, metaState, repeatCount, args->downTime);
+        needWake = enqueueInboundEventLocked(newEntry);
+        mLock.unlock();
+    }
+    if (needWake) {
+        mLooper->wake();
+    }
+}
+bool InputDispatcher::shouldSendKeyToInputFilterLocked(const NotifyKeyArgs* args) {
+    return mInputFilterEnabled;
+}
+void InputDispatcher::notifyMotion(const NotifyMotionArgs* args) {
+#if DEBUG_INBOUND_EVENT_DETAILS
+    ALOGD("notifyMotion - id=%" PRIx32 " eventTime=%" PRId64 ", deviceId=%d, source=0x%x, "
+          "displayId=%" PRId32 ", policyFlags=0x%x, "
+          "action=0x%x, actionButton=0x%x, flags=0x%x, metaState=0x%x, buttonState=0x%x, "
+          "edgeFlags=0x%x, xPrecision=%f, yPrecision=%f, xCursorPosition=%f, "
+          "yCursorPosition=%f, downTime=%" PRId64,
+          args->id, args->eventTime, args->deviceId, args->source, args->displayId,
+          args->policyFlags, args->action, args->actionButton, args->flags, args->metaState,
+          args->buttonState, args->edgeFlags, args->xPrecision, args->yPrecision,
+          args->xCursorPosition, args->yCursorPosition, args->downTime);
+    for (uint32_t i = 0; i < args->pointerCount; i++) {
+        ALOGD("  Pointer %d: id=%d, toolType=%d, "
+              "x=%f, y=%f, pressure=%f, size=%f, "
+              "touchMajor=%f, touchMinor=%f, toolMajor=%f, toolMinor=%f, "
+              "orientation=%f",
+              i, args->pointerProperties[i].id, args->pointerProperties[i].toolType,
+              args->pointerCoords[i].getAxisValue(AMOTION_EVENT_AXIS_X),
+              args->pointerCoords[i].getAxisValue(AMOTION_EVENT_AXIS_Y),
+              args->pointerCoords[i].getAxisValue(AMOTION_EVENT_AXIS_PRESSURE),
+              args->pointerCoords[i].getAxisValue(AMOTION_EVENT_AXIS_SIZE),
+              args->pointerCoords[i].getAxisValue(AMOTION_EVENT_AXIS_TOUCH_MAJOR),
+              args->pointerCoords[i].getAxisValue(AMOTION_EVENT_AXIS_TOUCH_MINOR),
+              args->pointerCoords[i].getAxisValue(AMOTION_EVENT_AXIS_TOOL_MAJOR),
+              args->pointerCoords[i].getAxisValue(AMOTION_EVENT_AXIS_TOOL_MINOR),
+              args->pointerCoords[i].getAxisValue(AMOTION_EVENT_AXIS_ORIENTATION));
+    }
+#endif
+    if (!validateMotionEvent(args->action, args->actionButton, args->pointerCount,
+                             args->pointerProperties)) {
+        return;
+    }
+    uint32_t policyFlags = args->policyFlags;
+    policyFlags |= POLICY_FLAG_TRUSTED;
+    android::base::Timer t;
+    mPolicy->interceptMotionBeforeQueueing(args->displayId, args->eventTime, policyFlags);
+    if (t.duration() > SLOW_INTERCEPTION_THRESHOLD) {
+        ALOGW("Excessive delay in interceptMotionBeforeQueueing; took %s ms",
+              std::to_string(t.duration().count()).c_str());
+    }
+    bool needWake;
+    {
+        mLock.lock();
+        if (shouldSendMotionToInputFilterLocked(args)) {
+            mLock.unlock();
+            MotionEvent event;
+            event.initialize(args->id, args->deviceId, args->source, args->displayId, INVALID_HMAC,
+                             args->action, args->actionButton, args->flags, args->edgeFlags,
+                             args->metaState, args->buttonState, args->classification, 1 ,
+                             1 , 0 , 0 , args->xPrecision,
+                             args->yPrecision, args->xCursorPosition, args->yCursorPosition,
+                             args->downTime, args->eventTime, args->pointerCount,
+                             args->pointerProperties, args->pointerCoords);
+            policyFlags |= POLICY_FLAG_FILTERED;
+            if (!mPolicy->filterInputEvent(&event, policyFlags)) {
+                return;
+            }
+            mLock.lock();
+        }
+        MotionEntry* newEntry =
+                new MotionEntry(args->id, args->eventTime, args->deviceId, args->source,
+                                args->displayId, policyFlags, args->action, args->actionButton,
+                                args->flags, args->metaState, args->buttonState,
+                                args->classification, args->edgeFlags, args->xPrecision,
+                                args->yPrecision, args->xCursorPosition, args->yCursorPosition,
+                                args->downTime, args->pointerCount, args->pointerProperties,
+                                args->pointerCoords, 0, 0);
+        needWake = enqueueInboundEventLocked(newEntry);
+        mLock.unlock();
+    }
+    if (needWake) {
+        mLooper->wake();
+    }
+}
+bool InputDispatcher::shouldSendMotionToInputFilterLocked(const NotifyMotionArgs* args) {
+    return mInputFilterEnabled;
+}
+void InputDispatcher::notifySwitch(const NotifySwitchArgs* args) {
+#if DEBUG_INBOUND_EVENT_DETAILS
+    ALOGD("notifySwitch - eventTime=%" PRId64 ", policyFlags=0x%x, switchValues=0x%08x, "
+          "switchMask=0x%08x",
+          args->eventTime, args->policyFlags, args->switchValues, args->switchMask);
+#endif
+    uint32_t policyFlags = args->policyFlags;
+    policyFlags |= POLICY_FLAG_TRUSTED;
+    mPolicy->notifySwitch(args->eventTime, args->switchValues, args->switchMask, policyFlags);
+}
+void InputDispatcher::notifyDeviceReset(const NotifyDeviceResetArgs* args) {
+#if DEBUG_INBOUND_EVENT_DETAILS
+    ALOGD("notifyDeviceReset - eventTime=%" PRId64 ", deviceId=%d", args->eventTime,
+          args->deviceId);
+#endif
+    bool needWake;
+    {
+        std::scoped_lock _l(mLock);
+        DeviceResetEntry* newEntry =
+                new DeviceResetEntry(args->id, args->eventTime, args->deviceId);
+        needWake = enqueueInboundEventLocked(newEntry);
+    }
+    if (needWake) {
+        mLooper->wake();
+    }
+}
+int32_t InputDispatcher::injectInputEvent(const InputEvent* event, int32_t injectorPid,
+                                          int32_t injectorUid, int32_t syncMode,
+                                          int32_t timeoutMillis, uint32_t policyFlags) {
+#if DEBUG_INBOUND_EVENT_DETAILS
+    ALOGD("injectInputEvent - eventType=%d, injectorPid=%d, injectorUid=%d, "
+          "syncMode=%d, timeoutMillis=%d, policyFlags=0x%08x",
+          event->getType(), injectorPid, injectorUid, syncMode, timeoutMillis, policyFlags);
+#endif
+    nsecs_t endTime = now() + milliseconds_to_nanoseconds(timeoutMillis);
+    policyFlags |= POLICY_FLAG_INJECTED;
+    if (hasInjectionPermission(injectorPid, injectorUid)) {
+        policyFlags |= POLICY_FLAG_TRUSTED;
+    }
+    std::queue<EventEntry*> injectedEntries;
+    switch (event->getType()) {
+        case AINPUT_EVENT_TYPE_KEY: {
+            const KeyEvent& incomingKey = static_cast<const KeyEvent&>(*event);
+            int32_t action = incomingKey.getAction();
+            if (!validateKeyEvent(action)) {
+                return INPUT_EVENT_INJECTION_FAILED;
+            }
+            int32_t flags = incomingKey.getFlags();
+            int32_t keyCode = incomingKey.getKeyCode();
+            int32_t metaState = incomingKey.getMetaState();
+            accelerateMetaShortcuts(VIRTUAL_KEYBOARD_ID, action,
+                                              keyCode, metaState);
+            KeyEvent keyEvent;
+            keyEvent.initialize(incomingKey.getId(), VIRTUAL_KEYBOARD_ID, incomingKey.getSource(),
+                                incomingKey.getDisplayId(), INVALID_HMAC, action, flags, keyCode,
+                                incomingKey.getScanCode(), metaState, incomingKey.getRepeatCount(),
+                                incomingKey.getDownTime(), incomingKey.getEventTime());
+            if (flags & AKEY_EVENT_FLAG_VIRTUAL_HARD_KEY) {
+                policyFlags |= POLICY_FLAG_VIRTUAL;
+            }
+            if (!(policyFlags & POLICY_FLAG_FILTERED)) {
+                android::base::Timer t;
+                mPolicy->interceptKeyBeforeQueueing(&keyEvent, policyFlags);
+                if (t.duration() > SLOW_INTERCEPTION_THRESHOLD) {
+                    ALOGW("Excessive delay in interceptKeyBeforeQueueing; took %s ms",
+                          std::to_string(t.duration().count()).c_str());
+                }
+            }
+            mLock.lock();
+            KeyEntry* injectedEntry =
+                    new KeyEntry(incomingKey.getId(), incomingKey.getEventTime(),
+                                 VIRTUAL_KEYBOARD_ID, incomingKey.getSource(),
+                                 incomingKey.getDisplayId(), policyFlags, action, flags,
+                                 incomingKey.getKeyCode(), incomingKey.getScanCode(),
+                                 incomingKey.getMetaState(), incomingKey.getRepeatCount(),
+                                 incomingKey.getDownTime());
+            injectedEntries.push(injectedEntry);
+            break;
+        }
+        case AINPUT_EVENT_TYPE_MOTION: {
+            const MotionEvent* motionEvent = static_cast<const MotionEvent*>(event);
+            int32_t action = motionEvent->getAction();
+            size_t pointerCount = motionEvent->getPointerCount();
+            const PointerProperties* pointerProperties = motionEvent->getPointerProperties();
+            int32_t actionButton = motionEvent->getActionButton();
+            int32_t displayId = motionEvent->getDisplayId();
+            if (!validateMotionEvent(action, actionButton, pointerCount, pointerProperties)) {
+                return INPUT_EVENT_INJECTION_FAILED;
+            }
+            if (!(policyFlags & POLICY_FLAG_FILTERED)) {
+                nsecs_t eventTime = motionEvent->getEventTime();
+                android::base::Timer t;
+                mPolicy->interceptMotionBeforeQueueing(displayId, eventTime, policyFlags);
+                if (t.duration() > SLOW_INTERCEPTION_THRESHOLD) {
+                    ALOGW("Excessive delay in interceptMotionBeforeQueueing; took %s ms",
+                          std::to_string(t.duration().count()).c_str());
+                }
+            }
+            mLock.lock();
+            const nsecs_t* sampleEventTimes = motionEvent->getSampleEventTimes();
+            const PointerCoords* samplePointerCoords = motionEvent->getSamplePointerCoords();
+            MotionEntry* injectedEntry =
+                    new MotionEntry(motionEvent->getId(), *sampleEventTimes, VIRTUAL_KEYBOARD_ID,
+                                    motionEvent->getSource(), motionEvent->getDisplayId(),
+                                    policyFlags, action, actionButton, motionEvent->getFlags(),
+                                    motionEvent->getMetaState(), motionEvent->getButtonState(),
+                                    motionEvent->getClassification(), motionEvent->getEdgeFlags(),
+                                    motionEvent->getXPrecision(), motionEvent->getYPrecision(),
+                                    motionEvent->getRawXCursorPosition(),
+                                    motionEvent->getRawYCursorPosition(),
+                                    motionEvent->getDownTime(), uint32_t(pointerCount),
+                                    pointerProperties, samplePointerCoords,
+                                    motionEvent->getXOffset(), motionEvent->getYOffset());
+            injectedEntries.push(injectedEntry);
+            for (size_t i = motionEvent->getHistorySize(); i > 0; i--) {
+                sampleEventTimes += 1;
+                samplePointerCoords += pointerCount;
+                MotionEntry* nextInjectedEntry =
+                        new MotionEntry(motionEvent->getId(), *sampleEventTimes,
+                                        VIRTUAL_KEYBOARD_ID, motionEvent->getSource(),
+                                        motionEvent->getDisplayId(), policyFlags, action,
+                                        actionButton, motionEvent->getFlags(),
+                                        motionEvent->getMetaState(), motionEvent->getButtonState(),
+                                        motionEvent->getClassification(),
+                                        motionEvent->getEdgeFlags(), motionEvent->getXPrecision(),
+                                        motionEvent->getYPrecision(),
+                                        motionEvent->getRawXCursorPosition(),
+                                        motionEvent->getRawYCursorPosition(),
+                                        motionEvent->getDownTime(), uint32_t(pointerCount),
+                                        pointerProperties, samplePointerCoords,
+                                        motionEvent->getXOffset(), motionEvent->getYOffset());
+                injectedEntries.push(nextInjectedEntry);
+            }
+            break;
+        }
+        default:
+            ALOGW("Cannot inject %s events", inputEventTypeToString(event->getType()));
+            return INPUT_EVENT_INJECTION_FAILED;
+    }
+    InjectionState* injectionState = new InjectionState(injectorPid, injectorUid);
+    if (syncMode == INPUT_EVENT_INJECTION_SYNC_NONE) {
+        injectionState->injectionIsAsync = true;
+    }
+    injectionState->refCount += 1;
+    injectedEntries.back()->injectionState = injectionState;
+    bool needWake = false;
+    while (!injectedEntries.empty()) {
+        needWake |= enqueueInboundEventLocked(injectedEntries.front());
+        injectedEntries.pop();
+    }
+    mLock.unlock();
+    if (needWake) {
+        mLooper->wake();
+    }
+    int32_t injectionResult;
+    {
+        std::unique_lock _l(mLock);
+        if (syncMode == INPUT_EVENT_INJECTION_SYNC_NONE) {
+            injectionResult = INPUT_EVENT_INJECTION_SUCCEEDED;
+        } else {
+            for (;;) {
+                injectionResult = injectionState->injectionResult;
+                if (injectionResult != INPUT_EVENT_INJECTION_PENDING) {
+                    break;
+                }
+                nsecs_t remainingTimeout = endTime - now();
+                if (remainingTimeout <= 0) {
+#if DEBUG_INJECTION
+                    ALOGD("injectInputEvent - Timed out waiting for injection result "
+                          "to become available.");
+#endif
+                    injectionResult = INPUT_EVENT_INJECTION_TIMED_OUT;
+                    break;
+                }
+                mInjectionResultAvailable.wait_for(_l, std::chrono::nanoseconds(remainingTimeout));
+            }
+            if (injectionResult == INPUT_EVENT_INJECTION_SUCCEEDED &&
+                syncMode == INPUT_EVENT_INJECTION_SYNC_WAIT_FOR_FINISHED) {
+                while (injectionState->pendingForegroundDispatches != 0) {
+#if DEBUG_INJECTION
+                    ALOGD("injectInputEvent - Waiting for %d pending foreground dispatches.",
+                          injectionState->pendingForegroundDispatches);
+#endif
+                    nsecs_t remainingTimeout = endTime - now();
+                    if (remainingTimeout <= 0) {
+#if DEBUG_INJECTION
+                        ALOGD("injectInputEvent - Timed out waiting for pending foreground "
+                              "dispatches to finish.");
+#endif
+                        injectionResult = INPUT_EVENT_INJECTION_TIMED_OUT;
+                        break;
+                    }
+                    mInjectionSyncFinished.wait_for(_l, std::chrono::nanoseconds(remainingTimeout));
+                }
+            }
+        }
+        injectionState->release();
+    }
+#if DEBUG_INJECTION
+    ALOGD("injectInputEvent - Finished with result %d.  "
+          "injectorPid=%d, injectorUid=%d",
+          injectionResult, injectorPid, injectorUid);
+#endif
+    return injectionResult;
+}
+std::unique_ptr<VerifiedInputEvent> InputDispatcher::verifyInputEvent(const InputEvent& event) {
+    std::array<uint8_t, 32> calculatedHmac;
+    std::unique_ptr<VerifiedInputEvent> result;
+    switch (event.getType()) {
+        case AINPUT_EVENT_TYPE_KEY: {
+            const KeyEvent& keyEvent = static_cast<const KeyEvent&>(event);
+            VerifiedKeyEvent verifiedKeyEvent = verifiedKeyEventFromKeyEvent(keyEvent);
+            result = std::make_unique<VerifiedKeyEvent>(verifiedKeyEvent);
+            calculatedHmac = mHmacKeyManager.sign(verifiedKeyEvent);
+            break;
+        }
+        case AINPUT_EVENT_TYPE_MOTION: {
+            const MotionEvent& motionEvent = static_cast<const MotionEvent&>(event);
+            VerifiedMotionEvent verifiedMotionEvent =
+                    verifiedMotionEventFromMotionEvent(motionEvent);
+            result = std::make_unique<VerifiedMotionEvent>(verifiedMotionEvent);
+            calculatedHmac = mHmacKeyManager.sign(verifiedMotionEvent);
+            break;
+        }
+        default: {
+            ALOGE("Cannot verify events of type %" PRId32, event.getType());
+            return nullptr;
+        }
+    }
+    if (calculatedHmac == INVALID_HMAC) {
+        return nullptr;
+    }
+    if (calculatedHmac != event.getHmac()) {
+        return nullptr;
+    }
+    return result;
+}
+bool InputDispatcher::hasInjectionPermission(int32_t injectorPid, int32_t injectorUid) {
+    return injectorUid == 0 ||
+            mPolicy->checkInjectEventsPermissionNonReentrant(injectorPid, injectorUid);
+}
+void InputDispatcher::setInjectionResult(EventEntry* entry, int32_t injectionResult) {
+    InjectionState* injectionState = entry->injectionState;
+    if (injectionState) {
+#if DEBUG_INJECTION
+        ALOGD("Setting input event injection result to %d.  "
+              "injectorPid=%d, injectorUid=%d",
+              injectionResult, injectionState->injectorPid, injectionState->injectorUid);
+#endif
+        if (injectionState->injectionIsAsync && !(entry->policyFlags & POLICY_FLAG_FILTERED)) {
+            switch (injectionResult) {
+                case INPUT_EVENT_INJECTION_SUCCEEDED:
+                    ALOGV("Asynchronous input event injection succeeded.");
+                    break;
+                case INPUT_EVENT_INJECTION_FAILED:
+                    ALOGW("Asynchronous input event injection failed.");
+                    break;
+                case INPUT_EVENT_INJECTION_PERMISSION_DENIED:
+                    ALOGW("Asynchronous input event injection permission denied.");
+                    break;
+                case INPUT_EVENT_INJECTION_TIMED_OUT:
+                    ALOGW("Asynchronous input event injection timed out.");
+                    break;
+            }
+        }
+        injectionState->injectionResult = injectionResult;
+        mInjectionResultAvailable.notify_all();
+    }
+}
+void InputDispatcher::incrementPendingForegroundDispatches(EventEntry* entry) {
+    InjectionState* injectionState = entry->injectionState;
+    if (injectionState) {
+        injectionState->pendingForegroundDispatches += 1;
+    }
+}
+void InputDispatcher::decrementPendingForegroundDispatches(EventEntry* entry) {
+    InjectionState* injectionState = entry->injectionState;
+    if (injectionState) {
+        injectionState->pendingForegroundDispatches -= 1;
+        if (injectionState->pendingForegroundDispatches == 0) {
+            mInjectionSyncFinished.notify_all();
+        }
+    }
+}
+std::vector<sp<InputWindowHandle>> InputDispatcher::getWindowHandlesLocked(
+        int32_t displayId) const {
+    return getValueByKey(mWindowHandlesByDisplay, displayId);
+}
+sp<InputWindowHandle> InputDispatcher::getWindowHandleLocked(
+        const sp<IBinder>& windowHandleToken) const {
+    for (auto& it : mWindowHandlesByDisplay) {
+        const std::vector<sp<InputWindowHandle>> windowHandles = it.second;
+        for (const sp<InputWindowHandle>& windowHandle : windowHandles) {
+            if (windowHandle->getToken() == windowHandleToken) {
+                return windowHandle;
+            }
+        }
+    }
+    return nullptr;
+}
+bool InputDispatcher::hasWindowHandleLocked(const sp<InputWindowHandle>& windowHandle) const {
+    for (auto& it : mWindowHandlesByDisplay) {
+        const std::vector<sp<InputWindowHandle>> windowHandles = it.second;
+        for (const sp<InputWindowHandle>& handle : windowHandles) {
+            if (handle->getToken() == windowHandle->getToken()) {
+                if (windowHandle->getInfo()->displayId != it.first) {
+                    ALOGE("Found window %s in display %" PRId32
+                          ", but it should belong to display %" PRId32,
+                          windowHandle->getName().c_str(), it.first,
+                          windowHandle->getInfo()->displayId);
+                }
+                return true;
+            }
+        }
+    }
+    return false;
+}
+sp<InputChannel> InputDispatcher::getInputChannelLocked(const sp<IBinder>& token) const {
+    size_t count = mInputChannelsByToken.count(token);
+    if (count == 0) {
+        return nullptr;
+    }
+    return mInputChannelsByToken.at(token);
+}
+void InputDispatcher::updateWindowHandlesForDisplayLocked(
+        const std::vector<sp<InputWindowHandle>>& inputWindowHandles, int32_t displayId) {
+    if (inputWindowHandles.empty()) {
+        mWindowHandlesByDisplay.erase(displayId);
+        return;
+    }
+    const std::vector<sp<InputWindowHandle>>& oldHandles = getWindowHandlesLocked(displayId);
+    std::unordered_map<int32_t , sp<InputWindowHandle>> oldHandlesById;
+    for (const sp<InputWindowHandle>& handle : oldHandles) {
+        oldHandlesById[handle->getId()] = handle;
+    }
+    std::vector<sp<InputWindowHandle>> newHandles;
+    for (const sp<InputWindowHandle>& handle : inputWindowHandles) {
+        if (!handle->updateInfo()) {
+            continue;
+        }
+        const InputWindowInfo* info = handle->getInfo();
+        if ((getInputChannelLocked(handle->getToken()) == nullptr &&
+             info->portalToDisplayId == ADISPLAY_ID_NONE)) {
+            const bool noInputChannel =
+                    info->inputFeatures & InputWindowInfo::INPUT_FEATURE_NO_INPUT_CHANNEL;
+            const bool canReceiveInput =
+                    !(info->layoutParamsFlags & InputWindowInfo::FLAG_NOT_TOUCHABLE) ||
+                    !(info->layoutParamsFlags & InputWindowInfo::FLAG_NOT_FOCUSABLE);
+            if (canReceiveInput && !noInputChannel) {
+                ALOGV("Window handle %s has no registered input channel",
+                      handle->getName().c_str());
+            }
+            continue;
+        }
+        if (info->displayId != displayId) {
+            ALOGE("Window %s updated by wrong display %d, should belong to display %d",
+                  handle->getName().c_str(), displayId, info->displayId);
+            continue;
+        }
+        if (oldHandlesById.find(handle->getId()) != oldHandlesById.end()) {
+            const sp<InputWindowHandle>& oldHandle = oldHandlesById.at(handle->getId());
+            oldHandle->updateFrom(handle);
+            newHandles.push_back(oldHandle);
+        } else {
+            newHandles.push_back(handle);
+        }
+    }
+    mWindowHandlesByDisplay[displayId] = newHandles;
+}
+void InputDispatcher::setInputWindows(const std::vector<sp<InputWindowHandle>>& inputWindowHandles,
+                                      int32_t displayId,
+                                      const sp<ISetInputWindowsListener>& setInputWindowsListener) {
+    if (DEBUG_FOCUS) {
+        std::string windowList;
+        for (const sp<InputWindowHandle>& iwh : inputWindowHandles) {
+            windowList += iwh->getName() + " ";
+        }
+        ALOGD("setInputWindows displayId=%" PRId32 " %s", displayId, windowList.c_str());
+    }
+    {
+        std::scoped_lock _l(mLock);
+        const std::vector<sp<InputWindowHandle>> oldWindowHandles =
+                getWindowHandlesLocked(displayId);
+        updateWindowHandlesForDisplayLocked(inputWindowHandles, displayId);
+        sp<InputWindowHandle> newFocusedWindowHandle = nullptr;
+        bool foundHoveredWindow = false;
+        for (const sp<InputWindowHandle>& windowHandle : getWindowHandlesLocked(displayId)) {
+            if (!newFocusedWindowHandle && windowHandle->getInfo()->hasFocus &&
+                windowHandle->getInfo()->visible) {
+                newFocusedWindowHandle = windowHandle;
+            }
+            if (windowHandle == mLastHoverWindowHandle) {
+                foundHoveredWindow = true;
+            }
+        }
+        if (!foundHoveredWindow) {
+            mLastHoverWindowHandle = nullptr;
+        }
+        sp<InputWindowHandle> oldFocusedWindowHandle =
+                getValueByKey(mFocusedWindowHandlesByDisplay, displayId);
+        if (!haveSameToken(oldFocusedWindowHandle, newFocusedWindowHandle)) {
+            if (oldFocusedWindowHandle != nullptr) {
+                if (DEBUG_FOCUS) {
+                    ALOGD("Focus left window: %s in display %" PRId32,
+                          oldFocusedWindowHandle->getName().c_str(), displayId);
+                }
+                sp<InputChannel> focusedInputChannel =
+                        getInputChannelLocked(oldFocusedWindowHandle->getToken());
+                if (focusedInputChannel != nullptr) {
+                    CancelationOptions options(CancelationOptions::CANCEL_NON_POINTER_EVENTS,
+                                               "focus left window");
+                    synthesizeCancelationEventsForInputChannelLocked(focusedInputChannel, options);
+                    enqueueFocusEventLocked(*oldFocusedWindowHandle, false );
+                }
+                mFocusedWindowHandlesByDisplay.erase(displayId);
@@ -667,6 +2963,4 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
-    mLooper->wake();
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
+            if (newFocusedWindowHandle != nullptr) {
+                if (DEBUG_FOCUS) {
+                    ALOGD("Focus entered window: %s in display %" PRId32,
+                          newFocusedWindowHandle->getName().c_str(), displayId);
@@ -674,6 +2968,2 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
-    mLooper->wake();
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
+                mFocusedWindowHandlesByDisplay[displayId] = newFocusedWindowHandle;
+                enqueueFocusEventLocked(*newFocusedWindowHandle, true );
@@ -681,6 +2971,2 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
-    mLooper->wake();
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
+            if (mFocusedDisplayId == displayId) {
+                onFocusChangedLocked(oldFocusedWindowHandle, newFocusedWindowHandle);
@@ -688,6 +2973,0 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
-    mLooper->wake();
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
@@ -695,6 +2975,21 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
-    mLooper->wake();
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
+        ssize_t stateIndex = mTouchStatesByDisplay.indexOfKey(displayId);
+        if (stateIndex >= 0) {
+            TouchState& state = mTouchStatesByDisplay.editValueAt(stateIndex);
+            for (size_t i = 0; i < state.windows.size();) {
+                TouchedWindow& touchedWindow = state.windows[i];
+                if (!hasWindowHandleLocked(touchedWindow.windowHandle)) {
+                    if (DEBUG_FOCUS) {
+                        ALOGD("Touched window was removed: %s in display %" PRId32,
+                              touchedWindow.windowHandle->getName().c_str(), displayId);
+                    }
+                    sp<InputChannel> touchedInputChannel =
+                            getInputChannelLocked(touchedWindow.windowHandle->getToken());
+                    if (touchedInputChannel != nullptr) {
+                        CancelationOptions options(CancelationOptions::CANCEL_POINTER_EVENTS,
+                                                   "touched window was removed");
+                        synthesizeCancelationEventsForInputChannelLocked(touchedInputChannel,
+                                                                         options);
+                    }
+                    state.windows.erase(state.windows.begin() + i);
+                } else {
+                    ++i;
@@ -702,6 +2996,0 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
-    mLooper->wake();
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
@@ -709,6 +2997,0 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
-    mLooper->wake();
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
@@ -716,6 +2999,4 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
-    mLooper->wake();
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
+        for (const sp<InputWindowHandle>& oldWindowHandle : oldWindowHandles) {
+            if (!hasWindowHandleLocked(oldWindowHandle)) {
+                if (DEBUG_FOCUS) {
+                    ALOGD("Window went away: %s", oldWindowHandle->getName().c_str());
@@ -723,6 +3004 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
-    mLooper->wake();
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
+                oldWindowHandle->releaseChannel();
@@ -730,6 +3005,0 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
-    mLooper->wake();
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
@@ -737,6 +3006,0 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
-    mLooper->wake();
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
@@ -744,3 +3007,0 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
@@ -748,2 +3009,2 @@ bool InputDispatcher::waitForIdle() {
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
+    if (setInputWindowsListener) {
+        setInputWindowsListener->onSetInputWindowsFinished();
@@ -751,6 +3011,0 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
-    mLooper->wake();
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
@@ -758,6 +3013,5 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
-    mLooper->wake();
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
+void InputDispatcher::setFocusedApplication(
+        int32_t displayId, const sp<InputApplicationHandle>& inputApplicationHandle) {
+    if (DEBUG_FOCUS) {
+        ALOGD("setFocusedApplication displayId=%" PRId32 " %s", displayId,
+              inputApplicationHandle ? inputApplicationHandle->getName().c_str() : "<nullptr>");
@@ -765,6 +3019,8 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
-    mLooper->wake();
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
+    {
+        std::scoped_lock _l(mLock);
+        sp<InputApplicationHandle> oldFocusedApplicationHandle =
+                getValueByKey(mFocusedApplicationHandlesByDisplay, displayId);
+        if (inputApplicationHandle != nullptr && inputApplicationHandle->updateInfo()) {
+            if (oldFocusedApplicationHandle != inputApplicationHandle) {
+                if (oldFocusedApplicationHandle != nullptr) {
+                    resetANRTimeoutsLocked();
@@ -772,6 +3028 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
-    mLooper->wake();
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
+                mFocusedApplicationHandlesByDisplay[displayId] = inputApplicationHandle;
@@ -779,6 +3030,4 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
-    mLooper->wake();
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
+        } else if (oldFocusedApplicationHandle != nullptr) {
+            resetANRTimeoutsLocked();
+            oldFocusedApplicationHandle.clear();
+            mFocusedApplicationHandlesByDisplay.erase(displayId);
@@ -786,6 +3034,0 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
-    mLooper->wake();
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
@@ -793,3 +3035,0 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
@@ -797,2 +3036,0 @@ bool InputDispatcher::waitForIdle() {
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
@@ -800,6 +3038,3 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
-    mLooper->wake();
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
+void InputDispatcher::setFocusedDisplay(int32_t displayId) {
+    if (DEBUG_FOCUS) {
+        ALOGD("setFocusedDisplay displayId=%" PRId32, displayId);
@@ -807,6 +3042,29 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
-    mLooper->wake();
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
+    {
+        std::scoped_lock _l(mLock);
+        if (mFocusedDisplayId != displayId) {
+            sp<InputWindowHandle> oldFocusedWindowHandle =
+                    getValueByKey(mFocusedWindowHandlesByDisplay, mFocusedDisplayId);
+            if (oldFocusedWindowHandle != nullptr) {
+                sp<InputChannel> inputChannel =
+                        getInputChannelLocked(oldFocusedWindowHandle->getToken());
+                if (inputChannel != nullptr) {
+                    CancelationOptions
+                            options(CancelationOptions::CANCEL_NON_POINTER_EVENTS,
+                                    "The display which contains this window no longer has focus.");
+                    options.displayId = ADISPLAY_ID_NONE;
+                    synthesizeCancelationEventsForInputChannelLocked(inputChannel, options);
+                }
+            }
+            mFocusedDisplayId = displayId;
+            sp<InputWindowHandle> newFocusedWindowHandle =
+                    getValueByKey(mFocusedWindowHandlesByDisplay, displayId);
+            onFocusChangedLocked(oldFocusedWindowHandle, newFocusedWindowHandle);
+            if (newFocusedWindowHandle == nullptr) {
+                ALOGW("Focused display #%" PRId32 " does not have a focused window.", displayId);
+                if (!mFocusedWindowHandlesByDisplay.empty()) {
+                    ALOGE("But another display has a focused window:");
+                    for (auto& it : mFocusedWindowHandlesByDisplay) {
+                        const int32_t displayId = it.first;
+                        const sp<InputWindowHandle>& windowHandle = it.second;
+                        ALOGE("Display #%" PRId32 " has focused window: '%s'\n", displayId,
+                              windowHandle->getName().c_str());
@@ -814,6 +3071,0 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
-    mLooper->wake();
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
@@ -821,6 +3072,0 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
-    mLooper->wake();
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
@@ -828,6 +3073,0 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
-    mLooper->wake();
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
@@ -835,6 +3075,2 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
-    mLooper->wake();
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
+        if (DEBUG_FOCUS) {
+            logDispatchStateLocked();
@@ -842,6 +3077,0 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
-    mLooper->wake();
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
@@ -849,3 +3078,0 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
@@ -853,2 +3079,0 @@ bool InputDispatcher::waitForIdle() {
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
@@ -856,3 +3081,25 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
+void InputDispatcher::setInputDispatchMode(bool enabled, bool frozen) {
+    if (DEBUG_FOCUS) {
+        ALOGD("setInputDispatchMode: enabled=%d, frozen=%d", enabled, frozen);
+    }
+    bool changed;
+    {
+        std::scoped_lock _l(mLock);
+        if (mDispatchEnabled != enabled || mDispatchFrozen != frozen) {
+            if (mDispatchFrozen && !frozen) {
+                resetANRTimeoutsLocked();
+            }
+            if (mDispatchEnabled && !enabled) {
+                resetAndDropEverythingLocked("dispatcher is being disabled");
+            }
+            mDispatchEnabled = enabled;
+            mDispatchFrozen = frozen;
+            changed = true;
+        } else {
+            changed = false;
+        }
+        if (DEBUG_FOCUS) {
+            logDispatchStateLocked();
+        }
+    }
+    if (changed) {
@@ -860,2 +3106,0 @@ bool InputDispatcher::waitForIdle() {
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
@@ -863,3 +3108,13 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
+}
+void InputDispatcher::setInputFilterEnabled(bool enabled) {
+    if (DEBUG_FOCUS) {
+        ALOGD("setInputFilterEnabled: enabled=%d", enabled);
+    }
+    {
+        std::scoped_lock _l(mLock);
+        if (mInputFilterEnabled == enabled) {
+            return;
+        }
+        mInputFilterEnabled = enabled;
+        resetAndDropEverythingLocked("input filter is being enabled or disabled");
+    }
@@ -867,2 +3121,0 @@ bool InputDispatcher::waitForIdle() {
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
@@ -870,3 +3123,68 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
+void InputDispatcher::setInTouchMode(bool inTouchMode) {
+    std::scoped_lock lock(mLock);
+    mInTouchMode = inTouchMode;
+}
+bool InputDispatcher::transferTouchFocus(const sp<IBinder>& fromToken, const sp<IBinder>& toToken) {
+    if (fromToken == toToken) {
+        if (DEBUG_FOCUS) {
+            ALOGD("Trivial transfer to same window.");
+        }
+        return true;
+    }
+    {
+        std::scoped_lock _l(mLock);
+        sp<InputWindowHandle> fromWindowHandle = getWindowHandleLocked(fromToken);
+        sp<InputWindowHandle> toWindowHandle = getWindowHandleLocked(toToken);
+        if (fromWindowHandle == nullptr || toWindowHandle == nullptr) {
+            ALOGW("Cannot transfer focus because from or to window not found.");
+            return false;
+        }
+        if (DEBUG_FOCUS) {
+            ALOGD("transferTouchFocus: fromWindowHandle=%s, toWindowHandle=%s",
+                  fromWindowHandle->getName().c_str(), toWindowHandle->getName().c_str());
+        }
+        if (fromWindowHandle->getInfo()->displayId != toWindowHandle->getInfo()->displayId) {
+            if (DEBUG_FOCUS) {
+                ALOGD("Cannot transfer focus because windows are on different displays.");
+            }
+            return false;
+        }
+        bool found = false;
+        for (size_t d = 0; d < mTouchStatesByDisplay.size(); d++) {
+            TouchState& state = mTouchStatesByDisplay.editValueAt(d);
+            for (size_t i = 0; i < state.windows.size(); i++) {
+                const TouchedWindow& touchedWindow = state.windows[i];
+                if (touchedWindow.windowHandle == fromWindowHandle) {
+                    int32_t oldTargetFlags = touchedWindow.targetFlags;
+                    BitSet32 pointerIds = touchedWindow.pointerIds;
+                    state.windows.erase(state.windows.begin() + i);
+                    int32_t newTargetFlags = oldTargetFlags &
+                            (InputTarget::FLAG_FOREGROUND | InputTarget::FLAG_SPLIT |
+                             InputTarget::FLAG_DISPATCH_AS_IS);
+                    state.addOrUpdateWindow(toWindowHandle, newTargetFlags, pointerIds);
+                    found = true;
+                    goto Found;
+                }
+            }
+        }
+    Found:
+        if (!found) {
+            if (DEBUG_FOCUS) {
+                ALOGD("Focus transfer failed because from window did not have focus.");
+            }
+            return false;
+        }
+        sp<Connection> fromConnection = getConnectionLocked(fromToken);
+        sp<Connection> toConnection = getConnectionLocked(toToken);
+        if (fromConnection != nullptr && toConnection != nullptr) {
+            fromConnection->inputState.mergePointerStateTo(toConnection->inputState);
+            CancelationOptions
+                    options(CancelationOptions::CANCEL_POINTER_EVENTS,
+                            "transferring touch focus from this window to another window");
+            synthesizeCancelationEventsForConnectionLocked(fromConnection, options);
+            synthesizePointerDownEventsForConnectionLocked(toConnection);
+        }
+        if (DEBUG_FOCUS) {
+            logDispatchStateLocked();
+        }
+    }
@@ -874,2 +3192,71 @@ bool InputDispatcher::waitForIdle() {
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
+    return true;
+}
+void InputDispatcher::resetAndDropEverythingLocked(const char* reason) {
+    if (DEBUG_FOCUS) {
+        ALOGD("Resetting and dropping all events (%s).", reason);
+    }
+    CancelationOptions options(CancelationOptions::CANCEL_ALL_EVENTS, reason);
+    synthesizeCancelationEventsForAllConnectionsLocked(options);
+    resetKeyRepeatLocked();
+    releasePendingEventLocked();
+    drainInboundQueueLocked();
+    resetANRTimeoutsLocked();
+    mTouchStatesByDisplay.clear();
+    mLastHoverWindowHandle.clear();
+    mReplacedKeys.clear();
+}
+void InputDispatcher::logDispatchStateLocked() {
+    std::string dump;
+    dumpDispatchStateLocked(dump);
+    std::istringstream stream(dump);
+    std::string line;
+    while (std::getline(stream, line, '\n')) {
+        ALOGD("%s", line.c_str());
+    }
+}
+void InputDispatcher::dumpDispatchStateLocked(std::string& dump) {
+    dump += StringPrintf(INDENT "DispatchEnabled: %s\n", toString(mDispatchEnabled));
+    dump += StringPrintf(INDENT "DispatchFrozen: %s\n", toString(mDispatchFrozen));
+    dump += StringPrintf(INDENT "InputFilterEnabled: %s\n", toString(mInputFilterEnabled));
+    dump += StringPrintf(INDENT "FocusedDisplayId: %" PRId32 "\n", mFocusedDisplayId);
+    if (!mFocusedApplicationHandlesByDisplay.empty()) {
+        dump += StringPrintf(INDENT "FocusedApplications:\n");
+        for (auto& it : mFocusedApplicationHandlesByDisplay) {
+            const int32_t displayId = it.first;
+            const sp<InputApplicationHandle>& applicationHandle = it.second;
+            dump += StringPrintf(INDENT2 "displayId=%" PRId32
+                                         ", name='%s', dispatchingTimeout=%0.3fms\n",
+                                 displayId, applicationHandle->getName().c_str(),
+                                 applicationHandle->getDispatchingTimeout(
+                                         DEFAULT_INPUT_DISPATCHING_TIMEOUT) /
+                                         1000000.0);
+        }
+    } else {
+        dump += StringPrintf(INDENT "FocusedApplications: <none>\n");
+    }
+    if (!mFocusedWindowHandlesByDisplay.empty()) {
+        dump += StringPrintf(INDENT "FocusedWindows:\n");
+        for (auto& it : mFocusedWindowHandlesByDisplay) {
+            const int32_t displayId = it.first;
+            const sp<InputWindowHandle>& windowHandle = it.second;
+            dump += StringPrintf(INDENT2 "displayId=%" PRId32 ", name='%s'\n", displayId,
+                                 windowHandle->getName().c_str());
+        }
+    } else {
+        dump += StringPrintf(INDENT "FocusedWindows: <none>\n");
+    }
+    if (!mTouchStatesByDisplay.isEmpty()) {
+        dump += StringPrintf(INDENT "TouchStatesByDisplay:\n");
+        for (size_t i = 0; i < mTouchStatesByDisplay.size(); i++) {
+            const TouchState& state = mTouchStatesByDisplay.valueAt(i);
+            dump += StringPrintf(INDENT2 "%d: down=%s, split=%s, deviceId=%d, source=0x%08x\n",
+                                 state.displayId, toString(state.down), toString(state.split),
+                                 state.deviceId, state.source);
+            if (!state.windows.empty()) {
+                dump += INDENT3 "Windows:\n";
+                for (size_t i = 0; i < state.windows.size(); i++) {
+                    const TouchedWindow& touchedWindow = state.windows[i];
+                    dump += StringPrintf(INDENT4
+                                         "%zu: name='%s', pointerIds=0x%0x, targetFlags=0x%x\n",
+                                         i, touchedWindow.windowHandle->getName().c_str(),
+                                         touchedWindow.pointerIds.value, touchedWindow.targetFlags);
@@ -877,6 +3264,2 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
-    mLooper->wake();
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
+            } else {
+                dump += INDENT3 "Windows: <none>\n";
@@ -884,6 +3267,6 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
-    mLooper->wake();
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
+            if (!state.portalWindows.empty()) {
+                dump += INDENT3 "Portal windows:\n";
+                for (size_t i = 0; i < state.portalWindows.size(); i++) {
+                    const sp<InputWindowHandle> portalWindowHandle = state.portalWindows[i];
+                    dump += StringPrintf(INDENT4 "%zu: name='%s'\n", i,
+                                         portalWindowHandle->getName().c_str());
@@ -891,6 +3273,0 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
-    mLooper->wake();
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
@@ -898,6 +3274,0 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
-    mLooper->wake();
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
@@ -905,6 +3276,35 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
-    mLooper->wake();
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
+    } else {
+        dump += INDENT "TouchStates: <no displays touched>\n";
+    }
+    if (!mWindowHandlesByDisplay.empty()) {
+        for (auto& it : mWindowHandlesByDisplay) {
+            const std::vector<sp<InputWindowHandle>> windowHandles = it.second;
+            dump += StringPrintf(INDENT "Display: %" PRId32 "\n", it.first);
+            if (!windowHandles.empty()) {
+                dump += INDENT2 "Windows:\n";
+                for (size_t i = 0; i < windowHandles.size(); i++) {
+                    const sp<InputWindowHandle>& windowHandle = windowHandles[i];
+                    const InputWindowInfo* windowInfo = windowHandle->getInfo();
+                    dump += StringPrintf(INDENT3 "%zu: name='%s', displayId=%d, "
+                                                 "portalToDisplayId=%d, paused=%s, hasFocus=%s, "
+                                                 "hasWallpaper=%s, visible=%s, canReceiveKeys=%s, "
+                                                 "flags=0x%08x, type=0x%08x, "
+                                                 "frame=[%d,%d][%d,%d], globalScale=%f, "
+                                                 "windowScale=(%f,%f), touchableRegion=",
+                                         i, windowInfo->name.c_str(), windowInfo->displayId,
+                                         windowInfo->portalToDisplayId,
+                                         toString(windowInfo->paused),
+                                         toString(windowInfo->hasFocus),
+                                         toString(windowInfo->hasWallpaper),
+                                         toString(windowInfo->visible),
+                                         toString(windowInfo->canReceiveKeys),
+                                         windowInfo->layoutParamsFlags,
+                                         windowInfo->layoutParamsType, windowInfo->frameLeft,
+                                         windowInfo->frameTop, windowInfo->frameRight,
+                                         windowInfo->frameBottom, windowInfo->globalScaleFactor,
+                                         windowInfo->windowXScale, windowInfo->windowYScale);
+                    dumpRegion(dump, windowInfo->touchableRegion);
+                    dump += StringPrintf(", inputFeatures=0x%08x", windowInfo->inputFeatures);
+                    dump += StringPrintf(", ownerPid=%d, ownerUid=%d, dispatchingTimeout=%0.3fms\n",
+                                         windowInfo->ownerPid, windowInfo->ownerUid,
+                                         windowInfo->dispatchingTimeout / 1000000.0);
@@ -912,6 +3312,2 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
-    mLooper->wake();
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
+            } else {
+                dump += INDENT2 "Windows: <none>\n";
@@ -919,6 +3314,0 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
-    mLooper->wake();
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
@@ -926,6 +3316,2 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
-    mLooper->wake();
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
+    } else {
+        dump += INDENT "Displays: <none>\n";
@@ -933,6 +3319,5 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
-    mLooper->wake();
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
+    if (!mGlobalMonitorsByDisplay.empty() || !mGestureMonitorsByDisplay.empty()) {
+        for (auto& it : mGlobalMonitorsByDisplay) {
+            const std::vector<Monitor>& monitors = it.second;
+            dump += StringPrintf(INDENT "Global monitors in display %" PRId32 ":\n", it.first);
+            dumpMonitors(dump, monitors);
@@ -940,6 +3325,4 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
-    mLooper->wake();
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
+        for (auto& it : mGestureMonitorsByDisplay) {
+            const std::vector<Monitor>& monitors = it.second;
+            dump += StringPrintf(INDENT "Gesture monitors in display %" PRId32 ":\n", it.first);
+            dumpMonitors(dump, monitors);
@@ -947,6 +3330,2 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
-    mLooper->wake();
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
+    } else {
+        dump += INDENT "Monitors: <none>\n";
@@ -954,6 +3333,7 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
-    mLooper->wake();
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
+    nsecs_t currentTime = now();
+    if (!mRecentQueue.empty()) {
+        dump += StringPrintf(INDENT "RecentQueue: length=%zu\n", mRecentQueue.size());
+        for (EventEntry* entry : mRecentQueue) {
+            dump += INDENT2;
+            entry->appendDescription(dump);
+            dump += StringPrintf(", age=%0.1fms\n", (currentTime - entry->eventTime) * 0.000001f);
@@ -961,6 +3341,11 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
-    mLooper->wake();
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
+    } else {
+        dump += INDENT "RecentQueue: <empty>\n";
+    }
+    if (mPendingEvent) {
+        dump += INDENT "PendingEvent:\n";
+        dump += INDENT2;
+        mPendingEvent->appendDescription(dump);
+        dump += StringPrintf(", age=%0.1fms\n",
+                             (currentTime - mPendingEvent->eventTime) * 0.000001f);
+    } else {
+        dump += INDENT "PendingEvent: <none>\n";
@@ -968,6 +3353,6 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
-    mLooper->wake();
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
+    if (!mInboundQueue.empty()) {
+        dump += StringPrintf(INDENT "InboundQueue: length=%zu\n", mInboundQueue.size());
+        for (EventEntry* entry : mInboundQueue) {
+            dump += INDENT2;
+            entry->appendDescription(dump);
+            dump += StringPrintf(", age=%0.1fms\n", (currentTime - entry->eventTime) * 0.000001f);
@@ -975,6 +3360,2 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
-    mLooper->wake();
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
+    } else {
+        dump += INDENT "InboundQueue: <empty>\n";
@@ -982,6 +3363,7 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
-    mLooper->wake();
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
+    if (!mReplacedKeys.isEmpty()) {
+        dump += INDENT "ReplacedKeys:\n";
+        for (size_t i = 0; i < mReplacedKeys.size(); i++) {
+            const KeyReplacement& replacement = mReplacedKeys.keyAt(i);
+            int32_t newKeyCode = mReplacedKeys.valueAt(i);
+            dump += StringPrintf(INDENT2 "%zu: originalKeyCode=%d, deviceId=%d, newKeyCode=%d\n", i,
+                                 replacement.keyCode, replacement.deviceId, newKeyCode);
@@ -989,6 +3371,22 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
-    mLooper->wake();
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
+    } else {
+        dump += INDENT "ReplacedKeys: <empty>\n";
+    }
+    if (!mConnectionsByFd.empty()) {
+        dump += INDENT "Connections:\n";
+        for (const auto& pair : mConnectionsByFd) {
+            const sp<Connection>& connection = pair.second;
+            dump += StringPrintf(INDENT2 "%i: channelName='%s', windowName='%s', "
+                                         "status=%s, monitor=%s, inputPublisherBlocked=%s\n",
+                                 pair.first, connection->getInputChannelName().c_str(),
+                                 connection->getWindowName().c_str(), connection->getStatusLabel(),
+                                 toString(connection->monitor),
+                                 toString(connection->inputPublisherBlocked));
+            if (!connection->outboundQueue.empty()) {
+                dump += StringPrintf(INDENT3 "OutboundQueue: length=%zu\n",
+                                     connection->outboundQueue.size());
+                for (DispatchEntry* entry : connection->outboundQueue) {
+                    dump.append(INDENT4);
+                    entry->eventEntry->appendDescription(dump);
+                    dump += StringPrintf(", targetFlags=0x%08x, resolvedAction=%d, age=%0.1fms\n",
+                                         entry->targetFlags, entry->resolvedAction,
+                                         (currentTime - entry->eventEntry->eventTime) * 0.000001f);
@@ -996,6 +3394,14 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
-    mLooper->wake();
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
+            } else {
+                dump += INDENT3 "OutboundQueue: <empty>\n";
+            }
+            if (!connection->waitQueue.empty()) {
+                dump += StringPrintf(INDENT3 "WaitQueue: length=%zu\n",
+                                     connection->waitQueue.size());
+                for (DispatchEntry* entry : connection->waitQueue) {
+                    dump += INDENT4;
+                    entry->eventEntry->appendDescription(dump);
+                    dump += StringPrintf(", targetFlags=0x%08x, resolvedAction=%d, "
+                                         "age=%0.1fms, wait=%0.1fms\n",
+                                         entry->targetFlags, entry->resolvedAction,
+                                         (currentTime - entry->eventEntry->eventTime) * 0.000001f,
+                                         (currentTime - entry->deliveryTime) * 0.000001f);
@@ -1003,6 +3409,2 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
-    mLooper->wake();
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
+            } else {
+                dump += INDENT3 "WaitQueue: <empty>\n";
@@ -1010,6 +3411,0 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
-    mLooper->wake();
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
@@ -1017,6 +3413,2 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
-    mLooper->wake();
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
+    } else {
+        dump += INDENT "Connections: <none>\n";
@@ -1024,6 +3416,5 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
-    mLooper->wake();
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
+    if (isAppSwitchPendingLocked()) {
+        dump += StringPrintf(INDENT "AppSwitch: pending, due in %0.1fms\n",
+                             (mAppSwitchDueTime - now()) / 1000000.0);
+    } else {
+        dump += INDENT "AppSwitch: not pending\n";
@@ -1031,6 +3422,4 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
-    mLooper->wake();
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
+    dump += INDENT "Configuration:\n";
+    dump += StringPrintf(INDENT2 "KeyRepeatDelay: %0.1fms\n", mConfig.keyRepeatDelay * 0.000001f);
+    dump += StringPrintf(INDENT2 "KeyRepeatTimeout: %0.1fms\n",
+                         mConfig.keyRepeatTimeout * 0.000001f);
@@ -1038,6 +3427,7 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
-    mLooper->wake();
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
+void InputDispatcher::dumpMonitors(std::string& dump, const std::vector<Monitor>& monitors) {
+    const size_t numMonitors = monitors.size();
+    for (size_t i = 0; i < numMonitors; i++) {
+        const Monitor& monitor = monitors[i];
+        const sp<InputChannel>& channel = monitor.inputChannel;
+        dump += StringPrintf(INDENT2 "%zu: '%s', ", i, channel->getName().c_str());
+        dump += "\n";
@@ -1045,6 +3434,0 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
-    mLooper->wake();
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
@@ -1052,6 +3436,11 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
-    mLooper->wake();
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
+status_t InputDispatcher::registerInputChannel(const sp<InputChannel>& inputChannel) {
+#if DEBUG_REGISTRATION
+    ALOGD("channel '%s' ~ registerInputChannel", inputChannel->getName().c_str());
+#endif
+    {
+        std::scoped_lock _l(mLock);
+        sp<Connection> existingConnection = getConnectionLocked(inputChannel->getConnectionToken());
+        if (existingConnection != nullptr) {
+            ALOGW("Attempted to register already registered input channel '%s'",
+                  inputChannel->getName().c_str());
+            return BAD_VALUE;
@@ -1059,6 +3448,5 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
-    mLooper->wake();
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
+        sp<Connection> connection = new Connection(inputChannel, false , mIdGenerator);
+        int fd = inputChannel->getFd();
+        mConnectionsByFd[fd] = connection;
+        mInputChannelsByToken[inputChannel->getConnectionToken()] = inputChannel;
+        mLooper->addFd(fd, 0, ALOOPER_EVENT_INPUT, handleReceiveCallback, this);
@@ -1066,3 +3453,0 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
@@ -1070,2 +3455 @@ bool InputDispatcher::waitForIdle() {
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
+    return OK;
@@ -1073,6 +3457,7 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
-    mLooper->wake();
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
+status_t InputDispatcher::registerInputMonitor(const sp<InputChannel>& inputChannel,
+                                               int32_t displayId, bool isGestureMonitor) {
+    {
+        std::scoped_lock _l(mLock);
+        if (displayId < 0) {
+            ALOGW("Attempted to register input monitor without a specified display.");
+            return BAD_VALUE;
@@ -1080,6 +3465,3 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
-    mLooper->wake();
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
+        if (inputChannel->getConnectionToken() == nullptr) {
+            ALOGW("Attempted to register input monitor without an identifying token.");
+            return BAD_VALUE;
@@ -1087,6 +3469,8 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
-    mLooper->wake();
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
+        sp<Connection> connection = new Connection(inputChannel, true , mIdGenerator);
+        const int fd = inputChannel->getFd();
+        mConnectionsByFd[fd] = connection;
+        mInputChannelsByToken[inputChannel->getConnectionToken()] = inputChannel;
+        auto& monitorsByDisplay =
+                isGestureMonitor ? mGestureMonitorsByDisplay : mGlobalMonitorsByDisplay;
+        monitorsByDisplay[displayId].emplace_back(inputChannel);
+        mLooper->addFd(fd, 0, ALOOPER_EVENT_INPUT, handleReceiveCallback, this);
@@ -1094,3 +3477,0 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
@@ -1098,2 +3479 @@ bool InputDispatcher::waitForIdle() {
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
+    return OK;
@@ -1101,6 +3481,9 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
-    mLooper->wake();
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
+status_t InputDispatcher::unregisterInputChannel(const sp<InputChannel>& inputChannel) {
+#if DEBUG_REGISTRATION
+    ALOGD("channel '%s' ~ unregisterInputChannel", inputChannel->getName().c_str());
+#endif
+    {
+        std::scoped_lock _l(mLock);
+        status_t status = unregisterInputChannelLocked(inputChannel, false );
+        if (status) {
+            return status;
@@ -1108,6 +3490,0 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
-    mLooper->wake();
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
@@ -1115,3 +3491,0 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
@@ -1119,2 +3493 @@ bool InputDispatcher::waitForIdle() {
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
+    return OK;
@@ -1122,6 +3495,19 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
-    mLooper->wake();
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
+status_t InputDispatcher::unregisterInputChannelLocked(const sp<InputChannel>& inputChannel,
+                                                       bool notify) {
+    sp<Connection> connection = getConnectionLocked(inputChannel->getConnectionToken());
+    if (connection == nullptr) {
+        ALOGW("Attempted to unregister already unregistered input channel '%s'",
+              inputChannel->getName().c_str());
+        return BAD_VALUE;
+    }
+    [[maybe_unused]] const bool removed = removeByValue(mConnectionsByFd, connection);
+    ALOG_ASSERT(removed);
+    mInputChannelsByToken.erase(inputChannel->getConnectionToken());
+    if (connection->monitor) {
+        removeMonitorChannelLocked(inputChannel);
+    }
+    mLooper->removeFd(inputChannel->getFd());
+    nsecs_t currentTime = now();
+    abortBrokenDispatchCycleLocked(currentTime, connection, notify);
+    connection->status = Connection::STATUS_ZOMBIE;
+    return OK;
@@ -1129,6 +3515,14 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
-    mLooper->wake();
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
+void InputDispatcher::removeMonitorChannelLocked(const sp<InputChannel>& inputChannel) {
+    removeMonitorChannelLocked(inputChannel, mGlobalMonitorsByDisplay);
+    removeMonitorChannelLocked(inputChannel, mGestureMonitorsByDisplay);
+}
+void InputDispatcher::removeMonitorChannelLocked(
+        const sp<InputChannel>& inputChannel,
+        std::unordered_map<int32_t, std::vector<Monitor>>& monitorsByDisplay) {
+    for (auto it = monitorsByDisplay.begin(); it != monitorsByDisplay.end();) {
+        std::vector<Monitor>& monitors = it->second;
+        const size_t numMonitors = monitors.size();
+        for (size_t i = 0; i < numMonitors; i++) {
+            if (monitors[i].inputChannel == inputChannel) {
+                monitors.erase(monitors.begin() + i);
+                break;
@@ -1136,6 +3529,0 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
-    mLooper->wake();
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
@@ -1143,6 +3531,5 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
-    mLooper->wake();
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
+        if (monitors.empty()) {
+            it = monitorsByDisplay.erase(it);
+        } else {
+            ++it;
+        }
@@ -1150,6 +3536,0 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
-    mLooper->wake();
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
@@ -1157,6 +3538,38 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
-    mLooper->wake();
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
+status_t InputDispatcher::pilferPointers(const sp<IBinder>& token) {
+    {
+        std::scoped_lock _l(mLock);
+        std::optional<int32_t> foundDisplayId = findGestureMonitorDisplayByTokenLocked(token);
+        if (!foundDisplayId) {
+            ALOGW("Attempted to pilfer pointers from an un-registered monitor or invalid token");
+            return BAD_VALUE;
+        }
+        int32_t displayId = foundDisplayId.value();
+        ssize_t stateIndex = mTouchStatesByDisplay.indexOfKey(displayId);
+        if (stateIndex < 0) {
+            ALOGW("Failed to pilfer pointers: no pointers on display %" PRId32 ".", displayId);
+            return BAD_VALUE;
+        }
+        TouchState& state = mTouchStatesByDisplay.editValueAt(stateIndex);
+        std::optional<int32_t> foundDeviceId;
+        for (const TouchedMonitor& touchedMonitor : state.gestureMonitors) {
+            if (touchedMonitor.monitor.inputChannel->getConnectionToken() == token) {
+                foundDeviceId = state.deviceId;
+            }
+        }
+        if (!foundDeviceId || !state.down) {
+            ALOGW("Attempted to pilfer points from a monitor without any on-going pointer streams."
+                  " Ignoring.");
+            return BAD_VALUE;
+        }
+        int32_t deviceId = foundDeviceId.value();
+        CancelationOptions options(CancelationOptions::CANCEL_POINTER_EVENTS,
+                                   "gesture monitor stole pointer stream");
+        options.deviceId = deviceId;
+        options.displayId = displayId;
+        for (const TouchedWindow& window : state.windows) {
+            sp<InputChannel> channel = getInputChannelLocked(window.windowHandle->getToken());
+            if (channel != nullptr) {
+                synthesizeCancelationEventsForInputChannelLocked(channel, options);
+            }
+        }
+        state.filterNonMonitors();
@@ -1164,6 +3577 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
-    mLooper->wake();
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
+    return OK;
@@ -1171,6 +3579,7 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
-    mLooper->wake();
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
+std::optional<int32_t> InputDispatcher::findGestureMonitorDisplayByTokenLocked(
+        const sp<IBinder>& token) {
+    for (const auto& it : mGestureMonitorsByDisplay) {
+        const std::vector<Monitor>& monitors = it.second;
+        for (const Monitor& monitor : monitors) {
+            if (monitor.inputChannel->getConnectionToken() == token) {
+                return it.first;
@@ -1178,6 +3586,0 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
-    mLooper->wake();
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
@@ -1185,6 +3587,0 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
-    mLooper->wake();
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
@@ -1192,6 +3589 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
-    mLooper->wake();
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
+    return std::nullopt;
@@ -1199,6 +3591,3 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
-    mLooper->wake();
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
+sp<Connection> InputDispatcher::getConnectionLocked(const sp<IBinder>& inputConnectionToken) {
+    if (inputConnectionToken == nullptr) {
+        return nullptr;
@@ -1206,6 +3595,4 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
-    mLooper->wake();
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
+    for (const auto& pair : mConnectionsByFd) {
+        const sp<Connection>& connection = pair.second;
+        if (connection->inputChannel->getConnectionToken() == inputConnectionToken) {
+            return connection;
@@ -1213,6 +3599,0 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
-    mLooper->wake();
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
@@ -1220,6 +3601 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
-    mLooper->wake();
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
+    return nullptr;
@@ -1227,6 +3603,130 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
-    mLooper->wake();
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
+void InputDispatcher::onDispatchCycleFinishedLocked(nsecs_t currentTime,
+                                                    const sp<Connection>& connection, uint32_t seq,
+                                                    bool handled) {
+    std::unique_ptr<CommandEntry> commandEntry = std::make_unique<CommandEntry>(
+            &InputDispatcher::doDispatchCycleFinishedLockedInterruptible);
+    commandEntry->connection = connection;
+    commandEntry->eventTime = currentTime;
+    commandEntry->seq = seq;
+    commandEntry->handled = handled;
+    postCommandLocked(std::move(commandEntry));
+}
+void InputDispatcher::onDispatchCycleBrokenLocked(nsecs_t currentTime,
+                                                  const sp<Connection>& connection) {
+    ALOGE("channel '%s' ~ Channel is unrecoverably broken and will be disposed!",
+          connection->getInputChannelName().c_str());
+    std::unique_ptr<CommandEntry> commandEntry = std::make_unique<CommandEntry>(
+            &InputDispatcher::doNotifyInputChannelBrokenLockedInterruptible);
+    commandEntry->connection = connection;
+    postCommandLocked(std::move(commandEntry));
+}
+void InputDispatcher::onFocusChangedLocked(const sp<InputWindowHandle>& oldFocus,
+                                           const sp<InputWindowHandle>& newFocus) {
+    sp<IBinder> oldToken = oldFocus != nullptr ? oldFocus->getToken() : nullptr;
+    sp<IBinder> newToken = newFocus != nullptr ? newFocus->getToken() : nullptr;
+    std::unique_ptr<CommandEntry> commandEntry = std::make_unique<CommandEntry>(
+            &InputDispatcher::doNotifyFocusChangedLockedInterruptible);
+    commandEntry->oldToken = oldToken;
+    commandEntry->newToken = newToken;
+    postCommandLocked(std::move(commandEntry));
+}
+void InputDispatcher::onANRLocked(nsecs_t currentTime,
+                                  const sp<InputApplicationHandle>& applicationHandle,
+                                  const sp<InputWindowHandle>& windowHandle, nsecs_t eventTime,
+                                  nsecs_t waitStartTime, const char* reason) {
+    float dispatchLatency = (currentTime - eventTime) * 0.000001f;
+    float waitDuration = (currentTime - waitStartTime) * 0.000001f;
+    ALOGI("Application is not responding: %s.  "
+          "It has been %0.1fms since event, %0.1fms since wait started.  Reason: %s",
+          getApplicationWindowLabel(applicationHandle, windowHandle).c_str(), dispatchLatency,
+          waitDuration, reason);
+    time_t t = time(nullptr);
+    struct tm tm;
+    localtime_r(&t, &tm);
+    char timestr[64];
+    strftime(timestr, sizeof(timestr), "%F %T", &tm);
+    mLastANRState.clear();
+    mLastANRState += INDENT "ANR:\n";
+    mLastANRState += StringPrintf(INDENT2 "Time: %s\n", timestr);
+    mLastANRState +=
+            StringPrintf(INDENT2 "Window: %s\n",
+                         getApplicationWindowLabel(applicationHandle, windowHandle).c_str());
+    mLastANRState += StringPrintf(INDENT2 "DispatchLatency: %0.1fms\n", dispatchLatency);
+    mLastANRState += StringPrintf(INDENT2 "WaitDuration: %0.1fms\n", waitDuration);
+    mLastANRState += StringPrintf(INDENT2 "Reason: %s\n", reason);
+    dumpDispatchStateLocked(mLastANRState);
+    std::unique_ptr<CommandEntry> commandEntry =
+            std::make_unique<CommandEntry>(&InputDispatcher::doNotifyANRLockedInterruptible);
+    commandEntry->inputApplicationHandle = applicationHandle;
+    commandEntry->inputChannel =
+            windowHandle != nullptr ? getInputChannelLocked(windowHandle->getToken()) : nullptr;
+    commandEntry->reason = reason;
+    postCommandLocked(std::move(commandEntry));
+}
+void InputDispatcher::doNotifyConfigurationChangedLockedInterruptible(CommandEntry* commandEntry) {
+    mLock.unlock();
+    mPolicy->notifyConfigurationChanged(commandEntry->eventTime);
+    mLock.lock();
+}
+void InputDispatcher::doNotifyInputChannelBrokenLockedInterruptible(CommandEntry* commandEntry) {
+    sp<Connection> connection = commandEntry->connection;
+    if (connection->status != Connection::STATUS_ZOMBIE) {
+        mLock.unlock();
+        mPolicy->notifyInputChannelBroken(connection->inputChannel->getConnectionToken());
+        mLock.lock();
+    }
+}
+void InputDispatcher::doNotifyFocusChangedLockedInterruptible(CommandEntry* commandEntry) {
+    sp<IBinder> oldToken = commandEntry->oldToken;
+    sp<IBinder> newToken = commandEntry->newToken;
+    mLock.unlock();
+    mPolicy->notifyFocusChanged(oldToken, newToken);
+    mLock.lock();
+}
+void InputDispatcher::doNotifyANRLockedInterruptible(CommandEntry* commandEntry) {
+    sp<IBinder> token =
+            commandEntry->inputChannel ? commandEntry->inputChannel->getConnectionToken() : nullptr;
+    mLock.unlock();
+    nsecs_t newTimeout =
+            mPolicy->notifyANR(commandEntry->inputApplicationHandle, token, commandEntry->reason);
+    mLock.lock();
+    resumeAfterTargetsNotReadyTimeoutLocked(newTimeout, token);
+}
+void InputDispatcher::doInterceptKeyBeforeDispatchingLockedInterruptible(
+        CommandEntry* commandEntry) {
+    KeyEntry* entry = commandEntry->keyEntry;
+    KeyEvent event = createKeyEvent(*entry);
+    mLock.unlock();
+    android::base::Timer t;
+    sp<IBinder> token = commandEntry->inputChannel != nullptr
+            ? commandEntry->inputChannel->getConnectionToken()
+            : nullptr;
+    nsecs_t delay = mPolicy->interceptKeyBeforeDispatching(token, &event, entry->policyFlags);
+    if (t.duration() > SLOW_INTERCEPTION_THRESHOLD) {
+        ALOGW("Excessive delay in interceptKeyBeforeDispatching; took %s ms",
+              std::to_string(t.duration().count()).c_str());
+    }
+    mLock.lock();
+    if (delay < 0) {
+        entry->interceptKeyResult = KeyEntry::INTERCEPT_KEY_RESULT_SKIP;
+    } else if (!delay) {
+        entry->interceptKeyResult = KeyEntry::INTERCEPT_KEY_RESULT_CONTINUE;
+    } else {
+        entry->interceptKeyResult = KeyEntry::INTERCEPT_KEY_RESULT_TRY_AGAIN_LATER;
+        entry->interceptKeyWakeupTime = now() + delay;
+    }
+    entry->release();
+}
+void InputDispatcher::doOnPointerDownOutsideFocusLockedInterruptible(CommandEntry* commandEntry) {
+    mLock.unlock();
+    mPolicy->onPointerDownOutsideFocus(commandEntry->newToken);
+    mLock.lock();
+}
+void InputDispatcher::doDispatchCycleFinishedLockedInterruptible(CommandEntry* commandEntry) {
+    sp<Connection> connection = commandEntry->connection;
+    const nsecs_t finishTime = commandEntry->eventTime;
+    uint32_t seq = commandEntry->seq;
+    const bool handled = commandEntry->handled;
+    std::deque<DispatchEntry*>::iterator dispatchEntryIt = connection->findWaitQueueEntry(seq);
+    if (dispatchEntryIt == connection->waitQueue.end()) {
+        return;
@@ -1234,6 +3734,31 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
-    mLooper->wake();
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
+    DispatchEntry* dispatchEntry = *dispatchEntryIt;
+    nsecs_t eventDuration = finishTime - dispatchEntry->deliveryTime;
+    if (eventDuration > SLOW_EVENT_PROCESSING_WARNING_TIMEOUT) {
+        std::string msg =
+                StringPrintf("Window '%s' spent %0.1fms processing the last input event: ",
+                             connection->getWindowName().c_str(), eventDuration * 0.000001f);
+        dispatchEntry->eventEntry->appendDescription(msg);
+        ALOGI("%s", msg.c_str());
+    }
+    bool restartEvent;
+    if (dispatchEntry->eventEntry->type == EventEntry::Type::KEY) {
+        KeyEntry* keyEntry = static_cast<KeyEntry*>(dispatchEntry->eventEntry);
+        restartEvent =
+                afterKeyEventLockedInterruptible(connection, dispatchEntry, keyEntry, handled);
+    } else if (dispatchEntry->eventEntry->type == EventEntry::Type::MOTION) {
+        MotionEntry* motionEntry = static_cast<MotionEntry*>(dispatchEntry->eventEntry);
+        restartEvent = afterMotionEventLockedInterruptible(connection, dispatchEntry, motionEntry,
+                                                           handled);
+    } else {
+        restartEvent = false;
+    }
+    dispatchEntryIt = connection->findWaitQueueEntry(seq);
+    if (dispatchEntryIt != connection->waitQueue.end()) {
+        dispatchEntry = *dispatchEntryIt;
+        connection->waitQueue.erase(dispatchEntryIt);
+        traceWaitQueueLength(connection);
+        if (restartEvent && connection->status == Connection::STATUS_NORMAL) {
+            connection->outboundQueue.push_front(dispatchEntry);
+            traceOutboundQueueLength(connection);
+        } else {
+            releaseDispatchEntry(dispatchEntry);
@@ -1241,6 +3765,0 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
-    mLooper->wake();
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
@@ -1248,6 +3767 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
-    mLooper->wake();
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
+    startDispatchCycleLocked(now(), connection);
@@ -1255,6 +3769,6 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
-    mLooper->wake();
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
+bool InputDispatcher::afterKeyEventLockedInterruptible(const sp<Connection>& connection,
+                                                       DispatchEntry* dispatchEntry,
+                                                       KeyEntry* keyEntry, bool handled) {
+    if (keyEntry->flags & AKEY_EVENT_FLAG_FALLBACK) {
+        if (!handled) {
+            mReporter->reportUnhandledKey(keyEntry->id);
@@ -1262,6 +3776 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
-    mLooper->wake();
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
+        return false;
@@ -1269,6 +3778,28 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
-    mLooper->wake();
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
+    int32_t originalKeyCode = keyEntry->keyCode;
+    int32_t fallbackKeyCode = connection->inputState.getFallbackKey(originalKeyCode);
+    if (keyEntry->action == AKEY_EVENT_ACTION_UP) {
+        connection->inputState.removeFallbackKey(originalKeyCode);
+    }
+    if (handled || !dispatchEntry->hasForegroundTarget()) {
+        if (fallbackKeyCode != -1) {
+#if DEBUG_OUTBOUND_EVENT_DETAILS
+            ALOGD("Unhandled key event: Asking policy to cancel fallback action.  "
+                  "keyCode=%d, action=%d, repeatCount=%d, policyFlags=0x%08x",
+                  keyEntry->keyCode, keyEntry->action, keyEntry->repeatCount,
+                  keyEntry->policyFlags);
+#endif
+            KeyEvent event = createKeyEvent(*keyEntry);
+            event.setFlags(event.getFlags() | AKEY_EVENT_FLAG_CANCELED);
+            mLock.unlock();
+            mPolicy->dispatchUnhandledKey(connection->inputChannel->getConnectionToken(), &event,
+                                          keyEntry->policyFlags, &event);
+            mLock.lock();
+            if (fallbackKeyCode != AKEYCODE_UNKNOWN) {
+                CancelationOptions options(CancelationOptions::CANCEL_FALLBACK_EVENTS,
+                                           "application handled the original non-fallback key "
+                                           "or is no longer a foreground target, "
+                                           "canceling previously dispatched fallback key");
+                options.keyCode = fallbackKeyCode;
+                synthesizeCancelationEventsForConnectionLocked(connection, options);
+            }
+            connection->inputState.removeFallbackKey(originalKeyCode);
@@ -1276,6 +3807,10 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
-    mLooper->wake();
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
+    } else {
+        bool initialDown = keyEntry->action == AKEY_EVENT_ACTION_DOWN && keyEntry->repeatCount == 0;
+        if (fallbackKeyCode == -1 && !initialDown) {
+#if DEBUG_OUTBOUND_EVENT_DETAILS
+            ALOGD("Unhandled key event: Skipping unhandled key event processing "
+                  "since this is not an initial down.  "
+                  "keyCode=%d, action=%d, repeatCount=%d, policyFlags=0x%08x",
+                  originalKeyCode, keyEntry->action, keyEntry->repeatCount, keyEntry->policyFlags);
+#endif
+            return false;
@@ -1283,6 +3818,14 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
-    mLooper->wake();
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
+#if DEBUG_OUTBOUND_EVENT_DETAILS
+        ALOGD("Unhandled key event: Asking policy to perform fallback action.  "
+              "keyCode=%d, action=%d, repeatCount=%d, policyFlags=0x%08x",
+              keyEntry->keyCode, keyEntry->action, keyEntry->repeatCount, keyEntry->policyFlags);
+#endif
+        KeyEvent event = createKeyEvent(*keyEntry);
+        mLock.unlock();
+        bool fallback =
+                mPolicy->dispatchUnhandledKey(connection->inputChannel->getConnectionToken(),
+                                              &event, keyEntry->policyFlags, &event);
+        mLock.lock();
+        if (connection->status != Connection::STATUS_NORMAL) {
+            connection->inputState.removeFallbackKey(originalKeyCode);
+            return false;
@@ -1290,6 +3833,22 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
-    mLooper->wake();
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
+        if (initialDown) {
+            if (fallback) {
+                fallbackKeyCode = event.getKeyCode();
+            } else {
+                fallbackKeyCode = AKEYCODE_UNKNOWN;
+            }
+            connection->inputState.setFallbackKey(originalKeyCode, fallbackKeyCode);
+        }
+        ALOG_ASSERT(fallbackKeyCode != -1);
+        if (fallbackKeyCode != AKEYCODE_UNKNOWN &&
+            (!fallback || fallbackKeyCode != event.getKeyCode())) {
+#if DEBUG_OUTBOUND_EVENT_DETAILS
+            if (fallback) {
+                ALOGD("Unhandled key event: Policy requested to send key %d"
+                      "as a fallback for %d, but on the DOWN it had requested "
+                      "to send %d instead.  Fallback canceled.",
+                      event.getKeyCode(), originalKeyCode, fallbackKeyCode);
+            } else {
+                ALOGD("Unhandled key event: Policy did not request fallback for %d, "
+                      "but on the DOWN it had requested to send %d.  "
+                      "Fallback canceled.",
+                      originalKeyCode, fallbackKeyCode);
@@ -1297,6 +3856,9 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
-    mLooper->wake();
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
+#endif
+            CancelationOptions options(CancelationOptions::CANCEL_FALLBACK_EVENTS,
+                                       "canceling fallback, policy no longer desires it");
+            options.keyCode = fallbackKeyCode;
+            synthesizeCancelationEventsForConnectionLocked(connection, options);
+            fallback = false;
+            fallbackKeyCode = AKEYCODE_UNKNOWN;
+            if (keyEntry->action != AKEY_EVENT_ACTION_UP) {
+                connection->inputState.setFallbackKey(originalKeyCode, fallbackKeyCode);
@@ -1304,6 +3865,0 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
-    mLooper->wake();
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
@@ -1311,6 +3867,7 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
-    mLooper->wake();
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
+#if DEBUG_OUTBOUND_EVENT_DETAILS
+        {
+            std::string msg;
+            const KeyedVector<int32_t, int32_t>& fallbackKeys =
+                    connection->inputState.getFallbackKeys();
+            for (size_t i = 0; i < fallbackKeys.size(); i++) {
+                msg += StringPrintf(", %d->%d", fallbackKeys.keyAt(i), fallbackKeys.valueAt(i));
@@ -1318,6 +3875,2 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
-    mLooper->wake();
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
+            ALOGD("Unhandled key event: %zu currently tracked fallback keys%s.",
+                  fallbackKeys.size(), msg.c_str());
@@ -1325,6 +3878,24 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
-    mLooper->wake();
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
+#endif
+        if (fallback) {
+            keyEntry->eventTime = event.getEventTime();
+            keyEntry->deviceId = event.getDeviceId();
+            keyEntry->source = event.getSource();
+            keyEntry->displayId = event.getDisplayId();
+            keyEntry->flags = event.getFlags() | AKEY_EVENT_FLAG_FALLBACK;
+            keyEntry->keyCode = fallbackKeyCode;
+            keyEntry->scanCode = event.getScanCode();
+            keyEntry->metaState = event.getMetaState();
+            keyEntry->repeatCount = event.getRepeatCount();
+            keyEntry->downTime = event.getDownTime();
+            keyEntry->syntheticRepeat = false;
+#if DEBUG_OUTBOUND_EVENT_DETAILS
+            ALOGD("Unhandled key event: Dispatching fallback key.  "
+                  "originalKeyCode=%d, fallbackKeyCode=%d, fallbackMetaState=%08x",
+                  originalKeyCode, fallbackKeyCode, keyEntry->metaState);
+#endif
+            return true;
+        } else {
+#if DEBUG_OUTBOUND_EVENT_DETAILS
+            ALOGD("Unhandled key event: No fallback key.");
+#endif
+            mReporter->reportUnhandledKey(keyEntry->id);
@@ -1332,6 +3902,0 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
-    mLooper->wake();
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
@@ -1339,6 +3904 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
-    mLooper->wake();
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
+    return false;
@@ -1346,6 +3906,4 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
-    mLooper->wake();
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
+bool InputDispatcher::afterMotionEventLockedInterruptible(const sp<Connection>& connection,
+                                                          DispatchEntry* dispatchEntry,
+                                                          MotionEntry* motionEntry, bool handled) {
+    return false;
@@ -1353,6 +3911,4 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
-    mLooper->wake();
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
+void InputDispatcher::doPokeUserActivityLockedInterruptible(CommandEntry* commandEntry) {
+    mLock.unlock();
+    mPolicy->pokeUserActivity(commandEntry->eventTime, commandEntry->userActivityEventType);
+    mLock.lock();
@@ -1360,6 +3916,10 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
-    mLooper->wake();
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
+KeyEvent InputDispatcher::createKeyEvent(const KeyEntry& entry) {
+    KeyEvent event;
+    event.initialize(entry.id, entry.deviceId, entry.source, entry.displayId, INVALID_HMAC,
+                     entry.action, entry.flags, entry.keyCode, entry.scanCode, entry.metaState,
+                     entry.repeatCount, entry.downTime, entry.eventTime);
+    return event;
+}
+void InputDispatcher::updateDispatchStatistics(nsecs_t currentTime, const EventEntry& entry,
+                                               int32_t injectionResult,
+                                               nsecs_t timeSpentWaitingForApplication) {
@@ -1383,6 +3943,3 @@ void InputDispatcher::reportTouchEventForStatistics(const MotionEntry& motionEnt
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
-    mLooper->wake();
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
+void InputDispatcher::traceInboundQueueLengthLocked() {
+    if (ATRACE_ENABLED()) {
+        ATRACE_INT("iq", mInboundQueue.size());
@@ -1390,6 +3946,0 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
-    mLooper->wake();
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
@@ -1397,6 +3948,5 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
-    mLooper->wake();
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
+void InputDispatcher::traceOutboundQueueLength(const sp<Connection>& connection) {
+    if (ATRACE_ENABLED()) {
+        char counterName[40];
+        snprintf(counterName, sizeof(counterName), "oq:%s", connection->getWindowName().c_str());
+        ATRACE_INT(counterName, connection->outboundQueue.size());
@@ -1404,6 +3953,0 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
-    mLooper->wake();
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
@@ -1411,3 +3955,18 @@ bool InputDispatcher::waitForIdle() {
-bool InputDispatcher::waitForIdle() {
-    constexpr std::chrono::duration TIMEOUT = 100ms;
-    std::unique_lock lock(mLock);
+void InputDispatcher::traceWaitQueueLength(const sp<Connection>& connection) {
+    if (ATRACE_ENABLED()) {
+        char counterName[40];
+        snprintf(counterName, sizeof(counterName), "wq:%s", connection->getWindowName().c_str());
+        ATRACE_INT(counterName, connection->waitQueue.size());
+    }
+}
+void InputDispatcher::dump(std::string& dump) {
+    std::scoped_lock _l(mLock);
+    dump += "Input Dispatcher State:\n";
+    dumpDispatchStateLocked(dump);
+    if (!mLastANRState.empty()) {
+        dump += "\nInput Dispatcher State at time of last ANR:\n";
+        dump += mLastANRState;
+    }
+}
+void InputDispatcher::monitor() {
+    std::unique_lock _l(mLock);
@@ -1415,2 +3974 @@ bool InputDispatcher::waitForIdle() {
-    std::cv_status result = mDispatcherEnteredIdle.wait_for(lock, TIMEOUT);
-    return result == std::cv_status::no_timeout;
+    mDispatcherIsAlive.wait(_l);
