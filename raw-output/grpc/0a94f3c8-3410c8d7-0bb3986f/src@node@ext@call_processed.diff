--- a/output/grpc/0a94f3c8-3410c8d7-0bb3986f/src@node@ext@call.no_comments_mergebot.cc
+++ b/output/grpc/0a94f3c8-3410c8d7-0bb3986f/src@node@ext@call.no_comments_truth.cc
@@ -44 +44 @@ using v8::Value;
-Persistent<FunctionTemplate> Call::fun_tpl;
+Callback *Call::constructor;
@@ -373,3 +372,0 @@ tag::~tag() {
-}{
-  delete callback;
-  delete ops;
@@ -420,7 +417 @@ Call::Call(grpc_call *call)
-    : wrapped_call(call), pending_batches(0), has_final_op_completed(false) <<<<<<< HEAD
-{}
-||||||| 0bb3986ffa
-{
-}
-=======
-{
+    : wrapped_call(call), pending_batches(0), has_final_op_completed(false) {
@@ -429,9 +420 @@ Call::Call(grpc_call *call)
->>>>>>> 3410c8d7
-Call::~Call() <<<<<<< HEAD
-{ DestroyCall(); }
-||||||| 0bb3986ffa
-{
-  DestroyCall();
-}
-=======
-{
+Call::~Call() {
@@ -441 +423,0 @@ Call::~Call() <<<<<<< HEAD
->>>>>>> 3410c8d7
@@ -486,3 +468,15 @@ void Call::CompleteBatch(bool is_final_op) {
-NAN_METHOD(Call::SetCredentials) {
-  Nan::HandleScope scope;
-  if (!HasInstance(info.This())) {
+NAN_METHOD(Call::New) {
+  if (info.IsConstructCall()) {
+    Call *call;
+    if (info[0]->IsExternal()) {
+      Local<External> ext = info[0].As<External>();
+      grpc_call *call_value = reinterpret_cast<grpc_call *>(ext->Value());
+      call = new Call(call_value);
+    } else {
+      if (!Channel::HasInstance(info[0])) {
+        return Nan::ThrowTypeError("Call's first argument must be a Channel");
+      }
+      if (!info[1]->IsString()) {
+        return Nan::ThrowTypeError("Call's second argument must be a string");
+      }
+      if (!(info[2]->IsNumber() || info[2]->IsDate())) {
@@ -490 +484,10 @@ NAN_METHOD(Call::SetCredentials) {
-        "setCredentials can only be called on Call objects");
+            "Call's third argument must be a date or a number");
+      }
+      grpc_call *parent_call = NULL;
+      if (Call::HasInstance(info[4])) {
+        Call *parent_obj =
+            ObjectWrap::Unwrap<Call>(Nan::To<Object>(info[4]).ToLocalChecked());
+        parent_call = parent_obj->wrapped_call;
+      } else if (!(info[4]->IsUndefined() || info[4]->IsNull())) {
+        return Nan::ThrowTypeError(
+            "Call's fifth argument must be another call, if provided");
@@ -492 +495,4 @@ NAN_METHOD(Call::SetCredentials) {
-  if (!CallCredentials::HasInstance(info[0])) {
+      uint32_t propagate_flags = GRPC_PROPAGATE_DEFAULTS;
+      if (info[5]->IsUint32()) {
+        propagate_flags = Nan::To<uint32_t>(info[5]).FromJust();
+      } else if (!(info[5]->IsUndefined() || info[5]->IsNull())) {
@@ -494 +500,26 @@ NAN_METHOD(Call::SetCredentials) {
-        "setCredentials' first argument must be a CallCredentials");
+            "Call's sixth argument must be propagate flags, if provided");
+      }
+      Local<Object> channel_object = Nan::To<Object>(info[0]).ToLocalChecked();
+      Channel *channel = ObjectWrap::Unwrap<Channel>(channel_object);
+      if (channel->GetWrappedChannel() == NULL) {
+        return Nan::ThrowError("Call cannot be created from a closed channel");
+      }
+      double deadline = Nan::To<double>(info[2]).FromJust();
+      grpc_channel *wrapped_channel = channel->GetWrappedChannel();
+      grpc_call *wrapped_call;
+      grpc_slice method =
+          CreateSliceFromString(Nan::To<String>(info[1]).ToLocalChecked());
+      if (info[3]->IsString()) {
+        grpc_slice *host = new grpc_slice;
+        *host =
+            CreateSliceFromString(Nan::To<String>(info[3]).ToLocalChecked());
+        wrapped_call = grpc_channel_create_call(
+            wrapped_channel, parent_call, propagate_flags, GetCompletionQueue(),
+            method, host, MillisecondsToTimespec(deadline), NULL);
+        delete host;
+      } else if (info[3]->IsUndefined() || info[3]->IsNull()) {
+        wrapped_call = grpc_channel_create_call(
+            wrapped_channel, parent_call, propagate_flags, GetCompletionQueue(),
+            method, NULL, MillisecondsToTimespec(deadline), NULL);
+      } else {
+        return Nan::ThrowTypeError("Call's fourth argument must be a string");
@@ -496,7 +527,4 @@ NAN_METHOD(Call::SetCredentials) {
-  Call *call = ObjectWrap::Unwrap<Call>(info.This());
-  CallCredentials *creds_object = ObjectWrap::Unwrap<CallCredentials>(
-      Nan::To<Object>(info[0]).ToLocalChecked());
-  grpc_call_credentials *creds = creds_object->GetWrappedCredentials();
-  grpc_call_error error = GRPC_CALL_ERROR;
-  if (creds) {
-    error = grpc_call_set_credentials(call->wrapped_call, creds);
+      grpc_slice_unref(method);
+      call = new Call(wrapped_call);
+      Nan::Set(info.This(), Nan::New("channel_").ToLocalChecked(),
+               channel_object);
@@ -504 +532,11 @@ NAN_METHOD(Call::SetCredentials) {
-  info.GetReturnValue().Set(Nan::New<Uint32>(error));
+    call->Wrap(info.This());
+    info.GetReturnValue().Set(info.This());
+  } else {
+    const int argc = 4;
+    Local<Value> argv[argc] = {info[0], info[1], info[2], info[3]};
+    MaybeLocal<Object> maybe_instance =
+        Nan::NewInstance(constructor->GetFunction(), argc, argv);
+    if (maybe_instance.IsEmpty()) {
+      return;
+    } else {
+      info.GetReturnValue().Set(maybe_instance.ToLocalChecked());
@@ -506,5 +543,0 @@ NAN_METHOD(Call::SetCredentials) {
-NAN_METHOD(Call::SetCredentials) {
-  Nan::HandleScope scope;
-  if (!HasInstance(info.This())) {
-    return Nan::ThrowTypeError(
-        "setCredentials can only be called on Call objects");
@@ -512,3 +544,0 @@ NAN_METHOD(Call::SetCredentials) {
-  if (!CallCredentials::HasInstance(info[0])) {
-    return Nan::ThrowTypeError(
-        "setCredentials' first argument must be a CallCredentials");
@@ -516,7 +546,3 @@ NAN_METHOD(Call::SetCredentials) {
-  Call *call = ObjectWrap::Unwrap<Call>(info.This());
-  CallCredentials *creds_object = ObjectWrap::Unwrap<CallCredentials>(
-      Nan::To<Object>(info[0]).ToLocalChecked());
-  grpc_call_credentials *creds = creds_object->GetWrappedCredentials();
-  grpc_call_error error = GRPC_CALL_ERROR;
-  if (creds) {
-    error = grpc_call_set_credentials(call->wrapped_call, creds);
+NAN_METHOD(Call::StartBatch) {
+  if (!Call::HasInstance(info.This())) {
+    return Nan::ThrowTypeError("startBatch can only be called on Call objects");
@@ -524 +550,2 @@ NAN_METHOD(Call::SetCredentials) {
-  info.GetReturnValue().Set(Nan::New<Uint32>(error));
+  if (!info[0]->IsObject()) {
+    return Nan::ThrowError("startBatch's first argument must be an object");
@@ -526,5 +553,2 @@ NAN_METHOD(Call::SetCredentials) {
-NAN_METHOD(Call::SetCredentials) {
-  Nan::HandleScope scope;
-  if (!HasInstance(info.This())) {
-    return Nan::ThrowTypeError(
-        "setCredentials can only be called on Call objects");
+  if (!info[1]->IsFunction()) {
+    return Nan::ThrowError("startBatch's second argument must be a callback");
@@ -532,3 +556,70 @@ NAN_METHOD(Call::SetCredentials) {
-  if (!CallCredentials::HasInstance(info[0])) {
-    return Nan::ThrowTypeError(
-        "setCredentials' first argument must be a CallCredentials");
+  Local<Function> callback_func = info[1].As<Function>();
+  Call *call = ObjectWrap::Unwrap<Call>(info.This());
+  if (call->wrapped_call == NULL) {
+    Local<Value> argv[] = {
+        Nan::Error("The async function failed because the call has completed")};
+    Nan::Call(callback_func, Nan::New<Object>(), 1, argv);
+    return;
+  }
+  Local<Object> obj = Nan::To<Object>(info[0]).ToLocalChecked();
+  Local<Array> keys = Nan::GetOwnPropertyNames(obj).ToLocalChecked();
+  size_t nops = keys->Length();
+  vector<grpc_op> ops(nops);
+  unique_ptr<OpVec> op_vector(new OpVec());
+  for (unsigned int i = 0; i < nops; i++) {
+    unique_ptr<Op> op;
+    MaybeLocal<Value> maybe_key = Nan::Get(keys, i);
+    if (maybe_key.IsEmpty() || (!maybe_key.ToLocalChecked()->IsUint32())) {
+      return Nan::ThrowError(
+          "startBatch's first argument's keys must be integers");
+    }
+    uint32_t type = Nan::To<uint32_t>(maybe_key.ToLocalChecked()).FromJust();
+    ops[i].op = static_cast<grpc_op_type>(type);
+    ops[i].flags = 0;
+    ops[i].reserved = NULL;
+    switch (type) {
+      case GRPC_OP_SEND_INITIAL_METADATA:
+        op.reset(new SendMetadataOp());
+        break;
+      case GRPC_OP_SEND_MESSAGE:
+        op.reset(new SendMessageOp());
+        break;
+      case GRPC_OP_SEND_CLOSE_FROM_CLIENT:
+        op.reset(new SendClientCloseOp());
+        break;
+      case GRPC_OP_SEND_STATUS_FROM_SERVER:
+        op.reset(new SendServerStatusOp());
+        break;
+      case GRPC_OP_RECV_INITIAL_METADATA:
+        op.reset(new GetMetadataOp());
+        break;
+      case GRPC_OP_RECV_MESSAGE:
+        op.reset(new ReadMessageOp());
+        break;
+      case GRPC_OP_RECV_STATUS_ON_CLIENT:
+        op.reset(new ClientStatusOp());
+        break;
+      case GRPC_OP_RECV_CLOSE_ON_SERVER:
+        op.reset(new ServerCloseResponseOp());
+        break;
+      default:
+        return Nan::ThrowError("Argument object had an unrecognized key");
+    }
+    if (!op->ParseOp(obj->Get(type), &ops[i])) {
+      return Nan::ThrowTypeError("Incorrectly typed arguments to startBatch");
+    }
+    op_vector->push_back(std::move(op));
+  }
+  Callback *callback = new Callback(callback_func);
+  grpc_call_error error = grpc_call_start_batch(
+      call->wrapped_call, &ops[0], nops,
+      new struct tag(callback, op_vector.release(), call, info.This()), NULL);
+  if (error != GRPC_CALL_OK) {
+    return Nan::ThrowError(nanErrorWithCode("startBatch failed", error));
+  }
+  call->pending_batches++;
+  CompletionQueueNext();
+}
+NAN_METHOD(Call::Cancel) {
+  if (!Call::HasInstance(info.This())) {
+    return Nan::ThrowTypeError("cancel can only be called on Call objects");
@@ -537,6 +628,2 @@ NAN_METHOD(Call::SetCredentials) {
-  CallCredentials *creds_object = ObjectWrap::Unwrap<CallCredentials>(
-      Nan::To<Object>(info[0]).ToLocalChecked());
-  grpc_call_credentials *creds = creds_object->GetWrappedCredentials();
-  grpc_call_error error = GRPC_CALL_ERROR;
-  if (creds) {
-    error = grpc_call_set_credentials(call->wrapped_call, creds);
+  if (call->wrapped_call == NULL) {
+    return;
@@ -544 +631,3 @@ NAN_METHOD(Call::SetCredentials) {
-  info.GetReturnValue().Set(Nan::New<Uint32>(error));
+  grpc_call_error error = grpc_call_cancel(call->wrapped_call, NULL);
+  if (error != GRPC_CALL_OK) {
+    return Nan::ThrowError(nanErrorWithCode("cancel failed", error));
@@ -546 +635,2 @@ NAN_METHOD(Call::SetCredentials) {
-NAN_METHOD(Call::SetCredentials) {
+}
+NAN_METHOD(Call::CancelWithStatus) {
@@ -548,0 +639,3 @@ NAN_METHOD(Call::SetCredentials) {
+    return Nan::ThrowTypeError("cancel can only be called on Call objects");
+  }
+  if (!info[0]->IsUint32()) {
@@ -550 +643 @@ NAN_METHOD(Call::SetCredentials) {
-        "setCredentials can only be called on Call objects");
+        "cancelWithStatus's first argument must be a status code");
@@ -552 +645 @@ NAN_METHOD(Call::SetCredentials) {
-  if (!CallCredentials::HasInstance(info[0])) {
+  if (!info[1]->IsString()) {
@@ -554 +647 @@ NAN_METHOD(Call::SetCredentials) {
-        "setCredentials' first argument must be a CallCredentials");
+        "cancelWithStatus's second argument must be a string");
@@ -557,6 +650,2 @@ NAN_METHOD(Call::SetCredentials) {
-  CallCredentials *creds_object = ObjectWrap::Unwrap<CallCredentials>(
-      Nan::To<Object>(info[0]).ToLocalChecked());
-  grpc_call_credentials *creds = creds_object->GetWrappedCredentials();
-  grpc_call_error error = GRPC_CALL_ERROR;
-  if (creds) {
-    error = grpc_call_set_credentials(call->wrapped_call, creds);
+  if (call->wrapped_call == NULL) {
+    return;
@@ -564 +653,5 @@ NAN_METHOD(Call::SetCredentials) {
-  info.GetReturnValue().Set(Nan::New<Uint32>(error));
+  grpc_status_code code =
+      static_cast<grpc_status_code>(Nan::To<uint32_t>(info[0]).FromJust());
+  if (code == GRPC_STATUS_OK) {
+    return Nan::ThrowRangeError(
+        "cancelWithStatus cannot be called with OK status");
@@ -566 +659,4 @@ NAN_METHOD(Call::SetCredentials) {
-NAN_METHOD(Call::SetCredentials) {
+  Utf8String details(info[1]);
+  grpc_call_cancel_with_status(call->wrapped_call, code, *details, NULL);
+}
+NAN_METHOD(Call::GetPeer) {
@@ -569,6 +665 @@ NAN_METHOD(Call::SetCredentials) {
-    return Nan::ThrowTypeError(
-        "setCredentials can only be called on Call objects");
-  }
-  if (!CallCredentials::HasInstance(info[0])) {
-    return Nan::ThrowTypeError(
-        "setCredentials' first argument must be a CallCredentials");
+    return Nan::ThrowTypeError("getPeer can only be called on Call objects");
@@ -577,8 +668,2 @@ NAN_METHOD(Call::SetCredentials) {
-  CallCredentials *creds_object = ObjectWrap::Unwrap<CallCredentials>(
-      Nan::To<Object>(info[0]).ToLocalChecked());
-  grpc_call_credentials *creds = creds_object->GetWrappedCredentials();
-  grpc_call_error error = GRPC_CALL_ERROR;
-  if (creds) {
-    error = grpc_call_set_credentials(call->wrapped_call, creds);
-  }
-  info.GetReturnValue().Set(Nan::New<Uint32>(error));
+  Local<Value> peer_value = Nan::New(call->peer).ToLocalChecked();
+  info.GetReturnValue().Set(peer_value);
@@ -596,0 +682,4 @@ NAN_METHOD(Call::SetCredentials) {
+  if (call->wrapped_call == NULL) {
+    return Nan::ThrowError(
+        "Cannot set credentials on a call that has already started");
+  }
