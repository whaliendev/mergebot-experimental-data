diff --git a/output/grpc/566316f3-9b5da208-4a92bc3c/src@core@surface@call.no_comments_mergebot.c b/output/grpc/566316f3-9b5da208-4a92bc3c/src@core@surface@call.no_comments_truth.c
index 08b70e3..6b6c57f 100644
--- a/output/grpc/566316f3-9b5da208-4a92bc3c/src@core@surface@call.no_comments_mergebot.c
+++ b/output/grpc/566316f3-9b5da208-4a92bc3c/src@core@surface@call.no_comments_truth.c
@@ -16,2 +16,9 @@ typedef struct legacy_state legacy_state;
-#define INVALID_TAG ((void *)0xdeadbeef)
-#define INITIAL_PENDING_READ_COUNT 4
+static void destroy_legacy_state(legacy_state *ls);
+typedef enum { REQ_INITIAL = 0, REQ_READY, REQ_DONE } req_state;
+typedef enum {
+  SEND_NOTHING,
+  SEND_INITIAL_METADATA,
+  SEND_MESSAGE,
+  SEND_TRAILING_METADATA_AND_FINISH,
+  SEND_FINISH
+} send_action;
@@ -19 +26 @@ typedef struct {
-  grpc_byte_buffer *byte_buffer;
+  grpc_ioreq_completion_func on_complete;
@@ -21,7 +28,18 @@ typedef struct {
-  void (*on_finish)(void *user_data, grpc_op_error error);
-} pending_read;
-typedef struct {
-  pending_read *data;
-  size_t count;
-  size_t capacity;
-} pending_read_array;
+  grpc_op_error status;
+} completed_request;
+#define REQSET_EMPTY 255
+#define REQSET_DONE 254
+typedef struct reqinfo {
+  grpc_ioreq_data data;
+  gpr_uint8 set;
+  grpc_op_error status;
+  grpc_ioreq_completion_func on_complete;
+  void *user_data;
+  gpr_uint32 need_mask;
+  gpr_uint32 complete_mask;
+} reqinfo;
+typedef enum {
+  STATUS_FROM_API_OVERRIDE = 0,
+  STATUS_FROM_WIRE,
+  STATUS_SOURCE_COUNT
+} status_source;
@@ -29,4 +47,4 @@ typedef struct {
-  size_t drain_pos;
-  pending_read_array filling;
-  pending_read_array draining;
-} pending_read_queue;
+  gpr_uint8 set;
+  grpc_status_code code;
+  grpc_mdstr *details;
+} received_status;
@@ -58,0 +77,12 @@ struct grpc_call {
+#define CALL_STACK_FROM_CALL(call) ((grpc_call_stack *)((call)+1))
+#define CALL_FROM_CALL_STACK(call_stack) (((grpc_call *)(call_stack)) - 1)
+#define CALL_ELEM_FROM_CALL(call,idx) \
+  grpc_call_stack_element(CALL_STACK_FROM_CALL(call), idx)
+#define CALL_FROM_TOP_ELEM(top_elem) \
+  CALL_FROM_CALL_STACK(grpc_call_stack_from_top_element(top_elem))
+#define SWAP(type,x,y) \
+  do { \
+    type temp = x; \
+    x = y; \
+    y = temp; \
+  } while (0)
@@ -118 +148,2 @@ void grpc_call_internal_unref(grpc_call *c, int allow_immediate_deletion) {
-static void set_status_code(grpc_call *call, status_source source, gpr_uint32 status) {
+static void set_status_code(grpc_call *call, status_source source,
+                            gpr_uint32 status) {
@@ -122 +153,2 @@ static void set_status_code(grpc_call *call, status_source source, gpr_uint32 st
-static void set_status_details(grpc_call *call, status_source source, grpc_mdstr *status) {
+static void set_status_details(grpc_call *call, status_source source,
+                               grpc_mdstr *status) {
@@ -133,142 +164,0 @@ static grpc_call_error bind_cq(grpc_call *call, grpc_completion_queue *cq) {
-void grpc_call_destroy(grpc_call *c) {
-  int cancel;
-  lock(c);
-  if (c->have_alarm) {
-    grpc_alarm_cancel(&c->alarm);
-    c->have_alarm = 0;
-  }
-  cancel = !c->stream_closed;
-  unlock(c);
-  if (cancel) grpc_call_cancel(c);
-  grpc_call_internal_unref(c, 1);
-}
-grpc_call_error grpc_call_cancel(grpc_call *c) {
-  grpc_call_element *elem;
-  grpc_call_op op;
-  op.type = GRPC_CANCEL_OP;
-  op.dir = GRPC_CALL_DOWN;
-  op.flags = 0;
-  op.done_cb = do_nothing;
-  op.user_data = NULL;
-  elem = CALL_ELEM_FROM_CALL(c, 0);
-  elem->filter->call_op(elem, NULL, &op);
-  return GRPC_CALL_OK;
-}
-grpc_call_error grpc_call_cancel_with_status(grpc_call *c,
-                                             grpc_status_code status,
-                                             const char *description) {
-  grpc_mdstr *details =
-      description ? grpc_mdstr_from_string(c->metadata_context, description)
-                  : NULL;
-  lock(c);
-  set_status_code(c, STATUS_FROM_API_OVERRIDE, status);
-  set_status_details(c, STATUS_FROM_API_OVERRIDE, details);
-  unlock(c);
-  return grpc_call_cancel(c);
-}
-void grpc_call_execute_op(grpc_call *call, grpc_call_op *op) {
-  grpc_call_element *elem;
-  GPR_ASSERT(op->dir == GRPC_CALL_DOWN);
-  elem = CALL_ELEM_FROM_CALL(call, 0);
-  elem->filter->call_op(elem, NULL, op);
-}
-grpc_call_error grpc_call_add_metadata_old(grpc_call *call, grpc_metadata *metadata, gpr_uint32 flags) {
-  grpc_mdelem *mdelem;
-  if (call->is_client) {
-    if (call->state >= CALL_STARTED) {
-      return GRPC_CALL_ERROR_ALREADY_INVOKED;
-    }
-  } else {
-    if (call->state >= CALL_FINISHED) {
-      return GRPC_CALL_ERROR_ALREADY_FINISHED;
-    }
-  }
-  mdelem = grpc_mdelem_from_string_and_buffer(
-      call->metadata_context, metadata->key, (gpr_uint8 *)metadata->value,
-      metadata->value_length);
-  grpc_call_add_mdelem(call, mdelem, flags);
-  return GRPC_CALL_OK;
-}
-grpc_call_error grpc_call_invoke_old(grpc_call *call, grpc_completion_queue *cq,
-                                     void *metadata_read_tag,
-                                     void *finished_tag, gpr_uint32 flags) {
-  grpc_ioreq reqs[3];
-  legacy_state *ls;
-  grpc_call_error err;
-  grpc_cq_begin_op(cq, call, GRPC_CLIENT_METADATA_READ);
-  grpc_cq_begin_op(cq, call, GRPC_FINISHED);
-  lock(call);
-  ls = get_legacy_state(call);
-  err = bind_cq(call, cq);
-  if (err != GRPC_CALL_OK) goto done;
-  ls->finished_tag = finished_tag;
-  reqs[0].op = GRPC_IOREQ_SEND_INITIAL_METADATA;
-  reqs[0].data.send_metadata.count = ls->md_out_count[ls->md_out_buffer];
-  reqs[0].data.send_metadata.metadata = ls->md_out[ls->md_out_buffer];
-  ls->md_out_buffer++;
-  err = start_ioreq(call, reqs, 1, finish_send_metadata, NULL);
-  if (err != GRPC_CALL_OK) goto done;
-  reqs[0].op = GRPC_IOREQ_RECV_INITIAL_METADATA;
-  reqs[0].data.recv_metadata = &ls->initial_md_in;
-  err = start_ioreq(call, reqs, 1, finish_recv_metadata, metadata_read_tag);
-  if (err != GRPC_CALL_OK) goto done;
-  reqs[0].op = GRPC_IOREQ_RECV_TRAILING_METADATA;
-  reqs[0].data.recv_metadata = &ls->trailing_md_in;
-  reqs[1].op = GRPC_IOREQ_RECV_STATUS;
-  reqs[1].data.recv_status.details = &ls->details;
-  reqs[1].data.recv_status.details_capacity = &ls->details_capacity;
-  reqs[1].data.recv_status.code = &ls->status;
-  reqs[2].op = GRPC_IOREQ_RECV_CLOSE;
-  err = start_ioreq(call, reqs, 3, finish_status, NULL);
-  if (err != GRPC_CALL_OK) goto done;
-done:
-  unlock(call);
-  return err;
-}
-grpc_call_error grpc_call_server_accept_old(grpc_call *call,
-                                            grpc_completion_queue *cq,
-                                            void *finished_tag) {
-  grpc_ioreq reqs[2];
-  grpc_call_error err;
-  legacy_state *ls;
-  grpc_cq_begin_op(cq, call, GRPC_FINISHED);
-  lock(call);
-  ls = get_legacy_state(call);
-  err = bind_cq(call, cq);
-  if (err != GRPC_CALL_OK) return err;
-  ls->finished_tag = finished_tag;
-  reqs[0].op = GRPC_IOREQ_RECV_STATUS;
-  reqs[0].data.recv_status.details = NULL;
-  reqs[0].data.recv_status.details_capacity = 0;
-  reqs[0].data.recv_status.code = &ls->status;
-  reqs[1].op = GRPC_IOREQ_RECV_CLOSE;
-  err = start_ioreq(call, reqs, 2, finish_status, NULL);
-  unlock(call);
-  return err;
-}
-static void finish_send_initial_metadata(grpc_call *call, grpc_op_error status, void *tag) {}
-grpc_call_error grpc_call_server_end_initial_metadata_old(grpc_call *call, gpr_uint32 flags) {
-  grpc_call_element *elem;
-  grpc_call_op op;
-  if (call->is_client) {
-    gpr_log(GPR_ERROR, "can only call %s on servers", __FUNCTION__);
-    return GRPC_CALL_ERROR_NOT_ON_CLIENT;
-  }
-  if (call->state >= CALL_STARTED) {
-    gpr_log(GPR_ERROR, "call is already started");
-    return GRPC_CALL_ERROR_ALREADY_INVOKED;
-  }
-  if (flags & GRPC_WRITE_NO_COMPRESS) {
-    return GRPC_CALL_ERROR_INVALID_FLAGS;
-  }
-  call->state = CALL_STARTED;
-  op.type = GRPC_SEND_START;
-  op.dir = GRPC_CALL_DOWN;
-  op.flags = flags;
-  op.done_cb = do_nothing;
-  op.data.start.pollset = grpc_cq_pollset(call->cq);
-  op.user_data = NULL;
-  elem = CALL_ELEM_FROM_CALL(call, 0);
-  elem->filter->call_op(elem, NULL, &op);
-  return GRPC_CALL_OK;
-}
@@ -284 +174 @@ static void request_more_data(grpc_call *call) {
-static void lock(grpc_call *call) { gpr_mu_lock(&call->mu){ gpr_mu_lock(&call->mu); }
+static void lock(grpc_call *call) { gpr_mu_lock(&call->mu); }
@@ -351 +241,2 @@ no_details:
-static void finish_ioreq_op(grpc_call *call, grpc_ioreq_op op, grpc_op_error status) {
+static void finish_ioreq_op(grpc_call *call, grpc_ioreq_op op,
+                            grpc_op_error status) {
@@ -381 +272,2 @@ static void finish_ioreq_op(grpc_call *call, grpc_ioreq_op op, grpc_op_error sta
-static void finish_send_op(grpc_call *call, grpc_ioreq_op op, grpc_op_error error) {
+static void finish_send_op(grpc_call *call, grpc_ioreq_op op,
+                           grpc_op_error error) {
@@ -514 +406,3 @@ static void enact_send_action(grpc_call *call, send_action sa) {
-static grpc_call_error start_ioreq_error(grpc_call *call, gpr_uint32 mutated_ops, grpc_call_error ret) {
+static grpc_call_error start_ioreq_error(grpc_call *call,
+                                         gpr_uint32 mutated_ops,
+                                         grpc_call_error ret) {
@@ -523 +417,4 @@ static grpc_call_error start_ioreq_error(grpc_call *call, gpr_uint32 mutated_ops
-static grpc_call_error start_ioreq(grpc_call *call, const grpc_ioreq *reqs, size_t nreqs, grpc_ioreq_completion_func completion, void *user_data) {
+static grpc_call_error start_ioreq(grpc_call *call, const grpc_ioreq *reqs,
+                                   size_t nreqs,
+                                   grpc_ioreq_completion_func completion,
+                                   void *user_data) {
@@ -632 +529,2 @@ static grpc_call_error start_ioreq(grpc_call *call, const grpc_ioreq *reqs, size
-static void call_start_ioreq_done(grpc_call *call, grpc_op_error status, void *user_data) {
+static void call_start_ioreq_done(grpc_call *call, grpc_op_error status,
+                                  void *user_data) {
@@ -635 +533,2 @@ static void call_start_ioreq_done(grpc_call *call, grpc_op_error status, void *u
-grpc_call_error grpc_call_start_ioreq(grpc_call *call, const grpc_ioreq *reqs, size_t nreqs, void *tag) {
+grpc_call_error grpc_call_start_ioreq(grpc_call *call, const grpc_ioreq *reqs,
+                                      size_t nreqs, void *tag) {
@@ -642 +541,3 @@ grpc_call_error grpc_call_start_ioreq(grpc_call *call, const grpc_ioreq *reqs, s
-grpc_call_error grpc_call_start_ioreq_and_call_back(grpc_call *call, const grpc_ioreq *reqs, size_t nreqs, grpc_ioreq_completion_func on_complete, void *user_data) {
+grpc_call_error grpc_call_start_ioreq_and_call_back(
+    grpc_call *call, const grpc_ioreq *reqs, size_t nreqs,
+    grpc_ioreq_completion_func on_complete, void *user_data) {
@@ -649,34 +550,6 @@ grpc_call_error grpc_call_start_ioreq_and_call_back(grpc_call *call, const grpc_
-grpc_call_error grpc_call_start_read_old(grpc_call *call, void *tag) {
-  legacy_state *ls;
-  grpc_ioreq req;
-  grpc_call_error err;
-  grpc_cq_begin_op(call->cq, call, GRPC_READ);
-  lock(call);
-  ls = get_legacy_state(call);
-  req.op = GRPC_IOREQ_RECV_MESSAGE;
-  req.data.recv_message = &ls->msg_in;
-  err = start_ioreq(call, &req, 1, finish_read, tag);
-  unlock(call);
-  return err;
-}
-static void finish_write(grpc_call *call, grpc_op_error status, void *tag) {
-  lock(call);
-  grpc_byte_buffer_destroy(get_legacy_state(call)->msg_out);
-  unlock(call);
-  grpc_cq_end_write_accepted(call->cq, tag, call, do_nothing, NULL, status);
-}
-grpc_call_error grpc_call_start_write_old(grpc_call *call,
-                                          grpc_byte_buffer *byte_buffer,
-                                          void *tag, gpr_uint32 flags) {
-  grpc_ioreq req;
-  legacy_state *ls;
-  grpc_call_error err;
-  grpc_cq_begin_op(call->cq, call, GRPC_WRITE_ACCEPTED);
-  lock(call);
-  ls = get_legacy_state(call);
-  ls->msg_out = grpc_byte_buffer_copy(byte_buffer);
-  req.op = GRPC_IOREQ_SEND_MESSAGE;
-  req.data.send_message = ls->msg_out;
-  err = start_ioreq(call, &req, 1, finish_write, tag);
-  unlock(call);
-  return err;
+void grpc_call_destroy(grpc_call *c) {
+  int cancel;
+  lock(c);
+  if (c->have_alarm) {
+    grpc_alarm_cancel(&c->alarm);
+    c->have_alarm = 0;
@@ -684,2 +557,4 @@ grpc_call_error grpc_call_start_write_old(grpc_call *call,
-static void finish_finish(grpc_call *call, grpc_op_error status, void *tag) {
-  grpc_cq_end_finish_accepted(call->cq, tag, call, do_nothing, NULL, status);
+  cancel = !c->stream_closed;
+  unlock(c);
+  if (cancel) grpc_call_cancel(c);
+  grpc_call_internal_unref(c, 1);
@@ -687 +562 @@ static void finish_finish(grpc_call *call, grpc_op_error status, void *tag) {
-grpc_call_error grpc_call_writes_done_old(grpc_call *call, void *tag) {
+grpc_call_error grpc_call_cancel(grpc_call *c) {
@@ -690,25 +565 @@ grpc_call_error grpc_call_writes_done_old(grpc_call *call, void *tag) {
-  if (!call->is_client) {
-    return GRPC_CALL_ERROR_NOT_ON_SERVER;
-  }
-  switch (call->state) {
-    case CALL_CREATED:
-    case CALL_BOUNDCQ:
-      return GRPC_CALL_ERROR_NOT_INVOKED;
-    case CALL_FINISHED:
-      return GRPC_CALL_ERROR_ALREADY_FINISHED;
-    case CALL_STARTED:
-      break;
-  }
-  if (call->have_write) {
-    return GRPC_CALL_ERROR_TOO_MANY_OPERATIONS;
-  }
-  grpc_cq_begin_op(call->cq, call, GRPC_FINISH_ACCEPTED);
-  call->write_tag = tag;
-  call->have_write = 1;
-  gpr_mu_lock(&call->read_mu);
-  if (!call->received_start) {
-    call->pending_writes_done = 1;
-    gpr_mu_unlock(&call->read_mu);
-  } else {
-    gpr_mu_unlock(&call->read_mu);
-    op.type = GRPC_SEND_FINISH;
+  op.type = GRPC_CANCEL_OP;
@@ -717,3 +568,3 @@ grpc_call_error grpc_call_writes_done_old(grpc_call *call, void *tag) {
-    op.done_cb = done_writes_done;
-    op.user_data = call;
-    elem = CALL_ELEM_FROM_CALL(call, 0);
+  op.done_cb = do_nothing;
+  op.user_data = NULL;
+  elem = CALL_ELEM_FROM_CALL(c, 0);
@@ -721 +571,0 @@ grpc_call_error grpc_call_writes_done_old(grpc_call *call, void *tag) {
-  }
@@ -724 +574 @@ grpc_call_error grpc_call_writes_done_old(grpc_call *call, void *tag) {
-grpc_call_error grpc_call_start_write_status_old(grpc_call *call,
+grpc_call_error grpc_call_cancel_with_status(grpc_call *c,
@@ -726,18 +576,9 @@ grpc_call_error grpc_call_start_write_status_old(grpc_call *call,
-                                                 const char *details,
-                                                 void *tag) {
-  grpc_ioreq reqs[3];
-  grpc_call_error err;
-  legacy_state *ls;
-  grpc_cq_begin_op(call->cq, call, GRPC_FINISH_ACCEPTED);
-  lock(call);
-  ls = get_legacy_state(call);
-  reqs[0].op = GRPC_IOREQ_SEND_TRAILING_METADATA;
-  reqs[0].data.send_metadata.count = ls->md_out_count[ls->md_out_buffer];
-  reqs[0].data.send_metadata.metadata = ls->md_out[ls->md_out_buffer];
-  reqs[1].op = GRPC_IOREQ_SEND_STATUS;
-  reqs[1].data.send_status.code = status;
-  reqs[1].data.send_status.details = gpr_strdup(details);
-  reqs[2].op = GRPC_IOREQ_SEND_CLOSE;
-  err = start_ioreq(call, reqs, 3, finish_finish, tag);
-  unlock(call);
-  return err;
+                                             const char *description) {
+  grpc_mdstr *details =
+      description ? grpc_mdstr_from_string(c->metadata_context, description)
+                  : NULL;
+  lock(c);
+  set_status_code(c, STATUS_FROM_API_OVERRIDE, status);
+  set_status_details(c, STATUS_FROM_API_OVERRIDE, details);
+  unlock(c);
+  return grpc_call_cancel(c);
@@ -745,75 +586,5 @@ grpc_call_error grpc_call_start_write_status_old(grpc_call *call,
-#define STATUS_OFFSET 1
-static void destroy_status(void *ignored) {}
-static gpr_uint32 decode_status(grpc_mdelem *md) {
-  gpr_uint32 status;
-  void *user_data = grpc_mdelem_get_user_data(md, destroy_status);
-  if (user_data) {
-    status = ((gpr_uint32)(gpr_intptr) user_data) - STATUS_OFFSET;
-  } else {
-    if (!gpr_parse_bytes_to_uint32(grpc_mdstr_as_c_string(md->value),
-                                   GPR_SLICE_LENGTH(md->value->slice),
-                                   &status)) {
-      status = GRPC_STATUS_UNKNOWN;
-    }
-    grpc_mdelem_set_user_data(md, destroy_status,
-                              (void *)(gpr_intptr)(status + STATUS_OFFSET));
-  }
-  return status;
-}
-void grpc_call_recv_metadata(grpc_call_element *elem, grpc_mdelem *md) {
-  grpc_call *call = CALL_FROM_TOP_ELEM(elem);
-  grpc_mdstr *key = md->key;
-  grpc_metadata_array *dest;
-  grpc_metadata *mdusr;
-  lock(call);
-  if (key == grpc_channel_get_status_string(call->channel)) {
-    set_status_code(call, STATUS_FROM_WIRE, decode_status(md));
-    grpc_mdelem_unref(md);
-  } else if (key == grpc_channel_get_message_string(call->channel)) {
-    set_status_details(call, STATUS_FROM_WIRE, grpc_mdstr_ref(md->value));
-    grpc_mdelem_unref(md);
-  } else {
-    if (!call->got_initial_metadata) {
-      dest = call->requests[GRPC_IOREQ_RECV_INITIAL_METADATA].set <
-                     GRPC_IOREQ_OP_COUNT
-                 ? call->requests[GRPC_IOREQ_RECV_INITIAL_METADATA]
-                       .data.recv_metadata
-                 : &call->buffered_initial_metadata;
-    } else {
-      dest = call->requests[GRPC_IOREQ_RECV_TRAILING_METADATA].set <
-                     GRPC_IOREQ_OP_COUNT
-                 ? call->requests[GRPC_IOREQ_RECV_TRAILING_METADATA]
-                       .data.recv_metadata
-                 : &call->buffered_trailing_metadata;
-    }
-    if (dest->count == dest->capacity) {
-      dest->capacity = GPR_MAX(dest->capacity + 8, dest->capacity * 2);
-      dest->metadata =
-          gpr_realloc(dest->metadata, sizeof(grpc_metadata) * dest->capacity);
-    }
-    mdusr = &dest->metadata[dest->count++];
-    mdusr->key = (char *)grpc_mdstr_as_c_string(md->key);
-    mdusr->value = (char *)grpc_mdstr_as_c_string(md->value);
-    mdusr->value_length = GPR_SLICE_LENGTH(md->value->slice);
-    if (call->owned_metadata_count == call->owned_metadata_capacity) {
-      call->owned_metadata_capacity = GPR_MAX(
-          call->owned_metadata_capacity + 8, call->owned_metadata_capacity * 2);
-      call->owned_metadata =
-          gpr_realloc(call->owned_metadata,
-                      sizeof(grpc_mdelem *) * call->owned_metadata_capacity);
-    }
-    call->owned_metadata[call->owned_metadata_count++] = md;
-  }
-  unlock(call);
-}
-void grpc_call_recv_message(grpc_call_element *elem,
-                            grpc_byte_buffer *byte_buffer) {
-  grpc_call *call = CALL_FROM_TOP_ELEM(elem);
-  lock(call);
-  if (call->requests[GRPC_IOREQ_RECV_MESSAGE].set < GRPC_IOREQ_OP_COUNT) {
-    *call->requests[GRPC_IOREQ_RECV_MESSAGE].data.recv_message = byte_buffer;
-    finish_ioreq_op(call, GRPC_IOREQ_RECV_MESSAGE, GRPC_OP_OK);
-  } else {
-    grpc_bbq_push(&call->incoming_queue, byte_buffer);
-  }
-  unlock(call);
+void grpc_call_execute_op(grpc_call *call, grpc_call_op *op) {
+  grpc_call_element *elem;
+  GPR_ASSERT(op->dir == GRPC_CALL_DOWN);
+  elem = CALL_ELEM_FROM_CALL(call, 0);
+  elem->filter->call_op(elem, NULL, op);
@@ -872,0 +644,76 @@ void grpc_call_stream_closed(grpc_call_element *elem) {
+#define STATUS_OFFSET 1
+static void destroy_status(void *ignored) {}
+static gpr_uint32 decode_status(grpc_mdelem *md) {
+  gpr_uint32 status;
+  void *user_data = grpc_mdelem_get_user_data(md, destroy_status);
+  if (user_data) {
+    status = ((gpr_uint32)(gpr_intptr) user_data) - STATUS_OFFSET;
+  } else {
+    if (!gpr_parse_bytes_to_uint32(grpc_mdstr_as_c_string(md->value),
+                                   GPR_SLICE_LENGTH(md->value->slice),
+                                   &status)) {
+      status = GRPC_STATUS_UNKNOWN;
+    }
+    grpc_mdelem_set_user_data(md, destroy_status,
+                              (void *)(gpr_intptr)(status + STATUS_OFFSET));
+  }
+  return status;
+}
+void grpc_call_recv_message(grpc_call_element *elem,
+                            grpc_byte_buffer *byte_buffer) {
+  grpc_call *call = CALL_FROM_TOP_ELEM(elem);
+  lock(call);
+  if (call->requests[GRPC_IOREQ_RECV_MESSAGE].set < GRPC_IOREQ_OP_COUNT) {
+    *call->requests[GRPC_IOREQ_RECV_MESSAGE].data.recv_message = byte_buffer;
+    finish_ioreq_op(call, GRPC_IOREQ_RECV_MESSAGE, GRPC_OP_OK);
+  } else {
+    grpc_bbq_push(&call->incoming_queue, byte_buffer);
+  }
+  unlock(call);
+}
+void grpc_call_recv_metadata(grpc_call_element *elem, grpc_mdelem *md) {
+  grpc_call *call = CALL_FROM_TOP_ELEM(elem);
+  grpc_mdstr *key = md->key;
+  grpc_metadata_array *dest;
+  grpc_metadata *mdusr;
+  lock(call);
+  if (key == grpc_channel_get_status_string(call->channel)) {
+    set_status_code(call, STATUS_FROM_WIRE, decode_status(md));
+    grpc_mdelem_unref(md);
+  } else if (key == grpc_channel_get_message_string(call->channel)) {
+    set_status_details(call, STATUS_FROM_WIRE, grpc_mdstr_ref(md->value));
+    grpc_mdelem_unref(md);
+  } else {
+    if (!call->got_initial_metadata) {
+      dest = call->requests[GRPC_IOREQ_RECV_INITIAL_METADATA].set <
+                     GRPC_IOREQ_OP_COUNT
+                 ? call->requests[GRPC_IOREQ_RECV_INITIAL_METADATA]
+                       .data.recv_metadata
+                 : &call->buffered_initial_metadata;
+    } else {
+      dest = call->requests[GRPC_IOREQ_RECV_TRAILING_METADATA].set <
+                     GRPC_IOREQ_OP_COUNT
+                 ? call->requests[GRPC_IOREQ_RECV_TRAILING_METADATA]
+                       .data.recv_metadata
+                 : &call->buffered_trailing_metadata;
+    }
+    if (dest->count == dest->capacity) {
+      dest->capacity = GPR_MAX(dest->capacity + 8, dest->capacity * 2);
+      dest->metadata =
+          gpr_realloc(dest->metadata, sizeof(grpc_metadata) * dest->capacity);
+    }
+    mdusr = &dest->metadata[dest->count++];
+    mdusr->key = (char *)grpc_mdstr_as_c_string(md->key);
+    mdusr->value = (char *)grpc_mdstr_as_c_string(md->value);
+    mdusr->value_length = GPR_SLICE_LENGTH(md->value->slice);
+    if (call->owned_metadata_count == call->owned_metadata_capacity) {
+      call->owned_metadata_capacity = GPR_MAX(
+          call->owned_metadata_capacity + 8, call->owned_metadata_capacity * 2);
+      call->owned_metadata =
+          gpr_realloc(call->owned_metadata,
+                      sizeof(grpc_mdelem *) * call->owned_metadata_capacity);
+    }
+    call->owned_metadata[call->owned_metadata_count++] = md;
+  }
+  unlock(call);
+}
@@ -911,36 +758,26 @@ static void destroy_legacy_state(legacy_state *ls) {
-static void destroy_legacy_state(legacy_state *ls);
-typedef enum { REQ_INITIAL = 0, REQ_READY, REQ_DONE } req_state;
-typedef enum {
-  SEND_NOTHING,
-  SEND_INITIAL_METADATA,
-  SEND_MESSAGE,
-  SEND_TRAILING_METADATA_AND_FINISH,
-  SEND_FINISH
-} send_action;
-typedef struct {
-  grpc_ioreq_completion_func on_complete;
-  void *user_data;
-  grpc_op_error status;
-} completed_request;
-#define REQSET_EMPTY 255
-#define REQSET_DONE 254
-typedef struct reqinfo {
-  grpc_ioreq_data data;
-  gpr_uint8 set;
-  grpc_op_error status;
-  grpc_ioreq_completion_func on_complete;
-  void *user_data;
-  gpr_uint32 need_mask;
-  gpr_uint32 complete_mask;
-} reqinfo;
-typedef enum {
-  STATUS_FROM_API_OVERRIDE = 0,
-  STATUS_FROM_WIRE,
-  STATUS_SOURCE_COUNT
-} status_source;
-typedef struct {
-  gpr_uint8 set;
-  grpc_status_code code;
-  grpc_mdstr *details;
-} received_status;
-static void finish_status(grpc_call *call, grpc_op_error status, void *ignored) {
+grpc_call_error grpc_call_add_metadata_old(grpc_call *call,
+                                           grpc_metadata *metadata,
+                                           gpr_uint32 flags) {
+  legacy_state *ls;
+  grpc_metadata *mdout;
+  lock(call);
+  ls = get_legacy_state(call);
+  if (ls->md_out_count[ls->md_out_buffer] ==
+      ls->md_out_capacity[ls->md_out_buffer]) {
+    ls->md_out_capacity[ls->md_out_buffer] =
+        GPR_MAX(ls->md_out_capacity[ls->md_out_buffer] * 3 / 2,
+                ls->md_out_capacity[ls->md_out_buffer] + 8);
+    ls->md_out[ls->md_out_buffer] = gpr_realloc(
+        ls->md_out[ls->md_out_buffer],
+        sizeof(grpc_metadata) * ls->md_out_capacity[ls->md_out_buffer]);
+  }
+  mdout = &ls->md_out[ls->md_out_buffer][ls->md_out_count[ls->md_out_buffer]++];
+  mdout->key = gpr_strdup(metadata->key);
+  mdout->value = gpr_malloc(metadata->value_length);
+  mdout->value_length = metadata->value_length;
+  memcpy(mdout->value, metadata->value, metadata->value_length);
+  unlock(call);
+  return GRPC_CALL_OK;
+}
+static void finish_status(grpc_call *call, grpc_op_error status,
+                          void *ignored) {
@@ -955 +792,2 @@ static void finish_status(grpc_call *call, grpc_op_error status, void *ignored)
-static void finish_recv_metadata(grpc_call *call, grpc_op_error status, void *tag) {
+static void finish_recv_metadata(grpc_call *call, grpc_op_error status,
+                                 void *tag) {
@@ -969 +807,75 @@ static void finish_recv_metadata(grpc_call *call, grpc_op_error status, void *ta
-static void finish_send_metadata(grpc_call *call, grpc_op_error status, void *tag) {}
+static void finish_send_metadata(grpc_call *call, grpc_op_error status,
+                                 void *tag) {}
+grpc_call_error grpc_call_invoke_old(grpc_call *call, grpc_completion_queue *cq,
+                                     void *metadata_read_tag,
+                                     void *finished_tag, gpr_uint32 flags) {
+  grpc_ioreq reqs[3];
+  legacy_state *ls;
+  grpc_call_error err;
+  grpc_cq_begin_op(cq, call, GRPC_CLIENT_METADATA_READ);
+  grpc_cq_begin_op(cq, call, GRPC_FINISHED);
+  lock(call);
+  ls = get_legacy_state(call);
+  err = bind_cq(call, cq);
+  if (err != GRPC_CALL_OK) goto done;
+  ls->finished_tag = finished_tag;
+  reqs[0].op = GRPC_IOREQ_SEND_INITIAL_METADATA;
+  reqs[0].data.send_metadata.count = ls->md_out_count[ls->md_out_buffer];
+  reqs[0].data.send_metadata.metadata = ls->md_out[ls->md_out_buffer];
+  ls->md_out_buffer++;
+  err = start_ioreq(call, reqs, 1, finish_send_metadata, NULL);
+  if (err != GRPC_CALL_OK) goto done;
+  reqs[0].op = GRPC_IOREQ_RECV_INITIAL_METADATA;
+  reqs[0].data.recv_metadata = &ls->initial_md_in;
+  err = start_ioreq(call, reqs, 1, finish_recv_metadata, metadata_read_tag);
+  if (err != GRPC_CALL_OK) goto done;
+  reqs[0].op = GRPC_IOREQ_RECV_TRAILING_METADATA;
+  reqs[0].data.recv_metadata = &ls->trailing_md_in;
+  reqs[1].op = GRPC_IOREQ_RECV_STATUS;
+  reqs[1].data.recv_status.details = &ls->details;
+  reqs[1].data.recv_status.details_capacity = &ls->details_capacity;
+  reqs[1].data.recv_status.code = &ls->status;
+  reqs[2].op = GRPC_IOREQ_RECV_CLOSE;
+  err = start_ioreq(call, reqs, 3, finish_status, NULL);
+  if (err != GRPC_CALL_OK) goto done;
+done:
+  unlock(call);
+  return err;
+}
+grpc_call_error grpc_call_server_accept_old(grpc_call *call,
+                                            grpc_completion_queue *cq,
+                                            void *finished_tag) {
+  grpc_ioreq reqs[2];
+  grpc_call_error err;
+  legacy_state *ls;
+  grpc_cq_begin_op(cq, call, GRPC_FINISHED);
+  lock(call);
+  ls = get_legacy_state(call);
+  err = bind_cq(call, cq);
+  if (err != GRPC_CALL_OK) return err;
+  ls->finished_tag = finished_tag;
+  reqs[0].op = GRPC_IOREQ_RECV_STATUS;
+  reqs[0].data.recv_status.details = NULL;
+  reqs[0].data.recv_status.details_capacity = 0;
+  reqs[0].data.recv_status.code = &ls->status;
+  reqs[1].op = GRPC_IOREQ_RECV_CLOSE;
+  err = start_ioreq(call, reqs, 2, finish_status, NULL);
+  unlock(call);
+  return err;
+}
+static void finish_send_initial_metadata(grpc_call *call, grpc_op_error status,
+                                         void *tag) {}
+grpc_call_error grpc_call_server_end_initial_metadata_old(grpc_call *call,
+                                                          gpr_uint32 flags) {
+  grpc_ioreq req;
+  grpc_call_error err;
+  legacy_state *ls;
+  lock(call);
+  ls = get_legacy_state(call);
+  req.op = GRPC_IOREQ_SEND_INITIAL_METADATA;
+  req.data.send_metadata.count = ls->md_out_count[ls->md_out_buffer];
+  req.data.send_metadata.metadata = ls->md_out[ls->md_out_buffer];
+  err = start_ioreq(call, &req, 1, finish_send_initial_metadata, NULL);
+  unlock(call);
+  return err;
+}
@@ -988,0 +901,69 @@ static void finish_read(grpc_call *call, grpc_op_error error, void *tag) {
+grpc_call_error grpc_call_start_read_old(grpc_call *call, void *tag) {
+  legacy_state *ls;
+  grpc_ioreq req;
+  grpc_call_error err;
+  grpc_cq_begin_op(call->cq, call, GRPC_READ);
+  lock(call);
+  ls = get_legacy_state(call);
+  req.op = GRPC_IOREQ_RECV_MESSAGE;
+  req.data.recv_message = &ls->msg_in;
+  err = start_ioreq(call, &req, 1, finish_read, tag);
+  unlock(call);
+  return err;
+}
+static void finish_write(grpc_call *call, grpc_op_error status, void *tag) {
+  lock(call);
+  grpc_byte_buffer_destroy(get_legacy_state(call)->msg_out);
+  unlock(call);
+  grpc_cq_end_write_accepted(call->cq, tag, call, do_nothing, NULL, status);
+}
+grpc_call_error grpc_call_start_write_old(grpc_call *call,
+                                          grpc_byte_buffer *byte_buffer,
+                                          void *tag, gpr_uint32 flags) {
+  grpc_ioreq req;
+  legacy_state *ls;
+  grpc_call_error err;
+  grpc_cq_begin_op(call->cq, call, GRPC_WRITE_ACCEPTED);
+  lock(call);
+  ls = get_legacy_state(call);
+  ls->msg_out = grpc_byte_buffer_copy(byte_buffer);
+  req.op = GRPC_IOREQ_SEND_MESSAGE;
+  req.data.send_message = ls->msg_out;
+  err = start_ioreq(call, &req, 1, finish_write, tag);
+  unlock(call);
+  return err;
+}
+static void finish_finish(grpc_call *call, grpc_op_error status, void *tag) {
+  grpc_cq_end_finish_accepted(call->cq, tag, call, do_nothing, NULL, status);
+}
+grpc_call_error grpc_call_writes_done_old(grpc_call *call, void *tag) {
+  grpc_ioreq req;
+  grpc_call_error err;
+  grpc_cq_begin_op(call->cq, call, GRPC_FINISH_ACCEPTED);
+  lock(call);
+  req.op = GRPC_IOREQ_SEND_CLOSE;
+  err = start_ioreq(call, &req, 1, finish_finish, tag);
+  unlock(call);
+  return err;
+}
+grpc_call_error grpc_call_start_write_status_old(grpc_call *call,
+                                                 grpc_status_code status,
+                                                 const char *details,
+                                                 void *tag) {
+  grpc_ioreq reqs[3];
+  grpc_call_error err;
+  legacy_state *ls;
+  grpc_cq_begin_op(call->cq, call, GRPC_FINISH_ACCEPTED);
+  lock(call);
+  ls = get_legacy_state(call);
+  reqs[0].op = GRPC_IOREQ_SEND_TRAILING_METADATA;
+  reqs[0].data.send_metadata.count = ls->md_out_count[ls->md_out_buffer];
+  reqs[0].data.send_metadata.metadata = ls->md_out[ls->md_out_buffer];
+  reqs[1].op = GRPC_IOREQ_SEND_STATUS;
+  reqs[1].data.send_status.code = status;
+  reqs[1].data.send_status.details = gpr_strdup(details);
+  reqs[2].op = GRPC_IOREQ_SEND_CLOSE;
+  err = start_ioreq(call, reqs, 3, finish_finish, tag);
+  unlock(call);
+  return err;
+}
