[
  {
    "code": [
      "typedef struct {",
      "    dict *dict;",
      "    double weight;",
      "} zsetopsrc;",
      "static void zremrangebyrankCommand(redisClient *c) {",
      "    int start = atoi(c->argv[2]->ptr);",
      "    int end = atoi(c->argv[3]->ptr);",
      "    robj *zsetobj;",
      "    zset *zs;",
      "",
      "    zsetobj = lookupKeyWrite(c->db,c->argv[1]);",
      "    if (zsetobj == NULL) {",
      "        addReply(c,shared.czero);",
      "    } else {",
      "        if (zsetobj->type != REDIS_ZSET) {",
      "            addReply(c,shared.wrongtypeerr);",
      "            return;",
      "        }",
      "",
      "        zs = zsetobj->ptr;",
      "        int llen = zs->zsl->length;",
      "        long deleted;",
      "",
      "        /* convert negative indexes */",
      "        if (start < 0) start = llen+start;",
      "        if (end < 0) end = llen+end;",
      "        if (start < 0) start = 0;",
      "        if (end < 0) end = 0;",
      "",
      "        /* indexes sanity checks */",
      "        if (start > end || start >= llen) {",
      "            addReply(c,shared.czero);",
      "            return;",
      "        }",
      "        if (end >= llen) end = llen-1;",
      "",
      "        /* increment start and end because zsl*Rank functions",
      "         * use 1-based rank */",
      "        deleted = zslDeleteRangeByRank(zs->zsl,start+1,end+1,zs->dict);",
      "        if (htNeedsResize(zs->dict)) dictResize(zs->dict);",
      "        server.dirty += deleted;",
      "        addReplyLong(c, deleted);",
      "    }",
      "}",
      "static int qsortCompareZsetopsrcByCardinality(const void *s1, const void *s2) {",
      "    zsetopsrc *d1 = (void*) s1, *d2 = (void*) s2;",
      "    unsigned long size1, size2;",
      "    size1 = d1->dict ? dictSize(d1->dict) : 0;",
      "    size2 = d2->dict ? dictSize(d2->dict) : 0;",
      "    return size1 - size2;",
      "}",
      "static void zunionInterGenericCommand(redisClient *c, robj *dstkey, int op) {",
      "    int i, j, zsetnum;",
      "    zsetopsrc *src;",
      "    robj *dstobj;",
      "    zset *dstzset;",
      "    dictIterator *di;",
      "    dictEntry *de;",
      "",
      "    /* expect zsetnum input keys to be given */",
      "    zsetnum = atoi(c->argv[2]->ptr);",
      "    if (zsetnum < 1) {",
      "        addReplySds(c,sdsnew(\"-ERR at least 1 input key is needed for ZUNION/ZINTER\\r\\n\"));",
      "        return;",
      "    }",
      "",
      "    /* test if the expected number of keys would overflow */",
      "    if (3+zsetnum > c->argc) {",
      "        addReply(c,shared.syntaxerr);",
      "        return;",
      "    }",
      "",
      "    /* read keys to be used for input */",
      "    src = malloc(sizeof(zsetopsrc) * zsetnum);",
      "    for (i = 0, j = 3; i < zsetnum; i++, j++) {",
      "        robj *zsetobj = lookupKeyWrite(c->db,c->argv[j]);",
      "        if (!zsetobj) {",
      "            src[i].dict = NULL;",
      "        } else {",
      "            if (zsetobj->type != REDIS_ZSET) {",
      "                zfree(src);",
      "                addReply(c,shared.wrongtypeerr);",
      "                return;",
      "            }",
      "            src[i].dict = ((zset*)zsetobj->ptr)->dict;",
      "        }",
      "",
      "        /* default all weights to 1 */",
      "        src[i].weight = 1.0;",
      "    }",
      "",
      "    /* parse optional extra arguments */",
      "    if (j < c->argc) {",
      "        int remaining = c->argc-j;",
      "",
      "        while (remaining) {",
      "            if (!strcasecmp(c->argv[j]->ptr,\"weights\")) {",
      "                j++; remaining--;",
      "                if (remaining < zsetnum) {",
      "                    zfree(src);",
      "                    addReplySds(c,sdsnew(\"-ERR not enough weights for ZUNION/ZINTER\\r\\n\"));",
      "                    return;",
      "                }",
      "                for (i = 0; i < zsetnum; i++, j++, remaining--) {",
      "                    src[i].weight = strtod(c->argv[j]->ptr, NULL);",
      "                }",
      "            } else {",
      "                zfree(src);",
      "                addReply(c,shared.syntaxerr);",
      "                return;",
      "            }",
      "        }",
      "    }",
      "",
      "    dstobj = createZsetObject();",
      "    dstzset = dstobj->ptr;",
      "",
      "    if (op == REDIS_OP_INTER) {",
      "        /* sort sets from the smallest to largest, this will improve our",
      "         * algorithm's performance */",
      "        qsort(src,zsetnum,sizeof(zsetopsrc), qsortCompareZsetopsrcByCardinality);",
      "",
      "        /* skip going over all entries if the smallest zset is NULL or empty */",
      "        if (src[0].dict && dictSize(src[0].dict) > 0) {",
      "            /* precondition: as src[0].dict is non-empty and the zsets are ordered",
      "             * from small to large, all src[i > 0].dict are non-empty too */",
      "            di = dictGetIterator(src[0].dict);",
      "            while((de = dictNext(di)) != NULL) {",
      "                double *score = zmalloc(sizeof(double));",
      "                *score = 0.0;",
      "",
      "                for (j = 0; j < zsetnum; j++) {",
      "                    dictEntry *other = (j == 0) ? de : dictFind(src[j].dict,dictGetEntryKey(de));",
      "                    if (other) {",
      "                        *score = *score + src[j].weight * (*(double*)dictGetEntryVal(other));",
      "                    } else {",
      "                        break;",
      "                    }",
      "                }",
      "",
      "                /* skip entry when not present in every source dict */",
      "                if (j != zsetnum) {",
      "                    zfree(score);",
      "                } else {",
      "                    robj *o = dictGetEntryKey(de);",
      "                    dictAdd(dstzset->dict,o,score);",
      "                    incrRefCount(o); /* added to dictionary */",
      "                    zslInsert(dstzset->zsl,*score,o);",
      "                    incrRefCount(o); /* added to skiplist */",
      "                }",
      "            }",
      "            dictReleaseIterator(di);",
      "        }",
      "    } else if (op == REDIS_OP_UNION) {",
      "        for (i = 0; i < zsetnum; i++) {",
      "            if (!src[i].dict) continue;",
      "",
      "            di = dictGetIterator(src[i].dict);",
      "            while((de = dictNext(di)) != NULL) {",
      "                /* skip key when already processed */",
      "                if (dictFind(dstzset->dict,dictGetEntryKey(de)) != NULL) continue;",
      "",
      "                double *score = zmalloc(sizeof(double));",
      "                *score = 0.0;",
      "                for (j = 0; j < zsetnum; j++) {",
      "                    if (!src[j].dict) continue;",
      "",
      "                    dictEntry *other = (i == j) ? de : dictFind(src[j].dict,dictGetEntryKey(de));",
      "                    if (other) {",
      "                        *score = *score + src[j].weight * (*(double*)dictGetEntryVal(other));",
      "                    }",
      "                }",
      "",
      "                robj *o = dictGetEntryKey(de);",
      "                dictAdd(dstzset->dict,o,score);",
      "                incrRefCount(o); /* added to dictionary */",
      "                zslInsert(dstzset->zsl,*score,o);",
      "                incrRefCount(o); /* added to skiplist */",
      "            }",
      "            dictReleaseIterator(di);",
      "        }",
      "    } else {",
      "        /* unknown operator */",
      "        redisAssert(op == REDIS_OP_INTER || op == REDIS_OP_UNION);",
      "    }",
      "",
      "    deleteKey(c->db,dstkey);",
      "    dictAdd(c->db->dict,dstkey,dstobj);",
      "    incrRefCount(dstkey);",
      "",
      "    addReplyLong(c, dstzset->zsl->length);",
      "    server.dirty++;",
      "    zfree(src);",
      "}",
      "static void zunionCommand(redisClient *c) {",
      "    zunionInterGenericCommand(c,c->argv[1], REDIS_OP_UNION);",
      "}",
      "static void zinterCommand(redisClient *c) {",
      "    zunionInterGenericCommand(c,c->argv[1], REDIS_OP_INTER);",
      "}"
    ],
    "label": "",
    "index": 2,
    "confidence": 0.4,
    "desc": "List merge."
  }
]