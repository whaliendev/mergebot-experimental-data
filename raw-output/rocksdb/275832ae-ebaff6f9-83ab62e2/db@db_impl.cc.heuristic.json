[
  {
    "code": [
      "          bool to_delete = compaction_filter->Filter(",
      "              compact->compaction->level(), ikey.user_key, value,",
      "              &compaction_filter_value, &value_changed);"
    ],
    "label": "",
    "index": 5,
    "confidence": 0.7,
    "desc": "Merge conflict caused by formatting issues."
  },
  {
    "desc": "List merge.",
    "confidence": 0.4,
    "index": 1,
    "label": "",
    "code": [
      "Status DBImpl::ProcessKeyValueCompaction(",
      "    SequenceNumber visible_at_tip,",
      "    SequenceNumber earliest_snapshot,",
      "    SequenceNumber latest_snapshot,",
      "    DeletionState& deletion_state,",
      "    bool bottommost_level,",
      "    int64_t& imm_micros,",
      "    Iterator* input,",
      "    CompactionState* compact,",
      "    bool is_compaction_v2,",
      "    LogBuffer* log_buffer) {",
      "  size_t combined_idx = 0;",
      "Status DBImpl::DoCompactionWork(CompactionState* compact,",
      "                                DeletionState& deletion_state,",
      "                                LogBuffer* log_buffer) {",
      "  assert(compact);",
      "  int64_t imm_micros = 0;  // Micros spent doing imm_ compactions",
      "  ColumnFamilyData* cfd = compact->compaction->column_family_data();",
      "  Log(options_.info_log,",
      "      \"[CF %u] Compacting %d@%d + %d@%d files, score %.2f slots available %d\",",
      "      cfd->GetID(), compact->compaction->num_input_files(0),",
      "      compact->compaction->level(), compact->compaction->num_input_files(1),",
      "      compact->compaction->output_level(), compact->compaction->score(),",
      "      options_.max_background_compactions - bg_compaction_scheduled_);",
      "  char scratch[2345];",
      "  compact->compaction->Summary(scratch, sizeof(scratch));",
      "  Log(options_.info_log, \"Compaction start summary: %s\\n\", scratch);",
      "",
      "  assert(compact->compaction->input_version()->NumLevelFiles(",
      "             compact->compaction->level()) > 0);",
      "  assert(compact->builder == nullptr);",
      "  assert(!compact->outfile);",
      "",
      "  SequenceNumber visible_at_tip = 0;",
      "  SequenceNumber earliest_snapshot;",
      "  SequenceNumber latest_snapshot = 0;",
      "  snapshots_.getAll(compact->existing_snapshots);",
      "  if (compact->existing_snapshots.size() == 0) {",
      "    // optimize for fast path if there are no snapshots",
      "    visible_at_tip = versions_->LastSequence();",
      "    earliest_snapshot = visible_at_tip;",
      "  } else {",
      "    latest_snapshot = compact->existing_snapshots.back();",
      "    // Add the current seqno as the 'latest' virtual",
      "    // snapshot to the end of this list.",
      "    compact->existing_snapshots.push_back(versions_->LastSequence());",
      "    earliest_snapshot = compact->existing_snapshots[0];",
      "  }",
      "",
      "  // Is this compaction producing files at the bottommost level?",
      "  bool bottommost_level = compact->compaction->BottomMostLevel();",
      "",
      "  // Allocate the output file numbers before we release the lock",
      "  AllocateCompactionOutputFileNumbers(compact);",
      "",
      "  // Release mutex while we're actually doing the compaction work",
      "  mutex_.Unlock();",
      "  // flush log buffer immediately after releasing the mutex",
      "  log_buffer->FlushBufferToLog();",
      "",
      "  const uint64_t start_micros = env_->NowMicros();",
      "  unique_ptr<Iterator> input(versions_->MakeInputIterator(compact->compaction));",
      "  input->SeekToFirst();"
    ]
  },
  {
    "code": [
      "          cfd->user_comparator()->Compare(ikey.user_key,",
      "                                          Slice(current_user_key)) != 0) {"
    ],
    "label": "",
    "index": 4,
    "confidence": 0.7,
    "desc": "De facto one-sided modification, accept their side."
  }
]