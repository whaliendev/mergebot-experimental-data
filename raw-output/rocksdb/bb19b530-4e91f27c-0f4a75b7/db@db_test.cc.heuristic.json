[
  {
    "desc": "Headers merge.",
    "confidence": 0.7,
    "index": 0,
    "label": "",
    "code": [
      "#include \"util/statistics.h\"",
      "#include \"util/hash_linklist_rep.h\""
    ]
  },
  {
    "code": [
      "void CopyFile(const std::string& source, const std::string& destination,",
      "                uint64_t size = 0) {",
      "    const EnvOptions soptions;",
      "    unique_ptr<SequentialFile> srcfile;",
      "    ASSERT_OK(env_->NewSequentialFile(source, &srcfile, soptions));",
      "    unique_ptr<WritableFile> destfile;",
      "    ASSERT_OK(env_->NewWritableFile(destination, &destfile, soptions));",
      "",
      "    if (size == 0) {",
      "      // default argument means copy everything",
      "      ASSERT_OK(env_->GetFileSize(source, &size));",
      "    }",
      "",
      "    char buffer[4096];",
      "    Slice slice;",
      "    while (size > 0) {",
      "      uint64_t one = std::min(uint64_t(sizeof(buffer)), size);",
      "      ASSERT_OK(srcfile->Read(one, &slice, buffer));",
      "      ASSERT_OK(destfile->Append(slice));",
      "      size -= slice.size();",
      "    }",
      "    ASSERT_OK(destfile->Close());",
      "  }",
      "// Used to test InplaceUpdate",
      "static UpdateStatus",
      "      updateInPlaceSmallerSize(char* prevValue, uint32_t* prevSize,",
      "                               Slice delta, std::string* newValue) {",
      "    if (prevValue == nullptr) {",
      "      *newValue = std::string(delta.size(), 'c');",
      "      return UpdateStatus::UPDATED;",
      "    } else {",
      "      *prevSize = *prevSize - 1;",
      "      std::string str_b = std::string(*prevSize, 'b');",
      "      memcpy(prevValue, str_b.c_str(), str_b.size());",
      "      return UpdateStatus::UPDATED_INPLACE;",
      "    }",
      "  }",
      "static UpdateStatus",
      "      updateInPlaceSmallerVarintSize(char* prevValue, uint32_t* prevSize,",
      "                                     Slice delta, std::string* newValue) {",
      "    if (prevValue == nullptr) {",
      "      *newValue = std::string(delta.size(), 'c');",
      "      return UpdateStatus::UPDATED;",
      "    } else {",
      "      *prevSize = 1;",
      "      std::string str_b = std::string(*prevSize, 'b');",
      "      memcpy(prevValue, str_b.c_str(), str_b.size());",
      "      return UpdateStatus::UPDATED_INPLACE;",
      "    }",
      "  }",
      "static UpdateStatus",
      "      updateInPlaceLargerSize(char* prevValue, uint32_t* prevSize,",
      "                              Slice delta, std::string* newValue) {",
      "    *newValue = std::string(delta.size(), 'c');",
      "    return UpdateStatus::UPDATED;",
      "  }",
      "static UpdateStatus",
      "      updateInPlaceNoAction(char* prevValue, uint32_t* prevSize,",
      "                            Slice delta, std::string* newValue) {",
      "    return UpdateStatus::UPDATE_FAILED;",
      "  }",
      "// Utility method to test InplaceUpdate",
      "void validateNumberOfEntries(int numValues) {",
      "      Iterator* iter = dbfull()->TEST_NewInternalIterator();",
      "      iter->SeekToFirst();",
      "      ASSERT_EQ(iter->status().ok(), true);",
      "      int seq = numValues;",
      "      while (iter->Valid()) {",
      "        ParsedInternalKey ikey;",
      "        ikey.sequence = -1;",
      "        ASSERT_EQ(ParseInternalKey(iter->key(), &ikey), true);",
      "",
      "        // checks sequence number for updates",
      "        ASSERT_EQ(ikey.sequence, (unsigned)seq--);",
      "        iter->Next();",
      "      }",
      "      delete iter;",
      "      ASSERT_EQ(0, seq);",
      "  }"
    ],
    "label": "",
    "index": 1,
    "confidence": 0.4,
    "desc": "List merge."
  }
]