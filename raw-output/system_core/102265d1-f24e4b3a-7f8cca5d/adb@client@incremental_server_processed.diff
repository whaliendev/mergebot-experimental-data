--- a/output/system_core/102265d1-f24e4b3a-7f8cca5d/adb@client@incremental_server.no_comments_mergebot.cpp
+++ b/output/system_core/102265d1-f24e4b3a-7f8cca5d/adb@client@incremental_server.no_comments_truth.cpp
@@ -85 +85,2 @@ static inline constexpr T readBigEndian(void* data) {
-struct ResponseHeader {
+struct RequestCommand {
+    RequestType request_type;
@@ -87 +88 @@ struct ResponseHeader {
-    CompressionType compression_type;
+    union {
@@ -89 +90,2 @@ struct ResponseHeader {
-    BlockSize block_size;
+        NumBlocks num_blocks;
+    };
@@ -92,0 +95 @@ struct ResponseHeader {
+    BlockType block_type;
@@ -127 +130,2 @@ public:
-    IncrementalServer(unique_fd fd, unique_fd adb_fd, unique_fd output_fd, std::vector<File> files): adb_fd_(std::move(fd)), adb_fd_(std::move(adb_fd)), output_fd_(std::move(output_fd)), files_(std::move(files)) {
+    IncrementalServer(unique_fd adb_fd, unique_fd output_fd, std::vector<File> files)
+        : adb_fd_(std::move(adb_fd)), output_fd_(std::move(output_fd)), files_(std::move(files)) {
@@ -170 +174 @@ private:
-    bool servingComplete_;
+    bool servingComplete_ = false;
@@ -348 +352,2 @@ void IncrementalServer::Flush() {
-bool IncrementalServer::Exit(std::optional<TimePoint> startTime, int missesCount, int missesSent) {
+bool IncrementalServer::ServingComplete(std::optional<TimePoint> startTime, int missesCount,
+                                        int missesSent) {
@@ -360,55 +365,109 @@ bool IncrementalServer::Exit(std::optional<TimePoint> startTime, int missesCount
-Result wait_for_installation(int read_fd) {
-    static constexpr int maxMessageSize = 256;
-    std::vector<char> child_stdout(CHUNK_SIZE);
-    int bytes_read;
-    int buf_size = 0;
-    while ((bytes_read = adb_read(read_fd, child_stdout.data() + buf_size,
-                                  child_stdout.size() - buf_size)) > 0) {
-        fprintf(stdout, "%.*s", bytes_read, child_stdout.data() + buf_size);
-        buf_size += bytes_read;
-        const std::string_view stdout_str(child_stdout.data(), buf_size);
-        if (stdout_str.find("Success") != std::string::npos) {
-            return Result::Success;
-        }
-        static constexpr auto failure_msg_head = "Failure ["sv;
-        if (const auto begin_itr = stdout_str.find(failure_msg_head);
-            begin_itr != std::string::npos) {
-            if (buf_size >= maxMessageSize) {
-                return Result::Failure;
-            }
-            const auto end_itr = stdout_str.rfind("]");
-            if (end_itr != std::string::npos && end_itr >= begin_itr + failure_msg_head.size()) {
-                return Result::Failure;
-            }
-        }
-        child_stdout.resize(buf_size + CHUNK_SIZE);
-    }
-    return Result::None;
-}
-Result wait_for_installation(int read_fd) {
-    static constexpr int maxMessageSize = 256;
-    std::vector<char> child_stdout(CHUNK_SIZE);
-    int bytes_read;
-    int buf_size = 0;
-    while ((bytes_read = adb_read(read_fd, child_stdout.data() + buf_size,
-                                  child_stdout.size() - buf_size)) > 0) {
-        fprintf(stdout, "%.*s", bytes_read, child_stdout.data() + buf_size);
-        buf_size += bytes_read;
-        const std::string_view stdout_str(child_stdout.data(), buf_size);
-        if (stdout_str.find("Success") != std::string::npos) {
-            return Result::Success;
-        }
-        static constexpr auto failure_msg_head = "Failure ["sv;
-        if (const auto begin_itr = stdout_str.find(failure_msg_head);
-            begin_itr != std::string::npos) {
-            if (buf_size >= maxMessageSize) {
-                return Result::Failure;
-            }
-            const auto end_itr = stdout_str.rfind("]");
-            if (end_itr != std::string::npos && end_itr >= begin_itr + failure_msg_head.size()) {
-                return Result::Failure;
-            }
-        }
-        child_stdout.resize(buf_size + CHUNK_SIZE);
-    }
-    return Result::None;
+bool IncrementalServer::Serve() {
+    if (!SendOkay(adb_fd_)) {
+        fprintf(stderr, "Connection is dead. Abort.\n");
+        return false;
+    }
+    std::unordered_set<FileId> prefetchedFiles;
+    bool doneSent = false;
+    int missesCount = 0;
+    int missesSent = 0;
+    using namespace std::chrono;
+    std::optional<TimePoint> startTime;
+    while (true) {
+        if (!doneSent && prefetches_.empty() &&
+            std::all_of(files_.begin(), files_.end(), [](const File& f) {
+                return f.sentBlocksCount == NumBlocks(f.sentBlocks.size());
+            })) {
+            fprintf(stderr, "All files should be loaded. Notifying the device.\n");
+            SendDone();
+            doneSent = true;
+        }
+        const bool blocking = prefetches_.empty();
+        if (blocking) {
+            Flush();
+        }
+        auto request = ReadRequest(blocking);
+        if (!startTime) {
+            startTime = high_resolution_clock::now();
+        }
+        if (request) {
+            FileId fileId = request->file_id;
+            BlockIdx blockIdx = request->block_idx;
+            switch (request->request_type) {
+                case DESTROY: {
+                    return true;
+                }
+                case SERVING_COMPLETE: {
+                    ServingComplete(startTime, missesCount, missesSent);
+                    break;
+                }
+                case BLOCK_MISSING: {
+                    ++missesCount;
+                    if (fileId < 0 || fileId >= (FileId)files_.size() || blockIdx < 0 ||
+                        blockIdx >= (BlockIdx)files_[fileId].sentBlocks.size()) {
+                        fprintf(stderr,
+                                "Received invalid data request for file_id %" PRId16
+                                " block_idx %" PRId32 ".\n",
+                                fileId, blockIdx);
+                        break;
+                    }
+                    if (auto res = SendBlock(fileId, blockIdx, true); res == SendResult::Error) {
+                        fprintf(stderr, "Failed to send block %" PRId32 ".\n", blockIdx);
+                    } else if (res == SendResult::Sent) {
+                        ++missesSent;
+                        prefetches_.emplace_front(files_[fileId], blockIdx + 1, 7);
+                    }
+                    break;
+                }
+                case PREFETCH: {
+                    if (fileId < 0) {
+                        fprintf(stderr,
+                                "Received invalid prefetch request for file_id %" PRId16 "\n",
+                                fileId);
+                        break;
+                    }
+                    if (!prefetchedFiles.insert(fileId).second) {
+                        fprintf(stderr,
+                                "Received duplicate prefetch request for file_id %" PRId16 "\n",
+                                fileId);
+                        break;
+                    }
+                    D("Received prefetch request for file_id %" PRId16 ".\n", fileId);
+                    prefetches_.emplace_back(files_[fileId]);
+                    break;
+                }
+                default:
+                    fprintf(stderr, "Invalid request %" PRId16 ",%" PRId16 ",%" PRId32 ".\n",
+                            request->request_type, fileId, blockIdx);
+                    break;
+            }
+        }
+        RunPrefetching();
+    }
+}
+bool serve(int connection_fd, int output_fd, int argc, const char** argv) {
+    auto connection_ufd = unique_fd(connection_fd);
+    auto output_ufd = unique_fd(output_fd);
+    if (argc <= 0) {
+        error_exit("inc-server: must specify at least one file.");
+    }
+    std::vector<File> files;
+    files.reserve(argc);
+    for (int i = 0; i < argc; ++i) {
+        auto filepath = argv[i];
+        struct stat st;
+        if (stat(filepath, &st)) {
+            fprintf(stderr, "Failed to stat input file %s. Abort.\n", filepath);
+            return {};
+        }
+        unique_fd fd(adb_open(filepath, O_RDONLY));
+        if (fd < 0) {
+            error_exit("inc-server: failed to open file '%s'.", filepath);
+        }
+        files.emplace_back(filepath, i, st.st_size, std::move(fd));
+    }
+    IncrementalServer server(std::move(connection_ufd), std::move(output_ufd), std::move(files));
+    printf("Serving...\n");
+    fclose(stdin);
+    fclose(stdout);
+    return server.Serve();
