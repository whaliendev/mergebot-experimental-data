--- a/output/system_core/e86a2c7c-85b3fcc5-cc1de48d/adb@services.no_comments_mergebot.c
+++ b/output/system_core/e86a2c7c-85b3fcc5-cc1de48d/adb@services.no_comments_truth.c
@@ -17,8 +16,0 @@
-#endif
-#if ADB_HOST
-# ifndef HAVE_WINSOCK
-# include <netinet/in.h>
-# include <netdb.h>
-# endif
-#else
-#include <sys/poll.h>
@@ -39,0 +32,143 @@ void *service_bootstrap_func(void *x)
+#if ADB_HOST
+ADB_MUTEX_DEFINE( dns_lock );
+static void dns_service(int fd, void *cookie)
+{
+    char *hostname = cookie;
+    struct hostent *hp;
+    unsigned zero = 0;
+    adb_mutex_lock(&dns_lock);
+    hp = gethostbyname(hostname);
+    if(hp == 0) {
+        writex(fd, &zero, 4);
+    } else {
+        writex(fd, hp->h_addr, 4);
+    }
+    adb_mutex_unlock(&dns_lock);
+    adb_close(fd);
+}
+#else
+extern int recovery_mode;
+static void recover_service(int s, void *cookie)
+{
+    unsigned char buf[4096];
+    unsigned count = (unsigned) cookie;
+    int fd;
+    fd = adb_creat("/tmp/update", 0644);
+    if(fd < 0) {
+        adb_close(s);
+        return;
+    }
+    while(count > 0) {
+        unsigned xfer = (count > 4096) ? 4096 : count;
+        if(readx(s, buf, xfer)) break;
+        if(writex(fd, buf, xfer)) break;
+        count -= xfer;
+    }
+    if(count == 0) {
+        writex(s, "OKAY", 4);
+    } else {
+        writex(s, "FAIL", 4);
+    }
+    adb_close(fd);
+    adb_close(s);
+    fd = adb_creat("/tmp/update.begin", 0644);
+    adb_close(fd);
+}
+void restart_root_service(int fd, void *cookie)
+{
+    char buf[100];
+    char value[PROPERTY_VALUE_MAX];
+    if (getuid() == 0) {
+        snprintf(buf, sizeof(buf), "adbd is already running as root\n");
+        writex(fd, buf, strlen(buf));
+        adb_close(fd);
+    } else {
+        property_get("ro.debuggable", value, "");
+        if (strcmp(value, "1") != 0) {
+            snprintf(buf, sizeof(buf), "adbd cannot run as root in production builds\n");
+            writex(fd, buf, strlen(buf));
+            adb_close(fd);
+            return;
+        }
+        property_set("service.adb.root", "1");
+        snprintf(buf, sizeof(buf), "restarting adbd as root\n");
+        writex(fd, buf, strlen(buf));
+        adb_close(fd);
+        sleep(1);
+        exit(1);
+    }
+}
+void restart_tcp_service(int fd, void *cookie)
+{
+    char buf[100];
+    char value[PROPERTY_VALUE_MAX];
+    int port = (int)cookie;
+    if (port <= 0) {
+        snprintf(buf, sizeof(buf), "invalid port\n");
+        writex(fd, buf, strlen(buf));
+        adb_close(fd);
+        return;
+    }
+    snprintf(value, sizeof(value), "%d", port);
+    property_set("service.adb.tcp.port", value);
+    snprintf(buf, sizeof(buf), "restarting in TCP mode port: %d\n", port);
+    writex(fd, buf, strlen(buf));
+    adb_close(fd);
+    sleep(1);
+    exit(1);
+}
+void restart_usb_service(int fd, void *cookie)
+{
+    char buf[100];
+    property_set("service.adb.tcp.port", "0");
+    snprintf(buf, sizeof(buf), "restarting in USB mode\n");
+    writex(fd, buf, strlen(buf));
+    adb_close(fd);
+    sleep(1);
+    exit(1);
+}
+void reboot_service(int fd, void *arg)
+{
+    char buf[100];
+    int ret;
+    sync();
+    ret = __reboot(LINUX_REBOOT_MAGIC1, LINUX_REBOOT_MAGIC2,
+                    LINUX_REBOOT_CMD_RESTART2, (char *)arg);
+    if (ret < 0) {
+        snprintf(buf, sizeof(buf), "reboot failed: %s\n", strerror(errno));
+        writex(fd, buf, strlen(buf));
+    }
+    adb_close(fd);
+}
+#endif
+#if 0
+static void echo_service(int fd, void *cookie)
+{
+    char buf[4096];
+    int r;
+    char *p;
+    int c;
+    for(;;) {
+        r = read(fd, buf, 4096);
+        if(r == 0) goto done;
+        if(r < 0) {
+            if(errno == EINTR) continue;
+            else goto done;
+        }
+        c = r;
+        p = buf;
+        while(c > 0) {
+            r = write(fd, p, c);
+            if(r > 0) {
+                c -= r;
+                p += r;
+                continue;
+            }
+            if((r < 0) && (errno == EINTR)) continue;
+            goto done;
+        }
+    }
+done:
+    close(fd);
+}
+#endif
@@ -63,0 +199,112 @@ static int create_service_thread(void (*func)(int, void *), void *cookie)
+#if !ADB_HOST
+static int create_subprocess(const char *cmd, const char *arg0, const char *arg1)
+{
+    char *devname;
+    int ptm;
+    pid_t pid;
+    ptm = unix_open("/dev/ptmx", O_RDWR);
+    if(ptm < 0){
+        printf("[ cannot open /dev/ptmx - %s ]\n",strerror(errno));
+        return -1;
+    }
+    fcntl(ptm, F_SETFD, FD_CLOEXEC);
+    if(grantpt(ptm) || unlockpt(ptm) ||
+       ((devname = (char*) ptsname(ptm)) == 0)){
+        printf("[ trouble with /dev/ptmx - %s ]\n", strerror(errno));
+        return -1;
+    }
+    pid = fork();
+    if(pid < 0) {
+        printf("- fork failed: %s -\n", strerror(errno));
+        return -1;
+    }
+    if(pid == 0){
+        int pts;
+        setsid();
+        pts = unix_open(devname, O_RDWR);
+        if(pts < 0) exit(-1);
+        dup2(pts, 0);
+        dup2(pts, 1);
+        dup2(pts, 2);
+        adb_close(ptm);
+        execl(cmd, cmd, arg0, arg1, NULL);
+        fprintf(stderr, "- exec '%s' failed: %s (%d) -\n",
+                cmd, strerror(errno), errno);
+        exit(-1);
+    } else {
+        char text[64];
+        snprintf(text, sizeof text, "/proc/%d/oom_adj", pid);
+        int fd = adb_open(text, O_WRONLY);
+        if (fd >= 0) {
+            adb_write(fd, "0", 1);
+            adb_close(fd);
+        } else {
+           D("adb: unable to open %s\n", text);
+        }
+        return ptm;
+    }
+}
+#endif
+#if ADB_HOST
+#define SHELL_COMMAND "/bin/sh"
+#else
+#define SHELL_COMMAND "/system/bin/sh"
+#endif
+#if !ADB_HOST
+static void shell_service(int s, void *command)
+{
+    char buffer[MAX_PAYLOAD];
+    char buffer2[MAX_PAYLOAD];
+    struct pollfd ufds[2];
+    int fd, ret = 0;
+    unsigned count = 0;
+    char** args = (char **)command;
+    fd = create_subprocess(SHELL_COMMAND, args[0], args[1]);
+    while (1) {
+        while (count < sizeof(buffer)) {
+            ufds[0].fd = fd;
+            ufds[0].events = POLLIN | POLLHUP;
+            ufds[0].revents = 0;
+            ufds[1].fd = s;
+            ufds[1].events = POLLIN | POLLHUP;
+            ufds[1].revents = 0;
+            ret = poll(ufds, 2, 100);
+            if (ret <= 0) {
+                D("poll returned %d\n", ret);
+                ret = 1;
+                break;
+            }
+            if (ufds[0].revents & POLLIN) {
+                ret = adb_read(fd, buffer + count, sizeof(buffer) - count);
+                D("read fd ret: %d, count: %d\n", ret, count);
+                if (ret > 0)
+                    count += ret;
+                else
+                    break;
+            }
+            if (ufds[1].revents & POLLIN) {
+                ret = adb_read(s, buffer2, sizeof(buffer2));
+                D("read s ret: %d\n", ret);
+                if (ret > 0)
+                    adb_write(fd, buffer2, ret);
+                else
+                    break;
+            }
+            if ((ufds[0].revents & POLLHUP) || (ufds[1].revents & POLLHUP)) {
+                ret = -1;
+                break;
+            }
+        }
+        D("writing: %d\n", count);
+        if (count > 0) {
+            adb_write(s, buffer, count);
+            count = 0;
+        }
+        if (ret <= 0)
+            break;
+    }
+    D("shell_service done\n");
+    adb_close(fd);
+    adb_close(s);
+}
+#endif
@@ -127 +373,0 @@ int service_to_fd(const char *name)
-<<<<<<< HEAD
@@ -133,8 +378,0 @@ int service_to_fd(const char *name)
-||||||| cc1de48dc
-=======
-    } else if(!strncmp(name, "reboot:", 7)) {
-        char* arg = name + 7;
-        if (*name == 0)
-            arg = NULL;
-        ret = create_service_thread(reboot_service, arg);
->>>>>>> 85b3fcc5
