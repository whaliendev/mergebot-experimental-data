[
  {
    "code": [
      "static int memory_stat_from_cgroup(struct memory_stat* mem_st, int pid, uid_t uid) {",
      "    FILE *fp;",
      "    char buf[PATH_MAX];"
    ],
    "label": "",
    "index": 3,
    "confidence": 0.7,
    "desc": "Merge conflict caused by formatting issues."
  },
  {
    "desc": "Added code or method extraction, accept our side.",
    "confidence": 0.7,
    "index": 0,
    "label": "",
    "code": [
      "static bool per_app_memcg;",
      "static int swap_free_low_percentage;",
      "static bool use_psi_monitors = false;",
      "static struct psi_threshold psi_thresholds[VMPRESS_LEVEL_COUNT] = {",
      "    { PSI_SOME, 70 },    /* 70ms out of 1sec for partial stall */",
      "    { PSI_SOME, 100 },   /* 100ms out of 1sec for partial stall */",
      "    { PSI_FULL, 70 },    /* 70ms out of 1sec for complete stall */",
      "};",
      "",
      "static android_log_context ctx;"
    ]
  },
  {
    "code": [
      "static void cmd_procpurge() {",
      "    int i;",
      "    struct proc *procp;",
      "    struct proc *next;",
      "",
      "    if (use_inkernel_interface) {",
      "        return;",
      "    }",
      "",
      "    for (i = 0; i <= ADJTOSLOT(OOM_SCORE_ADJ_MAX); i++) {",
      "        procadjslot_list[i].next = &procadjslot_list[i];",
      "        procadjslot_list[i].prev = &procadjslot_list[i];",
      "    }",
      "",
      "    for (i = 0; i < PIDHASH_SZ; i++) {",
      "        procp = pidhash[i];",
      "        while (procp) {",
      "            next = procp->pidhash_next;",
      "            free(procp);",
      "            procp = next;",
      "        }",
      "    }",
      "    memset(&pidhash[0], 0, sizeof(pidhash));",
      "}",
      "",
      "static void inc_killcnt(int oomadj) {",
      "    int slot = ADJTOSLOT(oomadj);",
      "    uint8_t idx = killcnt_idx[slot];",
      "",
      "    if (idx == KILLCNT_INVALID_IDX) {",
      "        /* index is not assigned for this oomadj */",
      "        if (killcnt_free_idx < MAX_DISTINCT_OOM_ADJ) {",
      "            killcnt_idx[slot] = killcnt_free_idx;",
      "            killcnt[killcnt_free_idx] = 1;",
      "            killcnt_free_idx++;",
      "        } else {",
      "            ALOGW(\"Number of distinct oomadj levels exceeds %d\",",
      "                MAX_DISTINCT_OOM_ADJ);",
      "        }",
      "    } else {",
      "        /*",
      "         * wraparound is highly unlikely and is detectable using total",
      "         * counter because it has to be equal to the sum of all counters",
      "         */",
      "        killcnt[idx]++;",
      "    }",
      "    /* increment total kill counter */",
      "    killcnt_total++;",
      "}",
      "",
      "static int get_killcnt(int min_oomadj, int max_oomadj) {",
      "    int slot;",
      "    int count = 0;",
      "",
      "    if (min_oomadj > max_oomadj)",
      "        return 0;",
      "",
      "    /* special case to get total kill count */",
      "    if (min_oomadj > OOM_SCORE_ADJ_MAX)",
      "        return killcnt_total;",
      "",
      "    while (min_oomadj <= max_oomadj &&",
      "           (slot = ADJTOSLOT(min_oomadj)) < ADJTOSLOT_COUNT) {",
      "        uint8_t idx = killcnt_idx[slot];",
      "        if (idx != KILLCNT_INVALID_IDX) {",
      "            count += killcnt[idx];",
      "        }",
      "        min_oomadj++;",
      "    }",
      "",
      "    return count;",
      "}",
      "",
      "static int cmd_getkillcnt(LMKD_CTRL_PACKET packet) {",
      "    struct lmk_getkillcnt params;",
      "",
      "    if (use_inkernel_interface) {",
      "        /* kernel driver does not expose this information */",
      "        return 0;",
      "    }",
      "",
      "    lmkd_pack_get_getkillcnt(packet, &params);",
      "",
      "    return get_killcnt(params.min_oomadj, params.max_oomadj);",
      "}",
      ""
    ],
    "label": "",
    "index": 1,
    "confidence": 0.7,
    "desc": "Added code or method extraction, accept our side."
  },
  {
    "code": [
      "    case LMK_PROCPURGE:",
      "        if (nargs != 0)",
      "            goto wronglen;",
      "        cmd_procpurge();",
      "        break;",
      "    case LMK_GETKILLCNT:",
      "        if (nargs != 2)",
      "            goto wronglen;",
      "        kill_cnt = cmd_getkillcnt(packet);",
      "        len = lmkd_pack_set_getkillcnt_repl(packet, kill_cnt);",
      "        if (ctrl_data_write(dsock_idx, (char *)packet, len) != len)",
      "            return;",
      "        break;"
    ],
    "label": "",
    "index": 2,
    "confidence": 0.7,
    "desc": "Added code or method extraction, accept our side."
  }
]